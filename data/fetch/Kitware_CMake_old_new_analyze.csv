sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_loc,new_loc,old_log,new_log,action_type,old_log_file,old_block,old_block_file,old_block_feature
47b3a57c9bc5c7db608bc3b59b139a902535255f,"Display subproject timing summary

Use the '--no-subproject-summary' option to disable timing summary.",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_1.cpp,"                 << static_cast<int>(percent + .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);
    if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
","                 << static_cast<int>(percent + .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);

    if (!this->CTest->GetLabelsForSubprojects().empty() &&
        this->CTest->GetSubprojectSummary()) {
      this->PrintSubprojectSummary();
    } else if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }

    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
",536,536,543,548,"sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start))","sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_0.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_0.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_1.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_1.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_2.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_2.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 26"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 13"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_3.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_3.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_4.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_4.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_5.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_5.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_6.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_6.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 71"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 2"", "" 0"", "" 3"", "" 3"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 9"", "" 0"", "" 17"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_7.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_7.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_10.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_8.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_8.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_9.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_9.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_10.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_10.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_11.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_11.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 26"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 13"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_12.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_12.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_13.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_13.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_14.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_14.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_15.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_15.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 71"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 2"", "" 0"", "" 3"", "" 3"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 9"", "" 0"", "" 17"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_16.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_16.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_22.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_17.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_17.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_18.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_18.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_19.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_19.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(buf+4, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_20.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_20.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 26"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 13"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_21.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_21.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_22.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_22.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_23.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_23.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 90"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_24.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_24.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 71"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 2"", "" 0"", "" 3"", "" 3"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 9"", "" 0"", "" 17"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE + 2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[++len] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_25.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_25.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_34.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_26.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_26.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_27.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_27.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
d6051ca39e2ac8e5afc8f6308fd1bda7d1e8c17b,"execute_process: Add option to get results of every child

Add a `RESULTS_VARIABLE` option to get the results of all children
in a pipeline of one or more `COMMAND`s.",[],Source/cmExecuteProcessCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_38.cpp,"    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
","    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[16];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
",287,297,291,301,"sprintf(buf, ""%d"", v)","sprintf(buf, ""%d"", v)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_28.cpp,"{
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_28.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 1"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig)","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_29.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_29.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code)","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_30.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_30.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig)","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_31.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_31.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code)","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_32.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_32.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_33.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_33.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_34.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_34.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 25"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 16"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 13"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_35.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_35.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_49.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3916,3912,3921,3917,"char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)","char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_36.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_36.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_37.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_37.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 89"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_51.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1092,1092,1099,1098,"*curl_mvaprintf(const char *format, va_list ap_save)","*curl_mvaprintf(const char *format, va_list ap_save)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_38.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_38.cpp,[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_52.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,646,655,"DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_39.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_39.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_55.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,2579,2639,"BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))","BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_40.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_40.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_41.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_41.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_42.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_42.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 25"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 16"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 13"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_43.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_43.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_60.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3915,3911,3920,3916,"char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)","char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_44.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_44.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_45.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_45.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 2"", "" 89"", "" 0"", "" 0"", "" 7"", "" 7"", "" 0"", "" 0"", "" 3"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 36"", "" 1"", "" 42"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 7"", "" 0"", "" 0"", "" 11"", "" 0"", "" 17"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_62.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1096,1096,1103,1102,"*curl_mvaprintf(const char *format, va_list ap_save)","*curl_mvaprintf(const char *format, va_list ap_save)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_46.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_46.cpp,[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_63.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE + 1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,646,655,"DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_47.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_47.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_66.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,2579,2639,"BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))","BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_48.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_48.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
48fa291469e5e8b3ae88fb846750df72468eb58a,"bindexplib: add ARM support

Fixes: #16728",[u'https://gitlab.kitware.com/cmake/cmake/issues/16728'],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_67.cpp,"    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
","    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_ARMNT)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
",323,326,323,326,"fprintf(stderr, ""File is an executable.  I don't dump those.\n"");","fprintf(stderr, ""File is an executable.  I don't dump those.\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_49.cpp,"{
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_49.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,367,369,"fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename)","fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_50.cpp,"{
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_50.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,374,376,"fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"")","fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_51.cpp,"{
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_51.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,382,384,"fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"")","fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_52.cpp,"{
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_52.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 4"", "" 0""]"
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,388,390,"fprintf(stderr, ""File is an executable.  I don't dump those.\n"")","fprintf(stderr, ""File is an executable.  I don't dump those.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_53.cpp,"{
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_53.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
7a8860afbc614f2215e083adadb25963fe8f4dfe,bindexplib: clang-format,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_69.cpp,"      pSymbolTable++;
    }
  }
private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType*  SymbolTable;
  bool Is64Bit;
};

bool
DumpFile(const char* filename,
         std::set<std::string>& symbols,
         std::set<std::string>& dataSymbols)
{
   HANDLE hFile;
   HANDLE hFileMapping;
   LPVOID lpFileBase;
   PIMAGE_DOS_HEADER dosHeader;

   hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(),
                       GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
           ((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64))
           && (dosHeader->e_sp == 0)
           ) {
      /*
      * The two tests above aren't what they look like.  They're
      * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
      * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
      */
      DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL>
        symbolDumper((PIMAGE_FILE_HEADER) lpFileBase, symbols, dataSymbols,
                     (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
   } else {
      // check for /bigobj format
      cmANON_OBJECT_HEADER_BIGOBJ* h =
        (cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase;
      if(h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
         DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX>
           symbolDumper((cmANON_OBJECT_HEADER_BIGOBJ*) lpFileBase, symbols,
                        dataSymbols,
                        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
         symbolDumper.DumpObjFile();
      } else {
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }
   }
   UnmapViewOfFile(lpFileBase);
   CloseHandle(hFileMapping);
   CloseHandle(hFile);
   return true;
}

bool bindexplib::AddObjectFile(const char* filename)
","      pSymbolTable++;
    }
  }

private:
  std::set<std::string>& Symbols;
  std::set<std::string>& DataSymbols;
  DWORD_PTR SymbolCount;
  PIMAGE_SECTION_HEADER SectionHeaders;
  ObjectHeaderType* ObjectImageHeader;
  SymbolTableType* SymbolTable;
  bool Is64Bit;
};

bool DumpFile(const char* filename, std::set<std::string>& symbols,
              std::set<std::string>& dataSymbols)
{
  HANDLE hFile;
  HANDLE hFileMapping;
  LPVOID lpFileBase;
  PIMAGE_DOS_HEADER dosHeader;

  hFile = CreateFileW(cmsys::Encoding::ToWide(filename).c_str(), GENERIC_READ,
                      FILE_SHARE_READ, NULL, OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL, 0);

  if (hFile == INVALID_HANDLE_VALUE) {
    fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
    return false;
  }

  hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
  if (hFileMapping == 0) {
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
    return false;
  }

  lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
  if (lpFileBase == 0) {
    CloseHandle(hFileMapping);
    CloseHandle(hFile);
    fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
    return false;
  }

  dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
  if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
    * really checking for IMAGE_FILE_HEADER.Machine == i386 (0x14C)
    * and IMAGE_FILE_HEADER.SizeOfOptionalHeader == 0;
    */
    DumpSymbols<IMAGE_FILE_HEADER, IMAGE_SYMBOL> symbolDumper(
      (PIMAGE_FILE_HEADER)lpFileBase, symbols, dataSymbols,
      (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64));
    symbolDumper.DumpObjFile();
  } else {
    // check for /bigobj format
    cmANON_OBJECT_HEADER_BIGOBJ* h = (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase;
    if (h->Sig1 == 0x0 && h->Sig2 == 0xffff) {
      DumpSymbols<cmANON_OBJECT_HEADER_BIGOBJ, cmIMAGE_SYMBOL_EX> symbolDumper(
        (cmANON_OBJECT_HEADER_BIGOBJ*)lpFileBase, symbols, dataSymbols,
        (h->Machine == IMAGE_FILE_MACHINE_AMD64));
      symbolDumper.DumpObjFile();
    } else {
      printf(""unrecognized file format in '%s'\n"", filename);
      return false;
    }
  }
  UnmapViewOfFile(lpFileBase);
  CloseHandle(hFileMapping);
  CloseHandle(hFile);
  return true;
}

bool bindexplib::AddObjectFile(const char* filename)
",339,342,417,415,"printf(""unrecognized file format in '%s'\n"", filename)","printf(""unrecognized file format in '%s'\n"", filename)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_54.cpp,"{
         printf(""unrecognized file format in '%s'\n"", filename);
         return false;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_54.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_70.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	/* Display warning and unset flag */
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
	return (ARCHIVE_WARN);
#endif
}
",563,562,582,575,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_55.cpp,"{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_55.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 1"", "" 36"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 2"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 2"", "" 0"", "" 0"", "" 5"", "" 0"", "" 7"", "" 5""]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_71.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
",1340,1329,1348,1338,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_56.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_56.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_72.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
",1219,1207,1226,1216,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_57.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_57.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_73.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	/* Display warning and unset flag */
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
	return (ARCHIVE_WARN);
#endif
}
",563,562,582,575,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_58.cpp,"{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_58.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 1"", "" 36"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 2"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 2"", "" 0"", "" 0"", "" 5"", "" 0"", "" 7"", "" 5""]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_74.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
",1340,1329,1348,1338,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_59.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_59.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_75.cpp,"	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname, a->restore_time);
	else
		a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
","	struct archive_read_disk *a = (struct archive_read_disk *)_a;

	if (a->tree != NULL)
		a->tree = tree_reopen(a->tree, pathname,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	else
		a->tree = tree_open(pathname, a->symlink_mode,
		    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
	if (a->tree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
",1219,1207,1226,1216,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_60.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_60.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,306,330,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_61.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_61.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"")","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_62.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_62.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_77.cpp,"	const char *path;
	ssize_t list_size;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	ssize_t list_size;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_63.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_63.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_78.cpp,"	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_64.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_64.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_80.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_65.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_65.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_81.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_66.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_66.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_82.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_67.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_67.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_83.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_83.cpp,"		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
","		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
",1643,1656,1643,1656,"archive_set_error(&a->archive, errno, ""statvfs failed"");","archive_set_error(&a->archive, errno, ""statvfs failed"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_68.cpp,"{
		t->current_filesystem->remote = -1;
		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_68.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_84.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_69.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_69.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_85.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_70.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_70.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_86.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_71.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_71.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_87.cpp,"#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}
	if (fstat(fd, &st) != 0) {
","#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		goto fail;
#endif
	}
	if (fstat(fd, &st) != 0) {
",277,277,278,278,"archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")","archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_72.cpp,"{
#if defined(_WIN32) && !defined(__CYGWIN__)
		wfilename = mine->filename.w;
		fd = _wopen(wfilename, O_RDONLY | O_BINARY);
		if (fd < 0 && errno == ENOENT) {
			wchar_t *fullpath;
			fullpath = __la_win_permissive_name_w(wfilename);
			if (fullpath != NULL) {
				fd = _wopen(fullpath, O_RDONLY | O_BINARY);
				free(fullpath);
			}
		}
		if (fd < 0) {
			archive_set_error(a, errno,
			    ""Failed to open '%S'"", wfilename);
			return (ARCHIVE_FATAL);
		}
#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_72.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 41"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 28"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 3"", "" 3"", "" 1"", "" 0"", "" 8"", "" 0"", "" 0"", "" 7"", "" 0"", "" 15"", "" 3""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_88.cpp,"		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		return (ARCHIVE_FATAL);
	}

	/*
","		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		goto fail;
	}

	/*
",287,287,288,288,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)","archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_73.cpp,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_73.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_89.cpp,"		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (mine == NULL || buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}
	mine->buffer = buffer;
	mine->fd = fd;
","		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		goto fail;
	}
	mine->buffer = buffer;
	mine->fd = fd;
",356,356,360,360,"archive_set_error(a, ENOMEM, ""No memory"")","archive_set_error(a, ENOMEM, ""No memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_74.cpp,"{
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_74.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_92.cpp,"	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
","	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
",178,163,184,167,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_75.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->name = ""lzma"";
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_75.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 52"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 1"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 27"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 3"", "" 0"", "" 0"", "" 8"", "" 0"", "" 9"", "" 4""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_76.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_76.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_77.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_77.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_78.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_78.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_79.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_79.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_80.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_80.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_81.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_81.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 3"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_82.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_82.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 3"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_83.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_83.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_94.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)malloc(sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ar, 0, sizeof(*ar));
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)calloc(1, sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
",104,104,109,109,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_84.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_84.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_95.cpp,"		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
","		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
",260,259,264,263,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_85.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_85.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_98.cpp,"		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
","		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			goto fail;
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
",1864,1864,1865,1865,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")","archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_86.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_86.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_99.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
",1990,1988,1990,1988,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_87.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_87.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_100.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a directory.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a directory.
",1999,1997,1999,1997,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_88.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_88.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_101.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
",2008,2006,2008,2006,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_89.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_89.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_102.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a regular file.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a regular file.
",2022,2020,2022,2020,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_90.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_90.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_103.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,2031,2029,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_91.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_91.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,2049,2047,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_92.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_92.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,2057,2055,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_93.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_93.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_105.cpp,"	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
","	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (lha->compsize < 0)
		goto invalid;	/* Invalid compressed file size */

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
",924,924,928,931,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_94.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_94.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_106.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)malloc(sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	memset(mtree, 0, sizeof(*mtree));
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)calloc(1, sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,228,234,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_95.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_95.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_107.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry, *ht_iter;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;
	unsigned int ht_idx;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,863,878,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_96.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_96.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_108.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

	/*
	 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

	/*
	 * Until enough data has been read, we cannot tell about
",647,647,653,653,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_97.cpp,"{
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_97.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_110.cpp,"	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		break;
	case 03000000:
		/* NFSv4 ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
		break;
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"")",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_98.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_98.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 2"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 13"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 7"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_112.cpp,"	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
","	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");
		return (ARCHIVE_FATAL);
	}
	if (tar->entry_bytes_remaining == INT64_MAX) {
		/* Note: tar_atol returns INT64_MAX on overflow */
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");
		return (ARCHIVE_FATAL);
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_99.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_99.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_100.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_100.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_101.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_101.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_102.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_102.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_103.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_103.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_114.cpp,"{
	struct sparse_block *p;

	p = (struct sparse_block *)malloc(sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	memset(p, 0, sizeof(*p));
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
","{
	struct sparse_block *p;

	p = (struct sparse_block *)calloc(1, sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
",2116,2227,2121,2232,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_104.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_104.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_115.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = malloc(sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}
	memset(w, 0, sizeof(*w));

	r = __archive_read_register_format(
		a, w, ""warc"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = calloc(1, sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}

	r = __archive_read_register_format(
		a, w, ""warc"",
",146,146,150,150,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_105.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_105.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"")","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_106.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_106.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,270,276,"archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")","archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_107.cpp,"{
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_107.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_117.cpp,"	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}
","	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
		/* remember the version */
		w->pver = ver;
	}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000)","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_108.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_108.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_109.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_109.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_110.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_110.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_111.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_111.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 1"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_112.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_112.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 2"", "" 1"", "" 3"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 18"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_122.cpp,"	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail <= 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
","	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail < 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
",1293,1332,1297,1336,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_113.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_113.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_124.cpp,"	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemnted yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
","	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemented yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
",1609,1657,1613,1661,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_114.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_114.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_125.cpp,"	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
","	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
",637,669,640,672,"archive_set_error(&a->archive, errno, ""chdir() failure"")","archive_set_error(&a->archive, errno,
			    ""chdir() failure"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_115.cpp,"{
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_115.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_126.cpp,"		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
","		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backward move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
",1402,1437,1406,1441,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_116.cpp,"{
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_116.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_127.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_127.cpp,"		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
","		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,1470,1505,"archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize)","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_117.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_117.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_128.cpp,"
	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

","
	if (en) {
		/* Everything failed; give up here. */
		if ((&a->archive)->error == NULL)
			archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name);
		return (ARCHIVE_FAILED);
	}

",1993,2043,1996,2047,"archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name)","archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_118.cpp,"{
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_118.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_119.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_119.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_120.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_120.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_121.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_121.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_122.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_122.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_123.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_123.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_124.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_124.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_131.cpp,"			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
","			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (flags
					    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");
						return (ARCHIVE_FAILED);
					}
				}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"")","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_125.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_125.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_132.cpp,"		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
","		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
",2707,2999,2710,3002,"archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path)","archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_126.cpp,"{
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_126.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_133.cpp,"				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3753,4051,3756,4054,"archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")","archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_127.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_127.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_134.cpp,"				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
","				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
",3764,4063,3767,4066,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_128.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_128.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_135.cpp,"			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name,
				    value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(
				    archive_entry_pathname(entry), namespace,
				    name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3808,4108,3823,4125,"archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")","archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_129.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_129.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_136.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)malloc(sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	memset(cpio, 0, sizeof(*cpio));
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)calloc(1, sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
",116,116,121,121,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_130.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_130.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_137.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)malloc(sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	memset(pax, 0, sizeof(*pax));
	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)calloc(1, sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
",127,137,132,142,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_131.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_131.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_138.cpp,"		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)malloc(sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ustar, 0, sizeof(*ustar));
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
","		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)calloc(1, sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
",184,184,189,189,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_132.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_132.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_139.cpp,"		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	memset(v7tar, 0, sizeof(*v7tar));
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
","		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
",161,161,166,166,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_133.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_133.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,306,330,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_134.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_134.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	if (a->tree != NULL) {
		if (a->tree_enter_working_dir(a->tree) != 0) {
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
","	name = archive_entry_sourcepath(entry);
	if (name == NULL)
		name = archive_entry_pathname(entry);
	else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}
	if (name == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}

	/* Short-circuit if there's nothing to do. */
	have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
	if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"")","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_135.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_135.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_141.cpp,"	const char *path;
	ssize_t list_size;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	ssize_t list_size;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_136.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_136.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_142.cpp,"	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = archive_entry_sourcepath(entry);
	if (path == NULL)
		path = archive_entry_pathname(entry);

	if (*fd < 0 && a->tree != NULL) {
		if (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)
			*fd = a->open_on_current_dir(a->tree, path,
				O_RDONLY | O_NONBLOCK);
		if (*fd < 0) {
			if (a->tree_enter_working_dir(a->tree) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}
		}
	}

","	const char *path;
	int namespace = EXTATTR_NAMESPACE_USER;

	path = NULL;

	if (*fd < 0) {
		path = archive_entry_sourcepath(entry);
		if (path == NULL || (a->tree != NULL &&
		    a->tree_enter_working_dir(a->tree) != 0))
			path = archive_entry_pathname(entry);
		if (path == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}
		if (a->tree != NULL && (a->follow_symlinks ||
		    archive_entry_filetype(entry) != AE_IFLNK)) {
			*fd = a->open_on_current_dir(a->tree,
			    path, O_RDONLY | O_NONBLOCK);
		}
	}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_137.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_137.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_144.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_138.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_138.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_145.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_139.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_139.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_146.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_140.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_140.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_147.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_147.cpp,"		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usuall come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
","		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	} else if (xr == 1) {
		/* Usually come here unless NetBSD supports _PC_REC_XFER_ALIGN
		 * for pathconf() function. */
		t->current_filesystem->xfer_align = sfs.f_frsize;
		t->current_filesystem->max_xfer_size = -1;
",1643,1656,1643,1656,"archive_set_error(&a->archive, errno, ""statvfs failed"");","archive_set_error(&a->archive, errno, ""statvfs failed"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_141.cpp,"{
		t->current_filesystem->remote = -1;
		archive_set_error(&a->archive, errno, ""statvfs failed"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_141.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_148.cpp,"		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_path_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_142.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_142.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_149.cpp,"		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_time_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_143.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_143.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_150.cpp,"		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
","		r = archive_match_owner_excluded(a->matching, entry);
		if (r < 0) {
			archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));
			return (r);
		}
		if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_144.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_144.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_151.cpp,"#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}
	if (fstat(fd, &st) != 0) {
","#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		goto fail;
#endif
	}
	if (fstat(fd, &st) != 0) {
",277,277,278,278,"archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")","archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_145.cpp,"{
#if defined(_WIN32) && !defined(__CYGWIN__)
		wfilename = mine->filename.w;
		fd = _wopen(wfilename, O_RDONLY | O_BINARY);
		if (fd < 0 && errno == ENOENT) {
			wchar_t *fullpath;
			fullpath = __la_win_permissive_name_w(wfilename);
			if (fullpath != NULL) {
				fd = _wopen(fullpath, O_RDONLY | O_BINARY);
				free(fullpath);
			}
		}
		if (fd < 0) {
			archive_set_error(a, errno,
			    ""Failed to open '%S'"", wfilename);
			return (ARCHIVE_FATAL);
		}
#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_145.cpp,"[""4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 41"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 28"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 3"", "" 3"", "" 1"", "" 0"", "" 8"", "" 0"", "" 0"", "" 7"", "" 0"", "" 15"", "" 3""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_152.cpp,"		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		return (ARCHIVE_FATAL);
	}

	/*
","		else
			archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename);
		goto fail;
	}

	/*
",287,287,288,288,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)","archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_146.cpp,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_146.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_153.cpp,"		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (mine == NULL || buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}
	mine->buffer = buffer;
	mine->fd = fd;
","		mine->block_size = new_block_size;
	}
	buffer = malloc(mine->block_size);
	if (buffer == NULL) {
		archive_set_error(a, ENOMEM, ""No memory"");
		goto fail;
	}
	mine->buffer = buffer;
	mine->fd = fd;
",356,356,360,360,"archive_set_error(a, ENOMEM, ""No memory"")","archive_set_error(a, ENOMEM, ""No memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_147.cpp,"{
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_147.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_156.cpp,"	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
","	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
",178,163,184,167,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_148.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->name = ""lzma"";
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_148.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 52"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 1"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 27"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 3"", "" 0"", "" 0"", "" 8"", "" 0"", "" 9"", "" 4""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_149.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_149.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_150.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_150.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_151.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_151.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_152.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_152.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_153.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_153.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_154.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_154.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 3"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_155.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_155.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 3"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
	struct private_data *state;
	size_t decompressed;
	ssize_t avail_in, ret;

	state = (struct private_data *)self->data;

	/* Empty our output buffer. */
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Try to fill the output buffer. */
	while (state->stream.avail_out > 0 && !state->eof) {
		state->stream.next_in = (unsigned char *)(uintptr_t)
		    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
		if (state->stream.next_in == NULL && avail_in < 0) {
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}
		state->stream.avail_in = avail_in;

		/* Decompress as much as we can in one pass. */
		ret = lzmadec_decode(&(state->stream), avail_in == 0);
		switch (ret) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}
	}

	decompressed = state->stream.next_out - state->out_block;
	state->total_out += decompressed;
	if (decompressed == 0)
		*p = NULL;
	else
		*p = state->out_block;
	return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
	struct private_data *state;
	int ret;

	state = (struct private_data *)self->data;
	ret = ARCHIVE_OK;
	switch (lzmadec_end(&(state->stream))) {
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}

	free(state->out_block);
	free(state);
	return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_156.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_156.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_158.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)malloc(sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ar, 0, sizeof(*ar));
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

	ar = (struct ar *)calloc(1, sizeof(*ar));
	if (ar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}
	ar->strtab = NULL;

	r = __archive_read_register_format(a,
",104,104,109,109,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_157.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_157.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_159.cpp,"		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
","		archive_entry_set_filetype(entry, AE_IFREG);
		/* Get the size of the filename table. */
		number = ar_atol10(h + AR_size_offset, AR_size_size);
		if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
",260,259,264,263,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_158.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_158.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_162.cpp,"		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
","		if ((file->utf16be_name = malloc(name_len)) == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			goto fail;
		}
		memcpy(file->utf16be_name, p, name_len);
		file->utf16be_bytes = name_len;
",1864,1864,1865,1865,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")","archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_159.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_159.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_163.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
			/*
			 * Sanity check: file does not have ""CL"" extension.
",1990,1988,1990,1988,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_160.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_160.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_164.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a directory.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a directory.
",1999,1997,1999,1997,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_161.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_161.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_165.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				goto fail;
			}
		} else if (parent != NULL && parent->rr_moved)
			file->rr_moved_has_re_only = 0;
",2008,2006,2008,2006,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_162.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_162.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_166.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			/*
			 * Sanity check: The file type must be a regular file.
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			/*
			 * Sanity check: The file type must be a regular file.
",2022,2020,2022,2020,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_163.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_163.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_167.cpp,"				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
","				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
			parent->subdirs++;
			/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,2031,2029,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_164.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_164.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,2049,2047,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_165.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_165.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}
		}
	}
","					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					goto fail;
				}
			}
			if (file->cl_offset == file->offset ||
			    parent->rr_moved) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				goto fail;
			}
		}
	}
",2049,2047,2057,2055,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_166.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_166.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_169.cpp,"	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
","	/* Get a real compressed file size. */
	lha->compsize -= extdsize - 2;

	if (lha->compsize < 0)
		goto invalid;	/* Invalid compressed file size */

	if (sum_calculated != headersum) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
",924,924,928,931,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_167.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_167.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_170.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)malloc(sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	memset(mtree, 0, sizeof(*mtree));
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

	mtree = (struct mtree *)calloc(1, sizeof(*mtree));
	if (mtree == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}
	mtree->fd = -1;

	r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,228,234,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_168.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_168.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_171.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
	struct mtree_entry *entry, *ht_iter;
	struct mtree_option *iter;
	const char *next, *eq, *name, *end;
	size_t name_len, len;
	int r, i;
	unsigned int ht_idx;

	if ((entry = malloc(sizeof(*entry))) == NULL) {
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,863,878,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_169.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_169.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_172.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

	/*
	 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

	/*
	 * Until enough data has been read, we cannot tell about
",647,647,653,653,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_170.cpp,"{
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_170.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_174.cpp,"	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","	switch ((int)type & ~0777777) {
	case 01000000:
		/* POSIX.1e ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
		break;
	case 03000000:
		/* NFSv4 ACL */
		acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
		break;
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"")",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_171.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_171.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 2"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 13"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 7"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_176.cpp,"	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
","	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");
		return (ARCHIVE_FATAL);
	}
	if (tar->entry_bytes_remaining == INT64_MAX) {
		/* Note: tar_atol returns INT64_MAX on overflow */
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");
		return (ARCHIVE_FATAL);
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_172.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_172.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_173.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_173.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_174.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_174.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_175.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_175.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			if (tar->sconv_acl == NULL) {
				tar->sconv_acl =
				    archive_string_conversion_from_charset(
					&(a->archive), ""UTF-8"", 1);
				if (tar->sconv_acl == NULL)
					return (ARCHIVE_FATAL);
			}

			r = archive_acl_parse_l(archive_entry_acl(entry),
			    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
			    tar->sconv_acl);
			if (r != ARCHIVE_OK) {
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
","	case 'S':
		/* We support some keys used by the ""star"" archiver */
		if (strcmp(key, ""SCHILY.acl.access"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
			r = pax_attribute_acl(a, tar, entry, value,
			    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
			if (r == ARCHIVE_FATAL)
				return (r);
		} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
			archive_entry_set_rdevmajor(entry,
			    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_176.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_176.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 15"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_178.cpp,"{
	struct sparse_block *p;

	p = (struct sparse_block *)malloc(sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	memset(p, 0, sizeof(*p));
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
","{
	struct sparse_block *p;

	p = (struct sparse_block *)calloc(1, sizeof(*p));
	if (p == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	if (tar->sparse_last != NULL)
		tar->sparse_last->next = p;
	else
",2116,2227,2121,2232,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_177.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_177.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_179.cpp,"	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = malloc(sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}
	memset(w, 0, sizeof(*w));

	r = __archive_read_register_format(
		a, w, ""warc"",
","	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

	if ((w = calloc(1, sizeof(*w))) == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}

	r = __archive_read_register_format(
		a, w, ""warc"",
",146,146,150,150,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_178.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_178.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"")","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_179.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_179.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
","			&a->archive, ARCHIVE_ERRNO_MISC,
			""Bad record header"");
		return (ARCHIVE_FATAL);
	}
	ver = _warc_rdver(buf, eoh - buf);
	/* we currently support WARC 0.12 to 1.0 */
	if (ver == 0U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");
		return (ARCHIVE_FATAL);
	} else if (ver < 1200U || ver > 10000U) {
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);
		return (ARCHIVE_FATAL);
	}
	cntlen = _warc_rdlen(buf, eoh - buf);
	if (cntlen < 0) {
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}
	rtime = _warc_rdrtm(buf, eoh - buf);
	if (rtime == (time_t)-1) {
		/* record time is mandatory as per WARC/1.0,
		 * so just barf here, fast and loud */
		archive_set_error(
",255,254,270,276,"archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")","archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_180.cpp,"{
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_180.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_181.cpp,"	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}
","	if (ver != w->pver) {
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
		/* remember the version */
		w->pver = ver;
	}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000)","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_181.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_181.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_182.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_182.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		if (xar->lzstream_valid)
			lzmadec_end(&(xar->lzstream));
		r = lzmadec_init(&(xar->lzstream));
		if (r != LZMADEC_OK) {
			switch (r) {
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}
			return (ARCHIVE_FATAL);
		}
		xar->lzstream_valid = 1;
		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
","		xar->lzstream.total_in = 0;
		xar->lzstream.total_out = 0;
		break;
#endif
	/*
	 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_183.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_183.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_184.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_184.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 1"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
	case LZMA:
		xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
		xar->lzstream.avail_in = avail_in;
		xar->lzstream.next_out = (unsigned char *)outbuff;
		xar->lzstream.avail_out = avail_out;
		r = lzmadec_decode(&(xar->lzstream), 0);
		switch (r) {
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}
		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
	case LZMA:
#endif
	case XZ:
#endif
	case NONE:
","		*used = avail_in - xar->lzstream.avail_in;
		*outbytes = avail_out - xar->lzstream.avail_out;
		break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
	case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
	case LZMA:
	case XZ:
#endif
	case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_185.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_185.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 2"", "" 1"", "" 3"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 18"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_186.cpp,"	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail <= 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
","	    && bytes_avail > zip->entry_bytes_remaining) {
		bytes_avail = (ssize_t)zip->entry_bytes_remaining;
	}
	if (bytes_avail < 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
",1293,1332,1297,1336,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_186.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file body"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_186.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_188.cpp,"	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemnted yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
","	__archive_read_consume(a, 4);

	/*return (ARCHIVE_OK);
	 * This is not fully implemented yet.*/
	archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"");
	return (ARCHIVE_FAILED);
",1609,1657,1613,1661,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
	    ""Encrypted file is unsupported"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_187.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_187.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_189.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_189.cpp,"	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
","	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
",637,669,640,672,"archive_set_error(&a->archive, errno, ""chdir() failure"")","archive_set_error(&a->archive, errno,
			    ""chdir() failure"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_188.cpp,"{
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_188.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_190.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_190.cpp,"		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
","		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backward move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
",1402,1437,1406,1441,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_189.cpp,"{
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_189.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_191.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_191.cpp,"		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
","		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
",1468,1503,1470,1505,"archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize)","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"",
		    (uintmax_t)a->filesize)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_190.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_190.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_192.cpp,"
	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

","
	if (en) {
		/* Everything failed; give up here. */
		if ((&a->archive)->error == NULL)
			archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name);
		return (ARCHIVE_FAILED);
	}

",1993,2043,1996,2047,"archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name)","archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_191.cpp,"{
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_191.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_192.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_192.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_193.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_193.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_194.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_194.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","	return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
	if (a_eno)
		*a_eno = err;
	if (a_estr)
		archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)path; /* UNUSED */
	(void)error_number; /* UNUSED */
	(void)error_string; /* UNUSED */
	(void)flags; /* UNUSED */
	return (ARCHIVE_OK);
#else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
	char c;
	int r;
	struct stat st;
	int restore_pwd;

	/* Nothing to do here if name is empty */
	if(path[0] == '\0')
	    return (ARCHIVE_OK);

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 *
	 * Walk the filename in chunks separated by '/'.  For each segment:
	 *  - if it doesn't exist, continue
	 *  - if it's symlink, abort or remove it
	 *  - if it's a directory and it's not the last chunk, cd into it
	 * As we go:
	 *  head points to the current (relative) path
	 *  tail points to the temporary \0 terminating the segment we're
	 *      currently examining
	 *  c holds what used to be in *tail
	 *  last is 1 if this is the last tail
	 */
	restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	/* TODO: reintroduce a safe cache here? */
	/* Skip the root directory if the path is absolute. */
	if(tail == path && tail[0] == '/')
		++tail;
	/* Keep going until we've checked the entire name.
	 * head, tail, path all alias the same string, which is
	 * temporarily zeroed at tail, so be careful restoring the
	 * stashed (c=tail[0]) for error messages.
	 * Exiting the loop with break is okay; continue is not.
	 */
	while (!last) {
		/*
		 * Skip the separator we just consumed, plus any adjacent ones
		 */
		while (*tail == '/')
		    ++tail;
		/* Skip the next path element. */
		while (*tail != '\0' && *tail != '/')
			++tail;
		/* is this the last path component? */
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		/* temporarily truncate the string here */
		c = tail[0];
		tail[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(head, &st);
		if (r != 0) {
			tail[0] = c;
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT) {
				break;
			} else {
				/*
				 * Treat any other error as fatal - best to be
				 * paranoid here.
				 * Note: This effectively disables deep
				 * directory support when security checks are
				 * enabled. Otherwise, very long pathnames that
				 * trigger an error here could evade the
				 * sandbox.
				 * TODO: We could do better, but it would
				 * probably require merging the symlink checks
				 * with the deep-directory editing.
				 */
				fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}
				/* Our view is now from inside this dir: */
				head = tail + 1;
			}
		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(head)) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				tail[0] = c;
				/*
				 * FIXME:  not sure how important this is to
				 * restore
				 */
				/*
				if (!S_ISLNK(path)) {
					fsobj_error(a_eno, a_estr, 0,
					    ""Removing symlink %s"", path);
				}
				*/
				/* Symlink gone.  No more problem! */
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(head) != 0) {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
				tail[0] = c;
			} else if ((flags &
			    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
				/*
				 * We are not the last element and we want to
				 * follow symlinks if they are a directory.
				 * 
				 * This is needed to extract hardlinks over
				 * symlinks.
				 */
				r = stat(head, &st);
				if (r != 0) {
					tail[0] = c;
					if (errno == ENOENT) {
						break;
					} else {
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}
				} else if (S_ISDIR(st.st_mode)) {
					if (chdir(head) != 0) {
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}
					/*
					 * Our view is now from inside
					 * this dir:
					 */
					head = tail + 1;
				} else {
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}
			} else {
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}
		}
		/* be sure to always maintain this */
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; /* Advance to the next segment. */
	}
	/* Catches loop exits via break */
	tail[0] = c;
#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	/* TODO: reintroduce a safe cache here? */
	return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
	struct archive_string error_string;
	int error_number;
	int rc;
	archive_string_init(&error_string);
	rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
	    a->flags);
	if (rc != ARCHIVE_OK) {
		archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);
	}
	archive_string_free(&error_string);
	a->pst = NULL;	/* to be safe */
	return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_195.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_195.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_196.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_196.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = path;
	if (*src == '\0') {
		fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(path);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");
			return (ARCHIVE_FAILED);
		}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_197.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_197.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_195.cpp,"			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
","			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (flags
					    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");
						return (ARCHIVE_FAILED);
					}
				}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"")","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_198.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_198.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_196.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_196.cpp,"		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
","		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
",2707,2999,2710,3002,"archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path)","archive_set_error(&a->archive, errno,
		    ""Can't test directory '%s'"", path)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_199.cpp,"{
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_199.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_197.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_197.cpp,"				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3753,4051,3756,4054,"archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")","archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_200.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_200.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_198.cpp,"				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
","				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
",3764,4063,3767,4066,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_201.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_201.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_199.cpp,"			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
","			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name,
				    value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(
				    archive_entry_pathname(entry), namespace,
				    name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
",3808,4108,3823,4125,"archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")","archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_202.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_202.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_200.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)malloc(sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	memset(cpio, 0, sizeof(*cpio));
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	cpio = (struct cpio *)calloc(1, sizeof(*cpio));
	if (cpio == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = cpio;
	a->format_name = ""cpio"";
	a->format_options = archive_write_newc_options;
",116,116,121,121,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_203.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_203.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_201.cpp,"	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)malloc(sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	memset(pax, 0, sizeof(*pax));
	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
","	if (a->format_free != NULL)
		(a->format_free)(a);

	pax = (struct pax *)calloc(1, sizeof(*pax));
	if (pax == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}
	pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

	a->format_data = pax;
	a->format_name = ""pax"";
	a->format_options = archive_write_pax_options;
",127,137,132,142,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_204.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_204.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_202.cpp,"		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)malloc(sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	memset(ustar, 0, sizeof(*ustar));
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
","		return (ARCHIVE_FATAL);
	}

	ustar = (struct ustar *)calloc(1, sizeof(*ustar));
	if (ustar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = ustar;
	a->format_name = ""ustar"";
	a->format_options = archive_write_ustar_options;
",184,184,189,189,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_205.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_205.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_203.cpp,"		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	memset(v7tar, 0, sizeof(*v7tar));
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
","		return (ARCHIVE_FATAL);
	}

	v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
	if (v7tar == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}
	a->format_data = v7tar;
	a->format_name = ""tar (non-POSIX)"";
	a->format_options = archive_write_v7tar_options;
",161,161,166,166,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_206.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_206.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",913,913,917,919,"len = curl_msnprintf(fptr, left, ""%ld"", width)","len = curl_msnprintf(fptr, left, ""%ld"", width)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_207.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_207.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 4"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",913,913,923,936,"len = curl_msnprintf(fptr, left, "".%ld"", prec)","len = curl_msnprintf(fptr, left, "".%ld"", prec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_208.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_208.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_205.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length +
                           strlen(conn->socks_proxy.host.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length + strlen(conn->socks_proxy.host.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name)","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_209.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_209.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 43"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 20"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 4"", "" 0"", "" 14"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_209.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_209.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,1577,1573,"txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",","txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_210.cpp,"{
    /* the info given when the version is zero is not that useful for us */

    ssl_ver >>= 8; /* check the upper 8 bits only below */

    /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL
     * always pass-up content-type as 0. But the interesting message-type
     * is at 'buf[0]'.
     */
    if(ssl_ver == SSL3_VERSION_MAJOR && content_type)
      tls_rt_name = tls_rt_type(content_type);
    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
                       verstr, direction?""OUT"":""IN"",
                       tls_rt_name, msg_name, msg_type);
    Curl_debug(data, CURLINFO_TEXT, ssl_buf, (size_t)txt_len, NULL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_210.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 1"", "" 28"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 2"", "" 0"", "" 5"", "" 0"", "" 0"", "" 7"", "" 0"", "" 17"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_210.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,2202,2259,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_211.cpp,"{
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_211.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_211.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n + 1);
  if(buf)
    for(n = 0; beg < end; n += 3)
      snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n + 1);
    if(buf)
      for(n = 0; beg < end; n += 3)
        snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,209,213,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)","snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_212.cpp,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_212.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",917,917,921,923,"len = curl_msnprintf(fptr, left, ""%ld"", width)","len = curl_msnprintf(fptr, left, ""%ld"", width)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_213.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_213.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 3"", "" 0"", "" 4"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
",917,917,927,940,"len = curl_msnprintf(fptr, left, "".%ld"", prec)","len = curl_msnprintf(fptr, left, "".%ld"", prec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_214.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_214.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_213.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length +
                           strlen(conn->socks_proxy.host.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length + strlen(conn->socks_proxy.host.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name)","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_215.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_215.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 43"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 20"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 4"", "" 0"", "" 14"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_217.cpp,"    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
","    else
      tls_rt_name = """";

    msg_type = *(char *)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
",1571,1567,1577,1573,"txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",","txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_216.cpp,"{
    /* the info given when the version is zero is not that useful for us */

    ssl_ver >>= 8; /* check the upper 8 bits only below */

    /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL
     * always pass-up content-type as 0. But the interesting message-type
     * is at 'buf[0]'.
     */
    if(ssl_ver == SSL3_VERSION_MAJOR && content_type)
      tls_rt_name = tls_rt_type(content_type);
    else
      tls_rt_name = """";

    msg_type = *(char*)buf;
    msg_name = ssl_msg_type(ssl_ver, msg_type);

    txt_len = snprintf(ssl_buf, sizeof(ssl_buf), ""%s (%s), %s, %s (%d):\n"",
                       verstr, direction?""OUT"":""IN"",
                       tls_rt_name, msg_name, msg_type);
    Curl_debug(data, CURLINFO_TEXT, ssl_buf, (size_t)txt_len, NULL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_216.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 1"", "" 28"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 2"", "" 0"", "" 5"", "" 0"", "" 0"", "" 7"", "" 0"", "" 17"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_218.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,2202,2259,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_217.cpp,"{
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_217.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 8"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_219.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n + 1);
  if(buf)
    for(n = 0; beg < end; n += 3)
      snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n + 1);
    if(buf)
      for(n = 0; beg < end; n += 3)
        snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,209,213,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)","snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_218.cpp,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_218.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmCommandArgument_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmCommandArgument_yy_load_buffer_state(yyscanner );
		}

	{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 41 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
	YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmCommandArgument_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmCommandArgument_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmCommandArgument_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 30 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 30 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 29);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1050,1054,"YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_219.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_219.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmCommandArgument_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmCommandArgument_yy_load_buffer_state(yyscanner );
		}

	{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 41 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
	YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmCommandArgument_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmCommandArgument_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmCommandArgument_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 30 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 30 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 29);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1073,1077,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_220.cpp,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_220.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmCommandArgument_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmCommandArgument_yy_load_buffer_state(yyscanner );
		}

	{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 41 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
	YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmCommandArgument_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmCommandArgument_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmCommandArgument_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 30 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 30 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 29);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1141,1145,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_221.cpp,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_221.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmCommandArgument_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmCommandArgument_yy_load_buffer_state(yyscanner );
		}

	{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 30 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 41 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ENVCURLY;
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_NCURLY;
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext+1, strlen(yytext)-2);
  return cal_ATNAME;
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytext+1)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
	YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmCommandArgument_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmCommandArgument_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmCommandArgument_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 30 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 30 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 29);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1185,1189,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_222.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_222.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1400,1409,1407,1416,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_223.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_223.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1400,1409,1416,1425,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_224.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_224.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		cmCommandArgument_yy_load_buffer_state(yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
	int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,1579,1584,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_225.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_225.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		cmCommandArgument_yy_load_buffer_state(yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
	int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,1599,1604,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_226.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_226.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_224.cpp," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
"," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
",1612,1617,1625,1630,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_227.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_227.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len + 2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1674,1679,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_228.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_228.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len + 2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1683,1688,"YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_229.cpp,"YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_229.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len + 2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1699,1706,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_230.cpp,"{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_230.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1814,1821,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_231.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_231.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1829,1836,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_232.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_232.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      ++yy_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ++yyg->yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr + yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmExpr_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmExpr_yy_load_buffer_state(yyscanner );
		}

	{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 23 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 21 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
	YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmExpr_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmExpr_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmExpr_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 23 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 23 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 22);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyg->yy_hold_char;

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyg->yy_n_chars + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
		}

	*--yy_cp = (char) c;

	yyg->yytext_ptr = yy_bp;
	yyg->yy_hold_char = *yy_cp;
	yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,968,991,"YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_233.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_233.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      ++yy_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ++yyg->yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr + yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmExpr_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmExpr_yy_load_buffer_state(yyscanner );
		}

	{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 23 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 21 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
	YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmExpr_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmExpr_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmExpr_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 23 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 23 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 22);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyg->yy_hold_char;

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyg->yy_n_chars + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
		}

	*--yy_cp = (char) c;

	yyg->yytext_ptr = yy_bp;
	yyg->yy_hold_char = *yy_cp;
	yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,991,1014,"YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_234.cpp,"YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_234.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
      ++yy_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ++yyg->yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr + yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			cmExpr_yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
		}

		cmExpr_yy_load_buffer_state(yyscanner );
		}

	{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			if ( yy_accept[yy_current_state] )
				{
				yyg->yy_last_accepting_state = yy_current_state;
				yyg->yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 23 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 21 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yyg->yy_hold_char;
			yy_cp = yyg->yy_last_accepting_cpos;
			yy_current_state = yyg->yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
	YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * cmExpr_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p ""<="" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( cmExpr_yywrap(yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	yy_size_t number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

			int yy_c_buf_p_offset =
				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = NULL;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" );

			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			cmExpr_yyrestart(yyin  ,yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((int) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			yyg->yy_last_accepting_state = yy_current_state;
			yyg->yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 23 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
	char *yy_cp = yyg->yy_c_buf_p;

	YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		yyg->yy_last_accepting_state = yy_current_state;
		yyg->yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 23 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (flex_int16_t) yy_c];
	yy_is_jam = (yy_current_state == 22);

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyg->yy_hold_char;

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyg->yy_n_chars + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
		}

	*--yy_cp = (char) c;

	yyg->yytext_ptr = yy_bp;
	yyg->yy_hold_char = *yy_cp;
	yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,1059,1082,"YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_235.cpp,"YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_235.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmExpr_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1311,1384,1318,1391,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_236.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_236.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_buf_size = (yy_size_t)size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size + 2 ,yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

	b->yy_is_our_buffer = 1;

	cmExpr_yy_init_buffer(b,file ,yyscanner);

	return b;
}

/** Destroy the buffer.
",1311,1384,1327,1400,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_237.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_237.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmExpr_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmExpr_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1532,1605,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_238.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_238.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmExpr_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmExpr_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1581,1654,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_239.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_239.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmExpr_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmExpr_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1590,1663,"YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_240.cpp,"YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_240.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len + 2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

	b->yy_buf_size = size - 2;	/* ""- 2"" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	cmExpr_yy_switch_to_buffer(b ,yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

	return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmExpr_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	(void) fprintf( stderr, ""%s\n"", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1606,1681,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_241.cpp,"{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_241.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1721,1796,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_242.cpp,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_242.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1736,1811,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_243.cpp,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_243.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_233.cpp,"		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
","		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
",1567,1561,1573,1567,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )","YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_244.cpp,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_244.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_234.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = _yybytes_len + 2;
	buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	yy_size_t i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) _yybytes_len + 2;
	buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

	for ( i = 0; i < (size_t)_yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
",1996,1990,2010,2004,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_245.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_245.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_235.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_246.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_246.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_236.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_247.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_247.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_237.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap)","s = curl_mvaprintf(fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_248.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_248.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 20"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 18"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_238.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
",4107,4103,4112,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_249.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_249.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_239.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,122,122,"vsnprintf(print_buffer, sizeof(print_buffer), message, args);","vsnprintf(print_buffer, sizeof(print_buffer), message, args);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_250.cpp,"{
  int ftp_code;
  ssize_t nread=0;
  va_list args;
  char print_buffer[50];

  va_start(args, message);
  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))
      ftp_code = -1;
  }

  (void)nread; /* Unused */
  return ftp_code;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_250.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 0"", "" 4"", "" 4"", "" 0"", "" 0"", "" 1"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 24"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 1"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 6"", "" 0"", "" 13"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_242.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,731,745,"md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)","md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_251.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_251.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_243.cpp,"  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }
","  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr += len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL))","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_252.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_252.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_244.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,2181,2202,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_253.cpp,"{
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_253.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_245.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_254.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_254.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_246.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_255.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_255.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_247.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap)","s = curl_mvaprintf(fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_256.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_256.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 20"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 18"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 3"", "" 0"", "" 13"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_248.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;
",4106,4102,4111,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_257.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_257.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_249.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,122,122,"vsnprintf(print_buffer, sizeof(print_buffer), message, args);","vsnprintf(print_buffer, sizeof(print_buffer), message, args);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_258.cpp,"{
  int ftp_code;
  ssize_t nread=0;
  va_list args;
  char print_buffer[50];

  va_start(args, message);
  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))
      ftp_code = -1;
  }

  (void)nread; /* Unused */
  return ftp_code;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_258.cpp,"[""2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 31"", "" 0"", "" 0"", "" 4"", "" 4"", "" 0"", "" 0"", "" 1"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 24"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 1"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 6"", "" 0"", "" 13"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_252.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,731,745,"md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)","md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_259.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_259.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_253.cpp,"  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }
","  left -= len;
  ptr += len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr += len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL))","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_260.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_260.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 10"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 3"", "" 0"", "" 5"", "" 0""]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_254.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,2181,2202,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_261.cpp,"{
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_261.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_255.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,607,565,"sprintf(argument, ""%s"", sit->c_str())","sprintf(argument, ""%s"", sit->c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_262.cpp,"{
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_262.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 1"", "" 5"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 50"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 13"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 8"", "" 0"", "" 14"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_132.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_255.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,617,583,"sprintf(buffer, format, argument)","sprintf(buffer, format, argument)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_263.cpp,"{
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_263.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 1"", "" 5"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 50"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 13"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 8"", "" 0"", "" 14"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_256.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,126,114,"sprintf(buf, ""%s*"", name.c_str())","sprintf(buf, ""%s*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_264.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_264.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_256.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,135,120,"sprintf(buf, ""%s\\*"", name.c_str())","sprintf(buf, ""%s\\*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_265.cpp,"{
      sprintf(buf, ""%s\\*"", name.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_265.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_256.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,139,122,"sprintf(buf, ""%s/*"", name.c_str())","sprintf(buf, ""%s/*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_266.cpp,"{
      sprintf(buf, ""%s/*"", name.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_266.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_257.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,176,156,"sprintf(buf, ""%s*"", name.c_str())","sprintf(buf, ""%s*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_267.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_267.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_133.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_257.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,181,159,"sprintf(buf, ""%s/*"", name.c_str())","sprintf(buf, ""%s/*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_268.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_268.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_134.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_258.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f++ = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f++ = '+';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f++ = '#';
      }
#if defined(_MSC_VER)
      *f++ = 'I';
      *f++ = '6';
      *f++ = '4';
#else
      *f++ = 'l';
      *f++ = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f++ = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f++ = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f++ = 'X';
      } else {
        *f++ = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,199,203,"sprintf(buffer, format, value)","sprintf(buffer, format, value)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_269.cpp,"{
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_269.cpp,"[""6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 72"", "" 0"", "" 0"", "" 4"", "" 4"", "" 0"", "" 0"", "" 2"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 62"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 2"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 15"", "" 2"", "" 4"", "" 3""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_259.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,88,76,"vfprintf(stream, format, var_args)","vfprintf(stream, format, var_args)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_270.cpp,"{
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_270.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_260.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,268,244,"fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)","fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_271.cpp,"{
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_271.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_260.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,275,250,"fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)","fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_272.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_272.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_261.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,299,274,"fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE)","fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_273.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_273.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_135.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_262.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,326,300,"fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE)","fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_274.cpp,"{
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
    case kwsysTerminal_Color_BackgroundRed:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_RED);
      break;
    case kwsysTerminal_Color_BackgroundGreen:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_GREEN);
      break;
    case kwsysTerminal_Color_BackgroundYellow:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW);
      break;
    case kwsysTerminal_Color_BackgroundBlue:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLUE);
      break;
    case kwsysTerminal_Color_BackgroundMagenta:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA);
      break;
    case kwsysTerminal_Color_BackgroundCyan:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_CYAN);
      break;
    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_274.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 32"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 32"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 8"", "" 0"", "" 16"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_263.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_263.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,40,31,"printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out)","printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_275.cpp,"{
  char md5out[33];
  kwsysMD5_Initialize(md5);
  kwsysMD5_Append(md5, testMD5input1, -1);
  kwsysMD5_FinalizeHex(md5, md5out);
  md5out[32] = 0;
  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_275.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 1"", "" 22"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 5"", "" 0"", "" 11"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_264.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_264.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,55,46,"printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out)","printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_276.cpp,"{
  unsigned char digest[16];
  char md5out[33];
  kwsysMD5_Initialize(md5);
  kwsysMD5_Append(md5, testMD5input2, testMD5input2len);
  kwsysMD5_Finalize(md5, digest);
  kwsysMD5_DigestToHex(digest, md5out);
  md5out[32] = 0;
  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_276.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 27"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 1"", "" 26"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 6"", "" 0"", "" 13"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,89,80,"fprintf(stdout, ""Output on stdout from test returning 0.\n"")","fprintf(stdout, ""Output on stdout from test returning 0.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_277.cpp,"{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_277.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,90,81,"fprintf(stderr, ""Output on stderr from test returning 0.\n"")","fprintf(stderr, ""Output on stderr from test returning 0.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_278.cpp,"{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_278.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,97,89,"fprintf(stdout, ""Output on stdout from test returning 123.\n"")","fprintf(stdout, ""Output on stdout from test returning 123.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_279.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_279.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,98,90,"fprintf(stderr, ""Output on stderr from test returning 123.\n"")","fprintf(stderr, ""Output on stderr from test returning 123.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_280.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_280.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,105,98,"fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"")","fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_281.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_281.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 11"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_265.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,106,99,"fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"")","fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_282.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_282.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 11"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_266.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,133,127,"fprintf(stdout, ""Output before crash on stdout from crash test.\n"")","fprintf(stdout, ""Output before crash on stdout from crash test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_283.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_283.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_266.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,134,128,"fprintf(stderr, ""Output before crash on stderr from crash test.\n"")","fprintf(stderr, ""Output before crash on stderr from crash test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_284.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_284.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_267.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,155,149,"fprintf(stderr, ""Output on stderr before recursive test.\n"");","fprintf(stderr, ""Output on stderr before recursive test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_285.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_285.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_267.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,160,154,"fprintf(stdout, ""Output on stdout after recursive test.\n"")","fprintf(stdout, ""Output on stdout after recursive test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_286.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_286.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_267.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,161,155,"fprintf(stderr, ""Output on stderr after recursive test.\n"")","fprintf(stderr, ""Output on stderr after recursive test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_287.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_287.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_268.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,195,189,"fprintf(stdout, ""Output on stdout before sleep.\n"")","fprintf(stdout, ""Output on stdout before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_288.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_288.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_268.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,196,190,"fprintf(stderr, ""Output on stderr before sleep.\n"")","fprintf(stderr, ""Output on stderr before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_289.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_289.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_269.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,235,230,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_290.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* TODO: Instead of closing pipes here leave them open to make sure
     the grandparent can stop listening when the parent exits.  This
     part of the test cannot be enabled until the feature is
     implemented.  */
  fclose(stdout);
  fclose(stderr);
  testProcess_sleep(15);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_290.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 9"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_269.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,236,231,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_291.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* TODO: Instead of closing pipes here leave them open to make sure
     the grandparent can stop listening when the parent exits.  This
     part of the test cannot be enabled until the feature is
     implemented.  */
  fclose(stdout);
  fclose(stderr);
  testProcess_sleep(15);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_291.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 9"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_270.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_270.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
",266,261,266,261,"fprintf(stderr, ""Output on stderr before grandchild test.\n"");","fprintf(stderr, ""Output on stderr before grandchild test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_292.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_292.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_271.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,313,306,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_293.cpp,"{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 9 seconds.  */
  testProcess_sleep(9);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_293.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 15"", "" 0"", "" 0"", "" 14"", "" 0"", "" 24"", "" 3""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_271.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,314,307,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_294.cpp,"{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 9 seconds.  */
  testProcess_sleep(9);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_294.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 15"", "" 0"", "" 0"", "" 14"", "" 0"", "" 24"", "" 3""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_272.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,341,334,"fprintf(stderr, ""Output on stderr before grandchild test.\n"");","fprintf(stderr, ""Output on stderr before grandchild test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_295.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_295.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_272.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,347,340,"fprintf(stdout, ""Output on stdout after grandchild test.\n"")","fprintf(stdout, ""Output on stdout after grandchild test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_296.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_296.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_272.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,348,341,"fprintf(stderr, ""Output on stderr after grandchild test.\n"")","fprintf(stderr, ""Output on stderr after grandchild test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_297.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_297.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_273.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,358,352,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_298.cpp,"{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 6 seconds.  */
  testProcess_sleep(6);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_298.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_273.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,359,353,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_299.cpp,"{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 6 seconds.  */
  testProcess_sleep(6);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_299.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,422,405,"fprintf(stdout, ""WaitForData timeout reached.\n"")","fprintf(stdout, ""WaitForData timeout reached.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_300.cpp,"{
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_300.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 4"", "" 0"", "" 7"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,429,411,"fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL)","fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_301.cpp,"{
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_301.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,467,440,"printf(""No process has been executed.\n"")","printf(""No process has been executed.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_302.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_302.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,469,443,"printf(""The process is still executing.\n"")","printf(""The process is still executing.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_303.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_303.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,471,446,"printf(""Child was killed when timeout expired.\n"")","printf(""Child was killed when timeout expired.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_304.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_304.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,473,449,"printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp))","printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_305.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_305.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,478,454,"printf(""Child was killed by parent.\n"")","printf(""Child was killed by parent.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_306.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_306.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,480,457,"printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp))","printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_307.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_307.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,485,463,"printf(""Child was disowned.\n"")","printf(""Child was disowned.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_308.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_308.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,487,466,"printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp))","printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_309.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_309.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,495,473,"fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp))","fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_310.cpp,"{
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_310.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,501,478,"fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp))","fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_311.cpp,"{
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_311.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,509,485,"fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp))","fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_312.cpp,"{
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_312.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 5"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_274.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,519,494,"fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL)","fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_313.cpp,"{
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_313.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_275.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,563,536,"fprintf(stderr, ""kwsysProcess_New returned NULL!\n"")","fprintf(stderr, ""kwsysProcess_New returned NULL!\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_314.cpp,"{
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_314.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
95a97a40e48a0db2b206c4560d6962be3666812c,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2016-11-09 (18c65411)",[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_276.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; ++c)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; ++c) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,640,618,"fprintf(stderr, ""Invalid test number %d.\n"", n)","fprintf(stderr, ""Invalid test number %d.\n"", n)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_315.cpp,"{
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_315.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 1"", "" 13"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 43"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 59"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 2"", "" 0"", "" 29"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_277.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,607,565,"sprintf(argument, ""%s"", sit->c_str())","sprintf(argument, ""%s"", sit->c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_316.cpp,"{
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_316.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 1"", "" 5"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 50"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 13"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 8"", "" 0"", "" 14"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_277.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_277.cpp,"  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  /*
  // This can help debugging help string
  str << endl;
","  maxlen += 4; // For the space before and after the option

  // Print help for each option
  for (mpit = mp.begin(); mpit != mp.end(); mpit++) {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for (sit = mpit->second.begin(); sit != mpit->second.end(); sit++) {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch (this->Internals->Callbacks[*sit].ArgumentType) {
        case CommandLineArguments::NO_ARGUMENT:
          break;
        case CommandLineArguments::CONCAT_ARGUMENT:
          strcat(argument, ""opt"");
          break;
        case CommandLineArguments::SPACE_ARGUMENT:
          strcat(argument, "" opt"");
          break;
        case CommandLineArguments::EQUAL_ARGUMENT:
          strcat(argument, ""=opt"");
          break;
        case CommandLineArguments::MULTI_ARGUMENT:
          strcat(argument, "" opt opt ..."");
          break;
      }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
    }
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    size_t len = strlen(ptr);
    int cnt = 0;
    while (len > 0) {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for (cc = 0; ptr[cc]; cc++) {
        if (*ptr == ' ' || *ptr == '\t') {
          ptr++;
          len--;
        }
      }
      if (cnt > 0) {
        for (cc = 0; cc < maxlen; cc++) {
          str << "" "";
        }
      }
      CommandLineArguments::Internal::String::size_type skip = len;
      if (skip > this->LineLength - maxlen) {
        skip = this->LineLength - maxlen;
        for (cc = skip - 1; cc > 0; cc--) {
          if (ptr[cc] == ' ' || ptr[cc] == '\t') {
            break;
          }
        }
        if (cc != 0) {
          skip = cc;
        }
      }
      str.write(ptr, static_cast<std::streamsize>(skip));
      str << std::endl;
      ptr += skip;
      len -= skip;
      cnt++;
    }
  }
  /*
  // This can help debugging help string
  str << endl;
",595,557,617,583,"sprintf(buffer, format, argument)","sprintf(buffer, format, argument)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_317.cpp,"{
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_317.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 1"", "" 5"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 50"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 13"", "" 0"", "" 31"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 8"", "" 0"", "" 14"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_278.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,126,114,"sprintf(buf, ""%s*"", name.c_str())","sprintf(buf, ""%s*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_318.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_318.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_278.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,135,120,"sprintf(buf, ""%s\\*"", name.c_str())","sprintf(buf, ""%s\\*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_319.cpp,"{
      sprintf(buf, ""%s\\*"", name.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_319.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_278.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' || *name.rbegin() == '\\' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if ( name.find('\\') != name.npos )
      {
      sprintf(buf, ""%s\\*"", name.c_str());
      }
    else
      {
      sprintf(buf, ""%s/*"", name.c_str());
      }
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  do
    {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/' || *name.rbegin() == '\\') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    // Make sure the slashes in the wildcard suffix are consistent with the
    // rest of the path
    buf = new char[n + 2 + 1];
    if (name.find('\\') != name.npos) {
      sprintf(buf, ""%s\\*"", name.c_str());
    } else {
      sprintf(buf, ""%s/*"", name.c_str());
    }
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  do {
    this->Internal->Files.push_back(Encoding::ToNarrow(data.name));
  } while (_wfindnext_func(srchHandle, &data) != -1);
  this->Internal->Path = name;
  return _findclose(srchHandle) != -1;
}
",120,109,139,122,"sprintf(buf, ""%s/*"", name.c_str())","sprintf(buf, ""%s/*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_320.cpp,"{
      sprintf(buf, ""%s/*"", name.c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_320.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 3"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_279.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,176,156,"sprintf(buf, ""%s*"", name.c_str())","sprintf(buf, ""%s*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_321.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_321.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Directory.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_279.cpp,"#endif
  char* buf;
  size_t n = name.size();
  if ( *name.rbegin() == '/' )
    {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
    }
  else
    {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }
  struct _wfinddata_t data;      // data of current file

  // Now put them into the file array
  srchHandle = _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete [] buf;

  if ( srchHandle == -1 )
    {
    return 0;
    }

  // Loop through names
  unsigned long count = 0;
  do
    {
    count++;
    }
  while ( _wfindnext_func(srchHandle, &data) != -1 );
  _findclose(srchHandle);
  return count;
}
","#endif
  char* buf;
  size_t n = name.size();
  if (*name.rbegin() == '/') {
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name.c_str());
  } else {
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
  }
  struct _wfinddata_t data; // data of current file

  // Now put them into the file array
  srchHandle =
    _wfindfirst_func((wchar_t*)Encoding::ToWide(buf).c_str(), &data);
  delete[] buf;

  if (srchHandle == -1) {
    return 0;
  }

  // Loop through names
  unsigned long count = 0;
  do {
    count++;
  } while (_wfindnext_func(srchHandle, &data) != -1);
  _findclose(srchHandle);
  return count;
}
",170,151,181,159,"sprintf(buf, ""%s/*"", name.c_str())","sprintf(buf, ""%s/*"", name.c_str())",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_322.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_322.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],IOStream.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_280.cpp,"
// Read an integer value from an input stream.
template <class T>
std::istream&
IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if(okay)
    {
    try {
    // Copy the string to a buffer and construct the format string.
    char buffer[KWSYS_IOS_INT64_MAX_DIG];
#   if defined(_MSC_VER)
    char format[] = ""%I64_"";
    const int typeIndex = 4;
#   else
    char format[] = ""%ll_"";
    const int typeIndex = 3;
#   endif
    switch(IOStreamScanStream(is, buffer))
      {
      case 8: format[typeIndex] = 'o'; break;
      case 0: // Default to decimal if not told otherwise.
      case 10: format[typeIndex] = type; break;
      case 16: format[typeIndex] = 'x'; break;
      };

    // Use sscanf to parse the number from the buffer.
    T result;
    int success = (sscanf(buffer, format, &result) == 1)?1:0;

    // Set flags for resulting state.
    if(is.peek() == EOF) { state |= std::ios_base::eofbit; }
    if(!success) { state |= std::ios_base::failbit; }
    else { value = result; }
    } catch(...) { state |= std::ios_base::badbit; }
    }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream&
IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if(okay)
    {
    try {
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    } catch(...) { os.clear(os.rdstate() | std::ios_base::badbit); }
    }
  return os;
}

# if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
","
// Read an integer value from an input stream.
template <class T>
std::istream& IOStreamScanTemplate(std::istream& is, T& value, char type)
{
  int state = std::ios_base::goodbit;

  // Skip leading whitespace.
  std::istream::sentry okay(is);

  if (okay) {
    try {
      // Copy the string to a buffer and construct the format string.
      char buffer[KWSYS_IOS_INT64_MAX_DIG];
#if defined(_MSC_VER)
      char format[] = ""%I64_"";
      const int typeIndex = 4;
#else
      char format[] = ""%ll_"";
      const int typeIndex = 3;
#endif
      switch (IOStreamScanStream(is, buffer)) {
        case 8:
          format[typeIndex] = 'o';
          break;
        case 0: // Default to decimal if not told otherwise.
        case 10:
          format[typeIndex] = type;
          break;
        case 16:
          format[typeIndex] = 'x';
          break;
      };

      // Use sscanf to parse the number from the buffer.
      T result;
      int success = (sscanf(buffer, format, &result) == 1) ? 1 : 0;

      // Set flags for resulting state.
      if (is.peek() == EOF) {
        state |= std::ios_base::eofbit;
      }
      if (!success) {
        state |= std::ios_base::failbit;
      } else {
        value = result;
      }
    } catch (...) {
      state |= std::ios_base::badbit;
    }
  }

  is.setstate(std::ios_base::iostate(state));
  return is;
}

// Print an integer value to an output stream.
template <class T>
std::ostream& IOStreamPrintTemplate(std::ostream& os, T value, char type)
{
  std::ostream::sentry okay(os);
  if (okay) {
    try {
      // Construct the format string.
      char format[8];
      char* f = format;
      *f++ = '%';
      if (os.flags() & std::ios_base::showpos) {
        *f++ = '+';
      }
      if (os.flags() & std::ios_base::showbase) {
        *f++ = '#';
      }
#if defined(_MSC_VER)
      *f++ = 'I';
      *f++ = '6';
      *f++ = '4';
#else
      *f++ = 'l';
      *f++ = 'l';
#endif
      long bflags = os.flags() & std::ios_base::basefield;
      if (bflags == std::ios_base::oct) {
        *f++ = 'o';
      } else if (bflags != std::ios_base::hex) {
        *f++ = type;
      } else if (os.flags() & std::ios_base::uppercase) {
        *f++ = 'X';
      } else {
        *f++ = 'x';
      }
      *f = '\0';

      // Use sprintf to print to a buffer and then write the
      // buffer to the stream.
      char buffer[2 * KWSYS_IOS_INT64_MAX_DIG];
      sprintf(buffer, format, value);
      os << buffer;
    } catch (...) {
      os.clear(os.rdstate() | std::ios_base::badbit);
    }
  }
  return os;
}

#if !KWSYS_IOS_HAS_ISTREAM_LONG_LONG
// Implement input stream operator for IOStreamSLL.
std::istream& IOStreamScan(std::istream& is, IOStreamSLL& value)
{
",123,107,199,203,"sprintf(buffer, format, value)","sprintf(buffer, format, value)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_323.cpp,"{
    // Construct the format string.
    char format[8];
    char* f = format;
    *f++ = '%';
    if(os.flags() & std::ios_base::showpos) { *f++ = '+'; }
    if(os.flags() & std::ios_base::showbase) { *f++ = '#'; }
#   if defined(_MSC_VER)
    *f++ = 'I'; *f++ = '6'; *f++ = '4';
#   else
    *f++ = 'l'; *f++ = 'l';
#   endif
    long bflags = os.flags() & std::ios_base::basefield;
    if(bflags == std::ios_base::oct) { *f++ = 'o'; }
    else if(bflags != std::ios_base::hex) { *f++ = type; }
    else if(os.flags() & std::ios_base::uppercase) { *f++ = 'X'; }
    else { *f++ = 'x'; }
    *f = '\0';

    // Use sprintf to print to a buffer and then write the
    // buffer to the stream.
    char buffer[2*KWSYS_IOS_INT64_MAX_DIG];
    sprintf(buffer, format, value);
    os << buffer;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_323.cpp,"[""6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 72"", "" 0"", "" 0"", "" 4"", "" 4"", "" 0"", "" 0"", "" 2"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 62"", "" 0"", "" 29"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 2"", "" 0"", "" 5"", "" 5"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 15"", "" 2"", "" 4"", "" 3""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_281.cpp,"#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if(GetConsoleScreenBufferInfo(hOut, &hOutInfo))
    {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
    }
#endif
  if(!pipeIsConsole && kwsysTerminalStreamIsVT100(stream,
                                                  default_vt100, default_tty))
    {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
    }

  /* Format the text into the stream.  */
  {
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }

  /* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if(pipeIsConsole)
    {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
    }
#endif
  if(pipeIsVT100)
    {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
    }
}

/*--------------------------------------------------------------------------*/
","#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  CONSOLE_SCREEN_BUFFER_INFO hOutInfo;
  HANDLE hOut = kwsysTerminalGetStreamHandle(stream);
  if (GetConsoleScreenBufferInfo(hOut, &hOutInfo)) {
    pipeIsConsole = 1;
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream, color);
  }
#endif
  if (!pipeIsConsole &&
      kwsysTerminalStreamIsVT100(stream, default_vt100, default_tty)) {
    pipeIsVT100 = 1;
    kwsysTerminalSetVT100Color(stream, color);
  }

  /* Format the text into the stream.  */
  {
    va_list var_args;
    va_start(var_args, format);
    vfprintf(stream, format, var_args);
    va_end(var_args);
  }

/* Restore the normal color state for the stream.  */
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)
  if (pipeIsConsole) {
    kwsysTerminalSetConsoleColor(hOut, &hOutInfo, stream,
                                 kwsysTerminal_Color_Normal);
  }
#endif
  if (pipeIsVT100) {
    kwsysTerminalSetVT100Color(stream, kwsysTerminal_Color_Normal);
  }
}

/*--------------------------------------------------------------------------*/
",68,58,88,76,"vfprintf(stream, format, var_args)","vfprintf(stream, format, var_args)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_324.cpp,"{
  va_list var_args;
  va_start(var_args, format);
  vfprintf(stream, format, var_args);
  va_end(var_args);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_324.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 3"", "" 0"", "" 6"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_282.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,268,244,"fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)","fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_325.cpp,"{
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_325.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_282.cpp,"
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL              ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD                ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE           ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK               ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE             ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK    ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED      ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN    ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW   ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE     ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA  ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN     ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE    ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK    ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED      ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN    ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW   ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE     ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA  ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN     ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE    ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if(color == kwsysTerminal_Color_Normal)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
    }

  switch(color & kwsysTerminal_Color_ForegroundMask)
    {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
","
/*--------------------------------------------------------------------------*/
/* VT100 escape sequence strings.  */
#define KWSYS_TERMINAL_VT100_NORMAL ""\33[0m""
#define KWSYS_TERMINAL_VT100_BOLD ""\33[1m""
#define KWSYS_TERMINAL_VT100_UNDERLINE ""\33[4m""
#define KWSYS_TERMINAL_VT100_BLINK ""\33[5m""
#define KWSYS_TERMINAL_VT100_INVERSE ""\33[7m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLACK ""\33[30m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_RED ""\33[31m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_GREEN ""\33[32m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_YELLOW ""\33[33m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_BLUE ""\33[34m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_MAGENTA ""\33[35m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_CYAN ""\33[36m""
#define KWSYS_TERMINAL_VT100_FOREGROUND_WHITE ""\33[37m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLACK ""\33[40m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_RED ""\33[41m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_GREEN ""\33[42m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW ""\33[43m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_BLUE ""\33[44m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA ""\33[45m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_CYAN ""\33[46m""
#define KWSYS_TERMINAL_VT100_BACKGROUND_WHITE ""\33[47m""

/*--------------------------------------------------------------------------*/
/* Write VT100 escape sequences to the stream for the given color.  */
static void kwsysTerminalSetVT100Color(FILE* stream, int color)
{
  if (color == kwsysTerminal_Color_Normal) {
    fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
    return;
  }

  switch (color & kwsysTerminal_Color_ForegroundMask) {
    case kwsysTerminal_Color_Normal:
      fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL);
      break;
",237,214,275,250,"fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)","fprintf(stream, KWSYS_TERMINAL_VT100_NORMAL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_326.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_326.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_283.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_283.cpp,"    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
    }
  switch(color & kwsysTerminal_Color_BackgroundMask)
    {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
","    case kwsysTerminal_Color_ForegroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE);
      break;
  }
  switch (color & kwsysTerminal_Color_BackgroundMask) {
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
",298,273,299,274,"fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE)","fprintf(stream, KWSYS_TERMINAL_VT100_FOREGROUND_WHITE)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_327.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_327.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],Terminal.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_284.cpp,"    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }
  if(color & kwsysTerminal_Color_ForegroundBold)
    {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
    }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

# define KWSYS_TERMINAL_MASK_FOREGROUND \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
# define KWSYS_TERMINAL_MASK_BACKGROUND \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
","    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
  }
  if (color & kwsysTerminal_Color_ForegroundBold) {
    fprintf(stream, KWSYS_TERMINAL_VT100_BOLD);
  }
}

/*--------------------------------------------------------------------------*/
#if defined(KWSYS_TERMINAL_SUPPORT_CONSOLE)

#define KWSYS_TERMINAL_MASK_FOREGROUND                                        \
  (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY)
#define KWSYS_TERMINAL_MASK_BACKGROUND                                        \
  (BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)

/* Get the Windows handle for a FILE stream.  */
",325,299,326,300,"fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE)","fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_328.cpp,"{
    case kwsysTerminal_Color_BackgroundBlack:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLACK);
      break;
    case kwsysTerminal_Color_BackgroundRed:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_RED);
      break;
    case kwsysTerminal_Color_BackgroundGreen:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_GREEN);
      break;
    case kwsysTerminal_Color_BackgroundYellow:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_YELLOW);
      break;
    case kwsysTerminal_Color_BackgroundBlue:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_BLUE);
      break;
    case kwsysTerminal_Color_BackgroundMagenta:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_MAGENTA);
      break;
    case kwsysTerminal_Color_BackgroundCyan:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_CYAN);
      break;
    case kwsysTerminal_Color_BackgroundWhite:
      fprintf(stream, KWSYS_TERMINAL_VT100_BACKGROUND_WHITE);
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_328.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 32"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 32"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 8"", "" 0"", "" 16"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_285.cpp,"  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}

static int testMD5_2(kwsysMD5* md5)
","  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0) ? 1 : 0;
}

static int testMD5_2(kwsysMD5* md5)
",40,31,40,31,"printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out)","printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_329.cpp,"{
  char md5out[33];
  kwsysMD5_Initialize(md5);
  kwsysMD5_Append(md5, testMD5input1, -1);
  kwsysMD5_FinalizeHex(md5, md5out);
  md5out[32] = 0;
  printf(""md5sum 1: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output1, md5out);
  return (strcmp(md5out, testMD5output1) != 0)? 1:0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_329.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 19"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 1"", "" 22"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 5"", "" 0"", "" 0"", "" 5"", "" 0"", "" 11"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testEncode.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_286.cpp,"  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}

int testEncode(int argc, char* argv[])
","  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0) ? 1 : 0;
}

int testEncode(int argc, char* argv[])
",55,46,55,46,"printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out)","printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_330.cpp,"{
  unsigned char digest[16];
  char md5out[33];
  kwsysMD5_Initialize(md5);
  kwsysMD5_Append(md5, testMD5input2, testMD5input2len);
  kwsysMD5_Finalize(md5, digest);
  kwsysMD5_DigestToHex(digest, md5out);
  md5out[32] = 0;
  printf(""md5sum 2: expected [%s]\n""
         ""               got [%s]\n"",
         testMD5output2, md5out);
  return (strcmp(md5out, testMD5output2) != 0)? 1:0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_330.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 27"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 1"", "" 26"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 3"", "" 0"", "" 1"", "" 1"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 6"", "" 0"", "" 13"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,89,80,"fprintf(stdout, ""Output on stdout from test returning 0.\n"")","fprintf(stdout, ""Output on stdout from test returning 0.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_331.cpp,"{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_331.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,90,81,"fprintf(stderr, ""Output on stderr from test returning 0.\n"")","fprintf(stderr, ""Output on stderr from test returning 0.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_332.cpp,"{
  /* This is a very basic functional test of kwsysProcess.  It is repeated
     numerous times to verify that there are no resource leaks in kwsysProcess
     that eventually lead to an error.  Many versions of OS X will fail after
     256 leaked file handles, so 257 iterations seems to be a good test.  On
     the other hand, too many iterations will cause the test to time out -
     especially if the test is instrumented with e.g. valgrind.

     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_332.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,97,89,"fprintf(stdout, ""Output on stdout from test returning 123.\n"")","fprintf(stdout, ""Output on stdout from test returning 123.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_333.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_333.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,98,90,"fprintf(stderr, ""Output on stderr from test returning 123.\n"")","fprintf(stderr, ""Output on stderr from test returning 123.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_334.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_334.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 4"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,105,98,"fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"")","fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_335.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_335.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 11"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_287.cpp,"     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
","     If you have problems with this test timing out on your system, or want to
     run more than 257 iterations, you can change the number of iterations by
     setting the KWSYS_TEST_PROCESS_1_COUNT environment variable.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 0.\n"");
  fprintf(stderr, ""Output on stderr from test returning 0.\n"");
  return 0;
}

static int test2(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from test returning 123.\n"");
  fprintf(stderr, ""Output on stderr from test returning 123.\n"");
  return 123;
}

static int test3(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
",85,75,106,99,"fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"")","fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_336.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_336.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 11"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_288.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,133,127,"fprintf(stdout, ""Output before crash on stdout from crash test.\n"")","fprintf(stdout, ""Output before crash on stdout from crash test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_337.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_337.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_288.cpp,"  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
","  /* Avoid error diagnostic popups since we are crashing on purpose.  */
  disable_debugger(1);
#endif
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output before crash on stdout from crash test.\n"");
  fprintf(stderr, ""Output before crash on stderr from crash test.\n"");
  fflush(stdout);
",129,122,134,128,"fprintf(stderr, ""Output before crash on stderr from crash test.\n"")","fprintf(stderr, ""Output before crash on stderr from crash test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_338.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_338.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_289.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,155,149,"fprintf(stderr, ""Output on stderr before recursive test.\n"");","fprintf(stderr, ""Output on stderr before recursive test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_339.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_339.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_289.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,160,154,"fprintf(stdout, ""Output on stdout after recursive test.\n"")","fprintf(stdout, ""Output on stdout after recursive test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_340.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_340.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_289.cpp,"  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096*2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE+1];
  (void)argc; (void)argv;
  for(i=0;i < TEST6_SIZE;++i)
    {
    runaway[i] = '.';
    }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for(;;)
    {
    fwrite(runaway, 1, TEST6_SIZE+1, stdout);
    fflush(stdout);
    }
}

/* Define MINPOLL to be one more than the number of times output is
","  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception, kwsysProcess_Exception_Fault,
               1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}

#define TEST6_SIZE (4096 * 2)
static void test6(int argc, const char* argv[])
{
  int i;
  char runaway[TEST6_SIZE + 1];
  (void)argc;
  (void)argv;
  for (i = 0; i < TEST6_SIZE; ++i) {
    runaway[i] = '.';
  }
  runaway[TEST6_SIZE] = '\n';

  /* Generate huge amounts of output to test killing.  */
  for (;;) {
    fwrite(runaway, 1, TEST6_SIZE + 1, stdout);
    fflush(stdout);
  }
}

/* Define MINPOLL to be one more than the number of times output is
",155,149,161,155,"fprintf(stderr, ""Output on stderr after recursive test.\n"")","fprintf(stderr, ""Output on stderr after recursive test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_341.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_341.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_290.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,195,189,"fprintf(stdout, ""Output on stdout before sleep.\n"")","fprintf(stdout, ""Output on stdout before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_342.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_342.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_290.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_290.cpp,"#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
","#define MAXPOLL 20
static int test7(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
",191,184,196,190,"fprintf(stderr, ""Output on stderr before sleep.\n"")","fprintf(stderr, ""Output on stderr before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_343.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_343.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_291.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,235,230,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_344.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* TODO: Instead of closing pipes here leave them open to make sure
     the grandparent can stop listening when the parent exits.  This
     part of the test cannot be enabled until the feature is
     implemented.  */
  fclose(stdout);
  fclose(stderr);
  testProcess_sleep(15);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_344.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 9"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_291.cpp,"
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","
static int test8_grandchild(int argc, const char* argv[])
{
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",231,225,236,231,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_345.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* TODO: Instead of closing pipes here leave them open to make sure
     the grandparent can stop listening when the parent exits.  This
     part of the test cannot be enabled until the feature is
     implemented.  */
  fclose(stdout);
  fclose(stderr);
  testProcess_sleep(15);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_345.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 17"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 19"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 0"", "" 9"", "" 0"", "" 9"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_292.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited,
               kwsysProcess_Exception_None,
               0, 1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exited, kwsysProcess_Exception_None, 0,
               1, 1, 0, 30, 0, 1, 0, 0, 0);
  /* This sleep will avoid a race condition between this function exiting
     normally and our Ctrl+C handler exiting abnormally after the process
     exits.  */
",266,261,266,261,"fprintf(stderr, ""Output on stderr before grandchild test.\n"");","fprintf(stderr, ""Output on stderr before grandchild test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_346.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_346.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_293.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,313,306,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_347.cpp,"{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 9 seconds.  */
  testProcess_sleep(9);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_347.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 15"", "" 0"", "" 0"", "" 14"", "" 0"", "" 24"", "" 3""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_293.cpp,"static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
","static int test9_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc;
  (void)argv;
#if defined(_WIN32)
  if (!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE)) {
    return 1;
  }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if (sigaction(SIGINT, &sa, 0) < 0) {
    return 1;
  }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
",294,288,314,307,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_348.cpp,"{
  /* The grandchild just sleeps for a few seconds while ignoring signals.  */
  (void)argc; (void)argv;
#if defined(_WIN32)
  if(!SetConsoleCtrlHandler(test9_grandchild_handler, TRUE))
    {
    return 1;
    }
#else
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  sigemptyset(&sa.sa_mask);
  if(sigaction(SIGINT, &sa, 0) < 0)
    {
    return 1;
    }
#endif
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 9 seconds.  */
  testProcess_sleep(9);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_348.cpp,"[""3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 12"", "" 0"", "" 44"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 2"", "" 2"", "" 1"", "" 0"", "" 15"", "" 0"", "" 0"", "" 14"", "" 0"", "" 24"", "" 3""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_294.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,341,334,"fprintf(stderr, ""Output on stderr before grandchild test.\n"");","fprintf(stderr, ""Output on stderr before grandchild test.\n"");",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_349.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_349.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_294.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,347,340,"fprintf(stdout, ""Output on stdout after grandchild test.\n"")","fprintf(stdout, ""Output on stdout after grandchild test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_350.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_350.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_294.cpp,"  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r =
    runChild(cmd, kwsysProcess_State_Exception,
             kwsysProcess_Exception_Interrupt, 0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",341,334,348,341,"fprintf(stderr, ""Output on stderr after grandchild test.\n"")","fprintf(stderr, ""Output on stderr after grandchild test.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_351.cpp,"{
  /* Test Ctrl+C behavior: the root test program will send a Ctrl+C to this
     process.  Here, we start a child process that sleeps for a long time and
     processes signals normally.  However, this grandchild is created in a new
     process group - ensuring that Ctrl+C we receive is sent to our process
     groups.  We make sure it exits anyway.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""110"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Interrupt,
               0, 1, 1, 0, 30, 0, 1, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_351.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 39"", "" 0"", "" 0"", "" 2"", "" 2"", "" 0"", "" 0"", "" 0"", "" 23"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 7"", "" 0"", "" 46"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 14"", "" 0"", "" 25"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_295.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,358,352,"fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")","fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_352.cpp,"{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 6 seconds.  */
  testProcess_sleep(6);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_352.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_295.cpp,"static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
","static int test10_grandchild(int argc, const char* argv[])
{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc;
  (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
",354,347,359,353,"fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")","fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_353.cpp,"{
  /* The grandchild just sleeps for a few seconds and handles signals.  */
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout from grandchild before sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 6 seconds.  */
  testProcess_sleep(6);
  fprintf(stdout, ""Output on stdout from grandchild after sleep.\n"");
  fprintf(stderr, ""Output on stderr from grandchild after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_353.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 21"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 25"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 9"", "" 0"", "" 0"", "" 11"", "" 0"", "" 13"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,422,405,"fprintf(stdout, ""WaitForData timeout reached.\n"")","fprintf(stdout, ""WaitForData timeout reached.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_354.cpp,"{
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_354.cpp,"[""1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 12"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 1"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 4"", "" 0"", "" 7"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,429,411,"fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL)","fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_355.cpp,"{
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_355.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,467,440,"printf(""No process has been executed.\n"")","printf(""No process has been executed.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_356.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_356.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,469,443,"printf(""The process is still executing.\n"")","printf(""The process is still executing.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_357.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_357.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,471,446,"printf(""Child was killed when timeout expired.\n"")","printf(""Child was killed when timeout expired.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_358.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_358.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,473,449,"printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp))","printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_359.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_359.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,478,454,"printf(""Child was killed by parent.\n"")","printf(""Child was killed by parent.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_360.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_360.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,480,457,"printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp))","printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_361.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_361.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,485,463,"printf(""Child was disowned.\n"")","printf(""Child was disowned.\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_362.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_362.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,487,466,"printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp))","printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_363.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_363.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,495,473,"fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp))","fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_364.cpp,"{
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_364.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,501,478,"fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp))","fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_365.cpp,"{
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_365.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 1"", "" 0"", "" 5"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,509,485,"fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp))","fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp))",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_366.cpp,"{
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_366.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 7"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 2"", "" 0"", "" 5"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_296.cpp,"  return 0;
}

static int runChild2(kwsysProcess* kp,
              const char* cmd[], int state, int exception, int value,
              int share, int output, int delay, double timeout,
              int poll, int disown, int createNewGroup,
              unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if(timeout >= 0)
    {
    kwsysProcess_SetTimeout(kp, timeout);
    }
  if(share)
    {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
    }
  if(disown)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
    }
  if(createNewGroup)
    {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
    }
  kwsysProcess_Execute(kp);

  if(poll)
    {
    pUserTimeout = &userTimeout;
    }

  if(interruptDelay)
    {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
    }

  if(!share && !disown)
    {
    int p;
    while((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout)))
      {
      if(output)
        {
        if(poll && p == kwsysProcess_Pipe_Timeout)
          {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if(++poll >= MAXPOLL)
            {
            fprintf(stdout, ""Poll count reached limit %d.\n"",
                    MAXPOLL);
            kwsysProcess_Kill(kp);
            }
          }
        else
          {
          fwrite(data, 1, (size_t) length, stdout);
          fflush(stdout);
          }
        }
      if(poll)
        {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
        }
      if(delay)
        {
        /* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
        }
      }
    }

  if(disown)
    {
    kwsysProcess_Disown(kp);
    }
  else
    {
    kwsysProcess_WaitForExit(kp, 0);
    }

  switch (kwsysProcess_GetState(kp))
    {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n""); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    };

  if(result)
    {
    if(exception != kwsysProcess_GetExitException(kp))
      {
      fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
      }
    if(value != kwsysProcess_GetExitValue(kp))
      {
      fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
      }
    }

  if(kwsysProcess_GetState(kp) != state)
    {
    fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
    }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if(poll && poll < MINPOLL)
    {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }

  return result;
}
","  return 0;
}

static int runChild2(kwsysProcess* kp, const char* cmd[], int state,
                     int exception, int value, int share, int output,
                     int delay, double timeout, int poll, int disown,
                     int createNewGroup, unsigned int interruptDelay)
{
  int result = 0;
  char* data = 0;
  int length = 0;
  double userTimeout = 0;
  double* pUserTimeout = 0;
  kwsysProcess_SetCommand(kp, cmd);
  if (timeout >= 0) {
    kwsysProcess_SetTimeout(kp, timeout);
  }
  if (share) {
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDOUT, 1);
    kwsysProcess_SetPipeShared(kp, kwsysProcess_Pipe_STDERR, 1);
  }
  if (disown) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_Detach, 1);
  }
  if (createNewGroup) {
    kwsysProcess_SetOption(kp, kwsysProcess_Option_CreateProcessGroup, 1);
  }
  kwsysProcess_Execute(kp);

  if (poll) {
    pUserTimeout = &userTimeout;
  }

  if (interruptDelay) {
    testProcess_sleep(interruptDelay);
    kwsysProcess_Interrupt(kp);
  }

  if (!share && !disown) {
    int p;
    while ((p = kwsysProcess_WaitForData(kp, &data, &length, pUserTimeout))) {
      if (output) {
        if (poll && p == kwsysProcess_Pipe_Timeout) {
          fprintf(stdout, ""WaitForData timeout reached.\n"");
          fflush(stdout);

          /* Count the number of times we polled without getting data.
             If it is excessive then kill the child and fail.  */
          if (++poll >= MAXPOLL) {
            fprintf(stdout, ""Poll count reached limit %d.\n"", MAXPOLL);
            kwsysProcess_Kill(kp);
          }
        } else {
          fwrite(data, 1, (size_t)length, stdout);
          fflush(stdout);
        }
      }
      if (poll) {
        /* Delay to avoid busy loop during polling.  */
        testProcess_usleep(100000);
      }
      if (delay) {
/* Purposely sleeping only on Win32 to let pipe fill up.  */
#if defined(_WIN32)
        testProcess_usleep(100000);
#endif
      }
    }
  }

  if (disown) {
    kwsysProcess_Disown(kp);
  } else {
    kwsysProcess_WaitForExit(kp, 0);
  }

  switch (kwsysProcess_GetState(kp)) {
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n"");
      break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n"");
      break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n"");
      break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"", kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n"");
      break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp)));
      break;
    case kwsysProcess_State_Disowned:
      printf(""Child was disowned.\n"");
      break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp));
      break;
  };

  if (result) {
    if (exception != kwsysProcess_GetExitException(kp)) {
      fprintf(stderr, ""Mismatch in exit exception.  ""
                      ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));
    }
    if (value != kwsysProcess_GetExitValue(kp)) {
      fprintf(stderr, ""Mismatch in exit value.  ""
                      ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));
    }
  }

  if (kwsysProcess_GetState(kp) != state) {
    fprintf(stderr, ""Mismatch in state.  ""
                    ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));
    result = 1;
  }

  /* We should have polled more times than there were data if polling
     was enabled.  */
  if (poll && poll < MINPOLL) {
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL);
    result = 1;
  }

  return result;
}
",368,362,519,494,"fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL)","fprintf(stderr, ""Poll count is %d, which is less than %d.\n"", poll,
            MINPOLL)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_367.cpp,"{
    fprintf(stderr, ""Poll count is %d, which is less than %d.\n"",
            poll, MINPOLL);
    result = 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_367.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 5"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 6"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 2"", "" 0"", "" 4"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_297.cpp," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value,
             int share, int output, int delay, double timeout,
             int poll, int repeat, int disown, int createNewGroup,
             unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if(!kp)
    {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }
  while(repeat-- > 0)
    {
    result = runChild2(kp, cmd, state, exception, value, share,
                       output, delay, timeout, poll, disown, createNewGroup,
                       interruptDelay);
    if(result)
      {
      break;
      }
    }
  kwsysProcess_Delete(kp);
  return result;
}
"," *                  BEFORE any reading/polling of pipes occurs and before any
 *                  detachment occurs.
 */
int runChild(const char* cmd[], int state, int exception, int value, int share,
             int output, int delay, double timeout, int poll, int repeat,
             int disown, int createNewGroup, unsigned int interruptDelay)
{
  int result = 1;
  kwsysProcess* kp = kwsysProcess_New();
  if (!kp) {
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
  }
  while (repeat-- > 0) {
    result = runChild2(kp, cmd, state, exception, value, share, output, delay,
                       timeout, poll, disown, createNewGroup, interruptDelay);
    if (result) {
      break;
    }
  }
  kwsysProcess_Delete(kp);
  return result;
}
",551,526,563,536,"fprintf(stderr, ""kwsysProcess_New returned NULL!\n"")","fprintf(stderr, ""kwsysProcess_New returned NULL!\n"")",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_368.cpp,"{
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_368.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 1"", "" 0"", "" 2"", "" 0""]"
773b36e5d4af3ac040625e0ea16bcfd30fcdeb6d,"KWSys 2016-11-09 (18c65411)

Code extracted from:

    http://public.kitware.com/KWSys.git

at commit 18c654114de3aa65429542f95308720bc68f9231 (master).

Upstream Shortlog
-----------------

Brad King (14):
      37306a1c FStream: Quiet unused argument warning
      15e90a3c Sort includes to stabilize include order w.r.t. clang-format
      26509227 Copyright.txt: Add notice of copyright by contributors
      fc42d3f2 Add temporary script to filter license notices
      c41c1bc4 Simplify KWSys per-source license notices
      1d4c0b4a Remove temporary script that filtered license notices
      a4f5ef79 SystemInformation: Remove stray comment
      8649a886 kwsysPrivate: Protect KWSYS_HEADER macro from clang-format
      89b98af5 Configure clang-format for KWSys source tree
      547dacad Add a script to run clang-format on the entire source tree
      aa94be0c CONTRIBUTING: Add a section on coding style
      6604c4b6 Empty commit at end of history preceding clang-format style transition
      2b3e2b1c Tell Git to not export 'clang-format' infrastructure
      18c65411 FStream: Include Configure.hxx before other headers

Kitware Robot (1):
      6c973b46 Revise C++ coding style using clang-format",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_143.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_298.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_298.cpp,"    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if(argc == 2)
    {
    n = atoi(argv[1]);
    }
  else if(argc == 3 && strcmp(argv[1], ""run"") == 0)
    {
    n = atoi(argv[2]);
    }
  /* Check arguments.  */
  if(((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3)
    {
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
      kwsysProcess_State_Expired, /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] =
    {
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_None,
      kwsysProcess_Exception_Interrupt
    };
    int values[10] = {0, 123, 1, 1, 0, 0, 0, 0, 1, 1};
    int shares[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    int outputs[10] = {1, 1, 1, 1, 1, 0, 1, 1, 1, 1};
    int delays[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
    double timeouts[10] = {10, 10, 10, 30, 30, 10, -1, 10, 6, 4};
    int polls[10] = {0, 0, 0, 0, 0, 0, 1, 0, 0, 0};
    int repeat[10] = {257, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    int createNewGroups[10] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1};
    unsigned int interruptDelays[10] = {0, 0, 0, 0, 0, 0, 0, 0, 3, 2};
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if(test1IterationsStr)
      {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if(test1Iterations > 10 && test1Iterations != LONG_MAX)
        {
        repeat[0] = (int)test1Iterations;
        }
      }
#ifdef _WIN32
    if(n == 0 && (argv0 = strdup(argv[0])))
      {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for(c=argv0; *c; ++c)
        {
        if(*c == '\\')
          {
          *c = '/';
          }
        }
      cmd[0] = argv0;
      }
    else
      {
      cmd[0] = argv[0];
      }
#else
    cmd[0] = argv[0];
#endif
","    SetStdHandle(STD_ERROR_HANDLE, out);
    }
#endif
  if (argc == 2) {
    n = atoi(argv[1]);
  } else if (argc == 3 && strcmp(argv[1], ""run"") == 0) {
    n = atoi(argv[2]);
  }
  /* Check arguments.  */
  if (((n >= 1 && n <= 10) || n == 108 || n == 109 || n == 110) && argc == 3) {
    /* This is the child process for a requested test number.  */
    switch (n) {
      case 1:
        return test1(argc, argv);
      case 2:
        return test2(argc, argv);
      case 3:
        return test3(argc, argv);
      case 4:
        return test4(argc, argv);
      case 5:
        return test5(argc, argv);
      case 6:
        test6(argc, argv);
        return 0;
      case 7:
        return test7(argc, argv);
      case 8:
        return test8(argc, argv);
      case 9:
        return test9(argc, argv);
      case 10:
        return test10(argc, argv);
      case 108:
        return test8_grandchild(argc, argv);
      case 109:
        return test9_grandchild(argc, argv);
      case 110:
        return test10_grandchild(argc, argv);
    }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
  } else if (n >= 1 && n <= 10) {
    /* This is the parent process for a requested test number.  */
    int states[10] = {
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  kwsysProcess_State_Exception,
      kwsysProcess_State_Exited,   kwsysProcess_State_Expired,
      kwsysProcess_State_Exited,   kwsysProcess_State_Exited,
      kwsysProcess_State_Expired,  /* Ctrl+C handler test */
      kwsysProcess_State_Exception /* Process group test */
    };
    int exceptions[10] = {
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Fault,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_None,
      kwsysProcess_Exception_None, kwsysProcess_Exception_Interrupt
    };
    int values[10] = { 0, 123, 1, 1, 0, 0, 0, 0, 1, 1 };
    int shares[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    int outputs[10] = { 1, 1, 1, 1, 1, 0, 1, 1, 1, 1 };
    int delays[10] = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };
    double timeouts[10] = { 10, 10, 10, 30, 30, 10, -1, 10, 6, 4 };
    int polls[10] = { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 };
    int repeat[10] = { 257, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    int createNewGroups[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 };
    unsigned int interruptDelays[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 2 };
    int r;
    const char* cmd[4];
#ifdef _WIN32
    char* argv0 = 0;
#endif
    char* test1IterationsStr = getenv(""KWSYS_TEST_PROCESS_1_COUNT"");
    if (test1IterationsStr) {
      long int test1Iterations = strtol(test1IterationsStr, 0, 10);
      if (test1Iterations > 10 && test1Iterations != LONG_MAX) {
        repeat[0] = (int)test1Iterations;
      }
    }
#ifdef _WIN32
    if (n == 0 && (argv0 = strdup(argv[0]))) {
      /* Try converting to forward slashes to see if it works.  */
      char* c;
      for (c = argv0; *c; ++c) {
        if (*c == '\\') {
          *c = '/';
        }
      }
      cmd[0] = argv0;
    } else {
      cmd[0] = argv[0];
    }
#else
    cmd[0] = argv[0];
#endif
",609,578,640,618,"fprintf(stderr, ""Invalid test number %d.\n"", n)","fprintf(stderr, ""Invalid test number %d.\n"", n)",0,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_369.cpp,"{
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_369.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 1"", "" 13"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 43"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 16"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 59"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 14"", "" 0"", "" 0"", "" 2"", "" 0"", "" 29"", "" 0""]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,248,248,"sprintf(temp, ""%d"", cmVersion::GetMajorVersion())","sprintf(temp, ""%d"", cmVersion::GetMajorVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_370.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_370.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,253,253,"sprintf(temp, ""%d"", cmVersion::GetPatchVersion())","sprintf(temp, ""%d"", cmVersion::GetPatchVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_371.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_371.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_300.cpp,"  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmStateEnums::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1103,1103,1103,1103,"sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));","sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_372.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_372.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0""]"
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,486,487,"fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str())","fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_373.cpp,"{
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_373.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,489,490,"fprintf(fout, ""add_executable(%s"", targetName.c_str())","fprintf(fout, ""add_executable(%s"", targetName.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_374.cpp,"{
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_374.cpp,"[""0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 1"", "" 0"", "" 0"", "" 0"", "" 0"", "" 11"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 2"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 3"", "" 0"", "" 8"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 0"", "" 4"", "" 0"", "" 0"", "" 2"", "" 0"", "" 6"", "" 0""]"
