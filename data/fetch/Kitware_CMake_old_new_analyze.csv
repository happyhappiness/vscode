sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_loc,new_loc,old_log,new_log,action_type,old_log_file,old_block,old_block_file,old_block_feature
47b3a57c9bc5c7db608bc3b59b139a902535255f,"Display subproject timing summary

Use the '--no-subproject-summary' option to disable timing summary.",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_0.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_1.cpp,"                 << static_cast<int>(percent  .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);
    if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
","                 << static_cast<int>(percent  .5f) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" << total
                 << std::endl);

    if (!this->CTest->GetLabelsForSubprojects().empty() &&
        this->CTest->GetSubprojectSummary()) {
      this->PrintSubprojectSummary();
    } else if (this->CTest->GetLabelSummary()) {
      this->PrintLabelSummary();
    }

    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestOptionalLog(this->CTest, HANDLER_OUTPUT,
",536,536,543,548,"sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start))","sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_0.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_0.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_1.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_1.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_2.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_2.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_3.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_3.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_4.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_4.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_5.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_5.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_6.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_6.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_7.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_7.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_10.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_8.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_8.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_9.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_9.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_10.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_10.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_11.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_11.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_12.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_12.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_13.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_13.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_14.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_14.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_15.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_15.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_16.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_16.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_22.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_17.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_17.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_18.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_18.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,478,477,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_19.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_19.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2110,2109,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_20.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_20.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2321,2322,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_21.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_21.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,300,301,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)","= aprintf(""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_22.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_22.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,313,315,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_23.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_23.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,248,249,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap)","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_24.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_24.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,251,253,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer)","strcpy(data->set.errorbuffer, error)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_25.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_25.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_34.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(READBUFFER_SIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
",644,658,649,663,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_26.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_26.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,396,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_27.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_27.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
d6051ca39e2ac8e5afc8f6308fd1bda7d1e8c17b,"execute_process: Add option to get results of every child

Add a `RESULTS_VARIABLE` option to get the results of all children
in a pipeline of one or more `COMMAND`s.",[],Source/cmExecuteProcessCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_38.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_38.cpp,"    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
","    switch (cmsysProcess_GetState(cp)) {
      case cmsysProcess_State_Exited: {
        int v = cmsysProcess_GetExitValue(cp);
        char buf[16];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      } break;
",287,297,291,301,"sprintf(buf, ""%d"", v)","sprintf(buf, ""%d"", v)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_28.cpp,"{
        int v = cmsysProcess_GetExitValue(cp);
        char buf[100];
        sprintf(buf, ""%d"", v);
        this->Makefile->AddDefinition(result_variable, buf);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_28.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig)","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_29.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_29.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code)","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_30.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_30.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2247,2277,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig)","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_31.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_31.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2124,2146,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code)","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_32.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_32.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_33.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_33.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_34.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_34.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_35.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_35.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_49.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3916,3912,3921,3917,"char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)","char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_36.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_36.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_37.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_37.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_33.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_51.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1092,1092,1099,1098,"*curl_mvaprintf(const char *format, va_list ap_save)","*curl_mvaprintf(const char *format, va_list ap_save)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_38.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_38.cpp,[]
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_34.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_52.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,646,655,"DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_39.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_39.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_55.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,2579,2639,"BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))","BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_40.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_40.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,479,478,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_41.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_41.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2110,2110,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_42.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_42.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2321,2321,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_43.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_43.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_60.cpp,"  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist->head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
","  case CURLWC_DOWNLOADING: {
    /* filelist has at least one file, lets get first one */
    struct ftp_conn *ftpc = &conn->proto.ftpc;
    struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;

    char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename);
    if(!tmp_path)
",3915,3911,3920,3916,"char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)","char *tmp_path = aprintf(""%s%s"", wildcard->path, finfo->filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_44.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_44.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,300,300,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_45.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_45.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_42.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_62.cpp,"    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  else
    return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
","    info.buffer[info.len] = 0; /* we terminate this with a zero byte */
    return info.buffer;
  }
  return strdup("""");
}

char *curl_mvaprintf(const char *format, va_list ap_save)
",1096,1096,1103,1102,"*curl_mvaprintf(const char *format, va_list ap_save)","*curl_mvaprintf(const char *format, va_list ap_save)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_46.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_46.cpp,[]
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/url.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_43.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_63.cpp,"
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
","
  /* We do some initial setup here, all those fields that can't be just 0 */

  data->state.buffer = malloc(BUFSIZE  1);
  if(!data->state.buffer) {
    DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }

  data->state.headerbuff = malloc(HEADERSIZE);
  if(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
",641,644,646,655,"DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))","DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_47.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_47.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_66.cpp,"        {
          const BIGNUM *n;
          const BIGNUM *e;
          const BIGNUM *d;
          const BIGNUM *p;
          const BIGNUM *q;
          const BIGNUM *dmp1;
          const BIGNUM *dmq1;
          const BIGNUM *iqmp;

          RSA_get0_key(rsa, &n, &e, &d);
          RSA_get0_factors(rsa, &p, &q);
          RSA_get0_crt_params(rsa, &dmp1, &dmq1, &iqmp);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
          print_pubkey_BN(rsa, d, i);
          print_pubkey_BN(rsa, p, i);
          print_pubkey_BN(rsa, q, i);
          print_pubkey_BN(rsa, dmp1, i);
          print_pubkey_BN(rsa, dmq1, i);
          print_pubkey_BN(rsa, iqmp, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
        print_pubkey_BN(rsa, d, i);
        print_pubkey_BN(rsa, p, i);
        print_pubkey_BN(rsa, q, i);
        print_pubkey_BN(rsa, dmp1, i);
        print_pubkey_BN(rsa, dmq1, i);
        print_pubkey_BN(rsa, iqmp, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
","        {
          const BIGNUM *n;
          const BIGNUM *e;

          RSA_get0_key(rsa, &n, &e, NULL);
          BN_print(mem, n);
          push_certinfo(""RSA Public Key"", i);
          print_pubkey_BN(rsa, n, i);
          print_pubkey_BN(rsa, e, i);
        }
#else
        BIO_printf(mem, ""%d"", BN_num_bits(rsa->n));
        push_certinfo(""RSA Public Key"", i);
        print_pubkey_BN(rsa, n, i);
        print_pubkey_BN(rsa, e, i);
#endif

        break;
      }
      case EVP_PKEY_DSA:
      {
#ifndef OPENSSL_NO_DSA
        DSA *dsa;
#ifdef HAVE_OPAQUE_EVP_PKEY
        dsa = EVP_PKEY_get0_DSA(pubkey);
",2554,2628,2579,2639,"BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))","BIO_printf(mem, ""%d"", BN_num_bits(rsa->n))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_48.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_48.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
48fa291469e5e8b3ae88fb846750df72468eb58a,"bindexplib: add ARM support

Fixes: #16728",[u'https://gitlab.kitware.com/cmake/cmake/issues/16728'],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_47.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_67.cpp,"    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a i386 COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
","    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }
  /* Does it look like a COFF OBJ file??? */
  else if (((dosHeader->e_magic == IMAGE_FILE_MACHINE_I386) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_AMD64) ||
            (dosHeader->e_magic == IMAGE_FILE_MACHINE_ARMNT)) &&
           (dosHeader->e_sp == 0)) {
    /*
    * The two tests above aren't what they look like.  They're
",323,326,323,326,"fprintf(stderr, ""File is an executable.  I don't dump those.\n"");","fprintf(stderr, ""File is an executable.  I don't dump those.\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_49.cpp,"{
    fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
    return false;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_49.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_70.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
static int warning_done = 0;
#endif
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->restore_time = 1;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
if (warning_done)
/* Warning was already emitted; suppress further warnings. */
return (ARCHIVE_OK);

archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
warning_done = 1;
return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
/* Display warning and unset flag */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
return (ARCHIVE_WARN);
#endif
}
",563,562,582,575,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_50.cpp,"{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_50.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 1, 36, 0, 0, 2, 2, 0, 0, 2, 5, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 1, 0, 2, 0, 0, 5, 0, 7, 5, 0, 0, 0, 0, 0]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_71.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
",1340,1329,1348,1338,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_51.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_51.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
62d0e22325d36e5f9d61ccfbef0d68cfe1935f1b,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-25 (d6b1bb9f)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_50.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_72.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
",1219,1207,1226,1216,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_52.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_52.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_73.cpp,"int
archive_read_disk_set_atime_restored(struct archive *_a)
{
#ifndef HAVE_UTIMES
static int warning_done = 0;
#endif
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->restore_time = 1;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
if (warning_done)
/* Warning was already emitted; suppress further warnings. */
return (ARCHIVE_OK);

archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
warning_done = 1;
return (ARCHIVE_WARN);
#endif
}
","int
archive_read_disk_set_atime_restored(struct archive *_a)
{
struct archive_read_disk *a = (struct archive_read_disk *)_a;
archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
a->flags |= ARCHIVE_READDISK_RESTORE_ATIME;
if (a->tree != NULL)
a->tree->flags |= needsRestoreTimes;
return (ARCHIVE_OK);
#else
/* Display warning and unset flag */
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Cannot restore access time on this system"");
a->flags &= ~ARCHIVE_READDISK_RESTORE_ATIME;
return (ARCHIVE_WARN);
#endif
}
",563,562,582,575,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_53.cpp,"{
#ifndef HAVE_UTIMES
	static int warning_done = 0;
#endif
	struct archive_read_disk *a = (struct archive_read_disk *)_a;
	archive_check_magic(_a, ARCHIVE_READ_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_read_disk_restore_atime"");
#ifdef HAVE_UTIMES
	a->restore_time = 1;
	if (a->tree != NULL)
		a->tree->flags |= needsRestoreTimes;
	return (ARCHIVE_OK);
#else
	if (warning_done)
		/* Warning was already emitted; suppress further warnings. */
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Cannot restore access time on this system"");
	warning_done = 1;
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_53.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 1, 36, 0, 0, 2, 2, 0, 0, 2, 5, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 1, 0, 2, 0, 0, 5, 0, 7, 5, 0, 0, 0, 0, 0]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_74.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate tar data"");
",1340,1329,1348,1338,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_54.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate tar data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_54.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
059aa805c9c0cb34c92eb69abf66febc40ab62db,"LibArchive 2017-02-25 (d6b1bb9f)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit d6b1bb9f7ea7bc153b7356e8e345c9e48005821a (v3.3.1).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_52.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_75.cpp,"struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname, a->restore_time);
else
a->tree = tree_open(pathname, a->symlink_mode, a->restore_time);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
","struct archive_read_disk *a = (struct archive_read_disk *)_a;

if (a->tree != NULL)
a->tree = tree_reopen(a->tree, pathname,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
else
a->tree = tree_open(pathname, a->symlink_mode,
    a->flags & ARCHIVE_READDISK_RESTORE_ATIME);
if (a->tree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate directory traversal data"");
",1219,1207,1226,1216,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_55.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_55.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,306,330,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_56.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_56.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_76.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"")","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_57.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_57.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_77.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_58.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_58.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_78.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_59.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_59.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_80.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_60.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_60.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_81.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_61.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_61.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_82.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_62.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_62.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_84.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_63.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_63.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_85.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_64.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_64.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_86.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_65.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_65.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_87.cpp,"#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
return (ARCHIVE_FATAL);
#endif
}
if (fstat(fd, &st) != 0) {
","#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
goto fail;
#endif
}
if (fstat(fd, &st) != 0) {
",277,277,278,278,"archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")","archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_66.cpp,"{
#if defined(_WIN32) && !defined(__CYGWIN__)
		wfilename = mine->filename.w;
		fd = _wopen(wfilename, O_RDONLY | O_BINARY);
		if (fd < 0 && errno == ENOENT) {
			wchar_t *fullpath;
			fullpath = __la_win_permissive_name_w(wfilename);
			if (fullpath != NULL) {
				fd = _wopen(fullpath, O_RDONLY | O_BINARY);
				free(fullpath);
			}
		}
		if (fd < 0) {
			archive_set_error(a, errno,
			    ""Failed to open '%S'"", wfilename);
			return (ARCHIVE_FATAL);
		}
#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_66.cpp,"[4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 41, 0, 0, 1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 8, 0, 0, 7, 0, 15, 3, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_88.cpp,"else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
return (ARCHIVE_FATAL);
}

/*
","else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
goto fail;
}

/*
",287,287,288,288,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)","archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_67.cpp,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_67.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_56.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_89.cpp,"mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (mine == NULL || buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
free(mine);
free(buffer);
return (ARCHIVE_FATAL);
}
mine->buffer = buffer;
mine->fd = fd;
","mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
goto fail;
}
mine->buffer = buffer;
mine->fd = fd;
",356,356,360,360,"archive_set_error(a, ENOMEM, ""No memory"")","archive_set_error(a, ENOMEM, ""No memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_68.cpp,"{
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_68.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_92.cpp,"bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
","bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
",178,163,184,167,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_69.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->name = ""lzma"";
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_69.cpp,"[2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 52, 0, 0, 2, 2, 0, 0, 1, 3, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 8, 0, 9, 4, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_70.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_70.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_71.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_71.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_72.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_72.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_73.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_73.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_74.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_74.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_75.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_75.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_76.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_76.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_77.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_77.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_94.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)malloc(sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
memset(ar, 0, sizeof(*ar));
ar->strtab = NULL;

r = __archive_read_register_format(a,
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)calloc(1, sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
ar->strtab = NULL;

r = __archive_read_register_format(a,
",104,104,109,109,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_78.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_78.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_95.cpp,"archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
","archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
",260,259,264,263,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_79.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_79.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_98.cpp,"if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
return (NULL);
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
","if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
goto fail;
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
",1864,1864,1865,1865,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")","archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_80.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_80.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_99.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_99.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
/*
 * Sanity check: file does not have ""CL"" extension.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
/*
 * Sanity check: file does not have ""CL"" extension.
",1990,1988,1990,1988,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_81.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_81.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_100.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_100.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a directory.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a directory.
",1999,1997,1999,1997,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_82.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_82.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_101.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_101.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
",2008,2006,2008,2006,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_83.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_83.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_102.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a regular file.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a regular file.
",2022,2020,2022,2020,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_84.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_84.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_103.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
parent->subdirsï¿½;
/* Overwrite an offset and a number of this ""CL"" entry
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
parent->subdirsï¿½;
/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,2031,2029,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_85.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_85.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,2049,2047,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_86.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_86.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_62.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_104.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,2057,2055,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_87.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_87.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_63.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_105.cpp,"/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
","/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (lha->compsize < 0)
goto invalid;/* Invalid compressed file size */

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
",924,924,928,931,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_88.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_88.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_106.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_106.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)malloc(sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
memset(mtree, 0, sizeof(*mtree));
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)calloc(1, sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,228,234,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_89.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_89.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_64.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_107.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_107.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry, *ht_iter;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;
unsigned int ht_idx;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,863,878,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_90.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_90.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_108.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_108.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

/*
 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

/*
 * Until enough data has been read, we cannot tell about
",647,647,653,653,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_91.cpp,"{
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_91.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_110.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"")",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_92.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_92.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_112.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_93.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_93.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_94.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_94.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_95.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_95.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_96.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_96.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_97.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_97.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_114.cpp,"{
struct sparse_block *p;

p = (struct sparse_block *)malloc(sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
memset(p, 0, sizeof(*p));
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
","{
struct sparse_block *p;

p = (struct sparse_block *)calloc(1, sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
",2116,2227,2121,2232,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_98.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_98.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_115.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = malloc(sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}
memset(w, 0, sizeof(*w));

r = __archive_read_register_format(
a, w, ""warc"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = calloc(1, sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}

r = __archive_read_register_format(
a, w, ""warc"",
",146,146,150,150,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_99.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_99.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"")","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_100.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_100.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_116.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,270,276,"archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")","archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_101.cpp,"{
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_101.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_117.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000)","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_102.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_102.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_103.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_103.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_104.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_104.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_105.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_105.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_106.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_106.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_128.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_128.cpp,"
if (en) {
/* Everything failed; give up here. */
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

","
if (en) {
/* Everything failed; give up here. */
if ((&a->archive)->error == NULL)
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

",1993,2043,1996,2047,"archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name)","archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_107.cpp,"{
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_107.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_108.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_108.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_109.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_109.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_110.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_110.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_111.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_111.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_112.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_112.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_113.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_113.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_131.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"")","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_114.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_114.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_71.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_136.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_136.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)malloc(sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
memset(cpio, 0, sizeof(*cpio));
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
","if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)calloc(1, sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
",116,116,121,121,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_115.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_115.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_137.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_137.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)malloc(sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
memset(pax, 0, sizeof(*pax));
a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
","if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)calloc(1, sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
",127,137,132,142,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_116.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_116.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_138.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_138.cpp,"return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)malloc(sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
memset(ustar, 0, sizeof(*ustar));
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
","return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)calloc(1, sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
",184,184,189,189,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_117.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_117.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_139.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_139.cpp,"return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
memset(v7tar, 0, sizeof(*v7tar));
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
","return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
",161,161,166,166,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_118.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_118.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,306,330,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_119.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_119.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_140.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,313,325,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"")","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_120.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_120.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_141.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,786,1497,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_121.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_121.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_142.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,946,1656,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path)","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_122.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_122.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_144.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,940,940,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_123.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_123.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_145.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1043,1043,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_124.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_124.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_146.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1069,1069,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_125.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_125.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_148.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,805,804,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_126.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_126.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_149.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,877,876,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_127.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_127.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_150.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,903,902,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching))","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching))",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_128.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_128.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_151.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_151.cpp,"#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
return (ARCHIVE_FATAL);
#endif
}
if (fstat(fd, &st) != 0) {
","#else
archive_set_error(a, ARCHIVE_ERRNO_MISC,
    ""Unexpedted operation in archive_read_open_filename"");
goto fail;
#endif
}
if (fstat(fd, &st) != 0) {
",277,277,278,278,"archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")","archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_129.cpp,"{
#if defined(_WIN32) && !defined(__CYGWIN__)
		wfilename = mine->filename.w;
		fd = _wopen(wfilename, O_RDONLY | O_BINARY);
		if (fd < 0 && errno == ENOENT) {
			wchar_t *fullpath;
			fullpath = __la_win_permissive_name_w(wfilename);
			if (fullpath != NULL) {
				fd = _wopen(fullpath, O_RDONLY | O_BINARY);
				free(fullpath);
			}
		}
		if (fd < 0) {
			archive_set_error(a, errno,
			    ""Failed to open '%S'"", wfilename);
			return (ARCHIVE_FATAL);
		}
#else
		archive_set_error(a, ARCHIVE_ERRNO_MISC,
		    ""Unexpedted operation in archive_read_open_filename"");
		return (ARCHIVE_FATAL);
#endif
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_129.cpp,"[4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 41, 0, 0, 1, 1, 0, 0, 0, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 8, 0, 0, 7, 0, 15, 3, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_152.cpp,"else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
return (ARCHIVE_FATAL);
}

/*
","else
archive_set_error(a, errno, ""Can't stat '%s'"",
    filename);
goto fail;
}

/*
",287,287,288,288,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)","archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_130.cpp,"archive_set_error(a, errno, ""Can't stat '%s'"",
			    filename)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_130.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_78.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_153.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_153.cpp,"mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (mine == NULL || buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
free(mine);
free(buffer);
return (ARCHIVE_FATAL);
}
mine->buffer = buffer;
mine->fd = fd;
","mine->block_size = new_block_size;
}
buffer = malloc(mine->block_size);
if (buffer == NULL) {
archive_set_error(a, ENOMEM, ""No memory"");
goto fail;
}
mine->buffer = buffer;
mine->fd = fd;
",356,356,360,360,"archive_set_error(a, ENOMEM, ""No memory"")","archive_set_error(a, ENOMEM, ""No memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_131.cpp,"{
		archive_set_error(a, ENOMEM, ""No memory"");
		free(mine);
		free(buffer);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_131.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_156.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_156.cpp,"bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
","bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
return (ARCHIVE_OK);
#else
archive_set_error(_a, ARCHIVE_ERRNO_MISC,
    ""Using external lzma program for lzma decompression"");
",178,163,184,167,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_132.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->name = ""lzma"";
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_132.cpp,"[2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 52, 0, 0, 2, 2, 0, 0, 1, 3, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 8, 0, 9, 4, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,790,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_133.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_133.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,821,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_134.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_134.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,827,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_135.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_135.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,833,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_136.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_136.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,866,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_137.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_137.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,884,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_138.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_138.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,890,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_139.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_139.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,921,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_140.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_140.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_158.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)malloc(sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
memset(ar, 0, sizeof(*ar));
ar->strtab = NULL;

r = __archive_read_register_format(a,
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_ar"");

ar = (struct ar *)calloc(1, sizeof(*ar));
if (ar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ar data"");
return (ARCHIVE_FATAL);
}
ar->strtab = NULL;

r = __archive_read_register_format(a,
",104,104,109,109,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_141.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_141.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_159.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_159.cpp,"archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
","archive_entry_set_filetype(entry, AE_IFREG);
/* Get the size of the filename table. */
number = ar_atol10(h  AR_size_offset, AR_size_size);
if (number > SIZE_MAX || number > 1024 * 1024 * 1024) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Filename table too large"");
return (ARCHIVE_FATAL);
",260,259,264,263,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_142.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Filename table too large"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_142.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_162.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_162.cpp,"if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
return (NULL);
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
","if ((file->utf16be_name = malloc(name_len)) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for file name"");
goto fail;
}
memcpy(file->utf16be_name, p, name_len);
file->utf16be_bytes = name_len;
",1864,1864,1865,1865,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")","archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_143.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for file name"");
			return (NULL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_143.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_163.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_163.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
/*
 * Sanity check: file does not have ""CL"" extension.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
/*
 * Sanity check: file does not have ""CL"" extension.
",1990,1988,1990,1988,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_144.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_144.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_164.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a directory.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE and CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a directory.
",1999,1997,1999,1997,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_145.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE and CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_145.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_165.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_165.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
return (NULL);
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge RE"");
goto fail;
}
} else if (parent != NULL && parent->rr_moved)
file->rr_moved_has_re_only = 0;
",2008,2006,2008,2006,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_146.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge RE"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_146.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_166.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_166.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
/*
 * Sanity check: The file type must be a regular file.
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
/*
 * Sanity check: The file type must be a regular file.
",2022,2020,2022,2020,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_147.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_147.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_167.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
parent->subdirsï¿½;
/* Overwrite an offset and a number of this ""CL"" entry
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
parent->subdirsï¿½;
/* Overwrite an offset and a number of this ""CL"" entry
",2031,2029,2031,2029,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_148.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_148.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,2049,2047,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_149.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Invalid Rockridge CL"");
					return (NULL);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_149.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_84.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_168.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_168.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
return (NULL);
}
}
}
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
if (file->cl_offset == file->offset ||
    parent->rr_moved) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Invalid Rockridge CL"");
goto fail;
}
}
}
",2049,2047,2057,2055,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_150.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Invalid Rockridge CL"");
				return (NULL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_150.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_85.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_169.cpp,"/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
","/* Get a real compressed file size. */
lha->compsize -= extdsize - 2;

if (lha->compsize < 0)
goto invalid;/* Invalid compressed file size */

if (sum_calculated != headersum) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""LHa header sum error"");
",924,924,928,931,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_151.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LHa header sum error"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_151.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_170.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)malloc(sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
memset(mtree, 0, sizeof(*mtree));
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_mtree"");

mtree = (struct mtree *)calloc(1, sizeof(*mtree));
if (mtree == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate mtree data"");
return (ARCHIVE_FATAL);
}
mtree->fd = -1;

r = __archive_read_register_format(a, mtree, ""mtree"",
",223,229,228,234,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_152.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate mtree data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_152.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_86.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_171.cpp,"    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","    struct mtree_option **global, const char *line, ssize_t line_len,
    struct mtree_entry **last_entry, int is_form_d)
{
struct mtree_entry *entry, *ht_iter;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;
unsigned int ht_idx;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",853,867,863,878,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_153.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_153.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_172.cpp,"  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)malloc(sizeof(*rar));
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }
  memset(rar, 0, sizeof(*rar));

/*
 * Until enough data has been read, we cannot tell about
","  archive_check_magic(_a, ARCHIVE_READ_MAGIC, ARCHIVE_STATE_NEW,
                      ""archive_read_support_format_rar"");

  rar = (struct rar *)calloc(sizeof(*rar), 1);
  if (rar == NULL)
  {
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }

/*
 * Until enough data has been read, we cannot tell about
",647,647,653,653,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_154.cpp,"{
    archive_set_error(&a->archive, ENOMEM, ""Can't allocate rar data"");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_154.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_174.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,940,992,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"")",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_155.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_155.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_176.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1130,1185,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_156.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_156.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1820,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_157.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_157.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1825,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_158.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_158.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1844,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_159.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_159.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1849,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_160.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_160.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_178.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_178.cpp,"{
struct sparse_block *p;

p = (struct sparse_block *)malloc(sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
memset(p, 0, sizeof(*p));
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
","{
struct sparse_block *p;

p = (struct sparse_block *)calloc(1, sizeof(*p));
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
return (ARCHIVE_FATAL);
}
if (tar->sparse_last != NULL)
tar->sparse_last->next = p;
else
",2116,2227,2121,2232,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_161.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_161.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_179.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = malloc(sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}
memset(w, 0, sizeof(*w));

r = __archive_read_register_format(
a, w, ""warc"",
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_warc"");

if ((w = calloc(1, sizeof(*w))) == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate warc data"");
return (ARCHIVE_FATAL);
}

r = __archive_read_register_format(
a, w, ""warc"",
",146,146,150,150,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_162.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate warc data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_162.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,263,261,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"")","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_163.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_163.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_180.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,270,276,"archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")","archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_164.cpp,"{
		/* nightmare!  the specs say content-length is mandatory
		 * so I don't feel overly bad stopping the reader here */
		archive_set_error(
			&a->archive, EINVAL,
			""Bad content length"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_164.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_181.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,287,295,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000)","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_165.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_165.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1537,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_166.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_166.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1544,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_167.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_167.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1701,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_168.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_168.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1711,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_169.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_169.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_192.cpp,"
if (en) {
/* Everything failed; give up here. */
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

","
if (en) {
/* Everything failed; give up here. */
if ((&a->archive)->error == NULL)
archive_set_error(&a->archive, en, ""Can't create '%s'"",
    a->name);
return (ARCHIVE_FAILED);
}

",1993,2043,1996,2047,"archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name)","archive_set_error(&a->archive, en, ""Can't create '%s'"",
			    a->name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_170.cpp,"{
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_170.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2414,2599,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_171.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_171.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2428,2629,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_172.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_172.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2438,2660,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name)","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_173.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_173.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2446,2673,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name)","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_174.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_174.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2544,2818,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_175.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_175.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_194.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_194.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2555,2829,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"")","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_176.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_176.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_195.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,2584,2859,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"")","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_177.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_177.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_cpio_newc.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_93.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_200.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)malloc(sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
memset(cpio, 0, sizeof(*cpio));
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
","if (a->format_free != NULL)
(a->format_free)(a);

cpio = (struct cpio *)calloc(1, sizeof(*cpio));
if (cpio == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
return (ARCHIVE_FATAL);
}
a->format_data = cpio;
a->format_name = ""cpio"";
a->format_options = archive_write_newc_options;
",116,116,121,121,"archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")","archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_178.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Can't allocate cpio data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_178.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_201.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_201.cpp,"if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)malloc(sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
memset(pax, 0, sizeof(*pax));
a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
","if (a->format_free != NULL)
(a->format_free)(a);

pax = (struct pax *)calloc(1, sizeof(*pax));
if (pax == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate pax data"");
return (ARCHIVE_FATAL);
}
pax->flags = WRITE_LIBARCHIVE_XATTR | WRITE_SCHILY_XATTR;

a->format_data = pax;
a->format_name = ""pax"";
a->format_options = archive_write_pax_options;
",127,137,132,142,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_179.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate pax data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_179.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_ustar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_202.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_202.cpp,"return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)malloc(sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
memset(ustar, 0, sizeof(*ustar));
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
","return (ARCHIVE_FATAL);
}

ustar = (struct ustar *)calloc(1, sizeof(*ustar));
if (ustar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate ustar data"");
return (ARCHIVE_FATAL);
}
a->format_data = ustar;
a->format_name = ""ustar"";
a->format_options = archive_write_ustar_options;
",184,184,189,189,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_180.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate ustar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_180.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_set_format_v7tar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_203.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_203.cpp,"return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)malloc(sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
memset(v7tar, 0, sizeof(*v7tar));
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
","return (ARCHIVE_FATAL);
}

v7tar = (struct v7tar *)calloc(1, sizeof(*v7tar));
if (v7tar == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate v7tar data"");
return (ARCHIVE_FATAL);
}
a->format_data = v7tar;
a->format_name = ""tar (non-POSIX)"";
a->format_options = archive_write_v7tar_options;
",161,161,166,166,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_181.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate v7tar data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_181.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",913,913,917,919,"len = curl_msnprintf(fptr, left, ""%ld"", width)","len = curl_msnprintf(fptr, left, ""%ld"", width)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_182.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_182.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_204.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_204.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",913,913,923,936,"len = curl_msnprintf(fptr, left, "".%ld"", prec)","len = curl_msnprintf(fptr, left, "".%ld"", prec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_183.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_183.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_205.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_205.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name)","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_184.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_184.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_102.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_210.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_210.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,2202,2259,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_185.cpp,"{
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_185.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_103.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_211.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_211.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n  1);
  if(buf)
    for(n = 0; beg < end; n = 3)
      snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) begï¿½);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n  1);
    if(buf)
      for(n = 0; beg < end; n = 3)
        snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) begï¿½);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,209,213,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)","snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_186.cpp,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_186.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",917,917,921,923,"len = curl_msnprintf(fptr, left, ""%ld"", width)","len = curl_msnprintf(fptr, left, ""%ld"", width)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_187.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr += len;
          left -= len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_187.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_212.cpp,"        *fptr = 0;

        if(width >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
","        *fptr = 0;

        if(width >= 0) {
          if(width >= (long)sizeof(work))
            width = sizeof(work)-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, ""%ld"", width);
          fptr = len;
          left -= len;
        }
        if(prec >= 0) {
          /* for each digit in the integer part, we can have one less
             precision */
          size_t maxprec = sizeof(work) - 2;
          double val = p->data.dnum;
          while(val >= 10.0) {
            val /= 10;
            maxprec--;
          }

          if(prec > (long)maxprec)
            prec = (long)maxprec-1;
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr = len;
",917,917,927,940,"len = curl_msnprintf(fptr, left, "".%ld"", prec)","len = curl_msnprintf(fptr, left, "".%ld"", prec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_188.cpp,"{
          /* RECURSIVE USAGE */
          len = curl_msnprintf(fptr, left, "".%ld"", prec);
          fptr += len;
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_188.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_105.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_213.cpp,"
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.value = malloc(strlen(serviceptr));
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr);
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) ëîºï¿½(conn->proxy.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
","
  /* prepare service name */
  if(strchr(serviceptr, '/')) {
    service.length = serviceptr_length;
    service.value = malloc(service.length);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    memcpy(service.value, serviceptr, service.length);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       (gss_OID) GSS_C_NULL_OID, &server);
  }
  else {
    service.value = malloc(serviceptr_length 
                           strlen(conn->socks_proxy.host.name)ï¿½);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = serviceptr_length  strlen(conn->socks_proxy.host.name)ï¿½;
    snprintf(service.value, service.lengthï¿½, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
",134,135,151,153,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name)","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_189.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_189.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_109.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_218.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          *certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2198,2255,2202,2259,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_190.cpp,"{
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_190.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/x509asn1.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_110.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_219.cpp,"  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char * octet2str(const char * beg, const char * end)
{
  size_t n = end - beg;
  char * buf;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  buf = malloc(3 * n  1);
  if(buf)
    for(n = 0; beg < end; n = 3)
      snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) begï¿½);
  return buf;
}

static const char * bit2str(const char * beg, const char * end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
","  return strdup(*beg? ""TRUE"": ""FALSE"");
}

static const char *octet2str(const char *beg, const char *end)
{
  size_t n = end - beg;
  char *buf = NULL;

  /* Convert an ASN.1 octet string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */

  if(n <= (CURL_SIZE_T_MAX - 1) / 3) {
    buf = malloc(3 * n  1);
    if(buf)
      for(n = 0; beg < end; n = 3)
        snprintf(buf  n, 4, ""%02x:"", *(const unsigned char *) begï¿½);
  }
  return buf;
}

static const char *bit2str(const char *beg, const char *end)
{
  /* Convert an ASN.1 bit string to a printable string.
     Return the dynamically allocated string, or NULL if an error occurs. */
",195,198,209,213,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)","snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_191.cpp,"snprintf(buf + n, 4, ""%02x:"", *(const unsigned char *) beg++)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_191.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                        ï¬¬ï¿½_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmCommandArgument_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmCommandArgument_yy_load_buffer_state(yyscanner );
}

{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 41 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmCommandArgument_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmCommandArgument_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmCommandArgument_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 29);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1050,1054,"YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_192.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_192.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                        ï¬¬ï¿½_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmCommandArgument_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmCommandArgument_yy_load_buffer_state(yyscanner );
}

{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 41 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmCommandArgument_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmCommandArgument_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmCommandArgument_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 29);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1073,1077,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_193.cpp,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_193.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                        ï¬¬ï¿½_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmCommandArgument_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmCommandArgument_yy_load_buffer_state(yyscanner );
}

{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 41 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmCommandArgument_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmCommandArgument_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmCommandArgument_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 29);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1141,1145,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_194.cpp,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_194.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_221.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 64 ""cmCommandArgumentLexer.in.l""


#line 732 ""cmCommandArgumentLexer.cxx""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmCommandArgument_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmCommandArgument_yy_load_buffer_state(yyscanner );
                }

        for(;;)             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 30 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                        ï¬¬ï¿½_cp;
                        }
                while ( yy_base[yy_current_state] != 41 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 66 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
case 2:
YY_RULE_SETUP
#line 72 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
case 3:
YY_RULE_SETUP
#line 78 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
case 4:
YY_RULE_SETUP
#line 84 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
case 5:
YY_RULE_SETUP
#line 91 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
case 6:
YY_RULE_SETUP
#line 98 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
case 7:
YY_RULE_SETUP
#line 105 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
case 8:
YY_RULE_SETUP
#line 111 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 119 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
case 10:
YY_RULE_SETUP
#line 125 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
case 11:
YY_RULE_SETUP
#line 131 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
case 12:
YY_RULE_SETUP
#line 137 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
case 13:
YY_RULE_SETUP
#line 143 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
case 14:
YY_RULE_SETUP
#line 149 ""cmCommandArgumentLexer.in.l""
ECHO;
        YY_BREAK
#line 943 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
        yyterminate();

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmCommandArgument_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmCommandArgument_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmCommandArgument_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 30 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 30 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 29);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmCommandArgument_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmCommandArgument_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmCommandArgument_yy_load_buffer_state(yyscanner );
}

{
#line 42 ""cmCommandArgumentLexer.in.l""


#line 740 ""cmCommandArgumentLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 41 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 44 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ENVCURLY;
}
YY_BREAK
case 2:
YY_RULE_SETUP
#line 50 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_NCURLY;
}
YY_BREAK
case 3:
YY_RULE_SETUP
#line 56 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytextï¿½, strlen(yytext)-2);
  return cal_ATNAME;
}
YY_BREAK
case 4:
YY_RULE_SETUP
#line 62 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DCURLYVariable;
  return cal_DCURLY;
}
YY_BREAK
case 5:
YY_RULE_SETUP
#line 69 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->RCURLYVariable;
  return cal_RCURLY;
}
YY_BREAK
case 6:
YY_RULE_SETUP
#line 76 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->ATVariable;
  return cal_AT;
}
YY_BREAK
case 7:
YY_RULE_SETUP
#line 83 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_NAME;
}
YY_BREAK
case 8:
YY_RULE_SETUP
#line 89 ""cmCommandArgumentLexer.in.l""
{
  if ( !yyextra->HandleEscapeSymbol(yylvalp, *(yytextï¿½)) )
    {
    return cal_ERROR;
    }
  return cal_SYMBOL;
}
YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 97 ""cmCommandArgumentLexer.in.l""
{
  //std::cerr << __LINE__ << "" here: ["" << yytext << ""]"" << std::endl;
  yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  return cal_SYMBOL;
}
YY_BREAK
case 10:
YY_RULE_SETUP
#line 103 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->DOLLARVariable;
  return cal_DOLLAR;
}
YY_BREAK
case 11:
YY_RULE_SETUP
#line 109 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->LCURLYVariable;
  return cal_LCURLY;
}
YY_BREAK
case 12:
YY_RULE_SETUP
#line 115 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_BSLASH;
}
YY_BREAK
case 13:
YY_RULE_SETUP
#line 121 ""cmCommandArgumentLexer.in.l""
{
  //yyextra->AllocateParserType(yylvalp, yytext, strlen(yytext));
  yylvalp->str = yyextra->BSLASHVariable;
  return cal_SYMBOL;
}
YY_BREAK
case 14:
YY_RULE_SETUP
#line 127 ""cmCommandArgumentLexer.in.l""
ECHO;
YY_BREAK
#line 925 ""cmCommandArgumentLexer.cxx""
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(ESCAPES):
case YY_STATE_EOF(NOESCAPES):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmCommandArgument_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmCommandArgument_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmCommandArgument_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmCommandArgument_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmCommandArgument_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmCommandArgument_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 30 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 29);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",702,692,1185,1189,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_195.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_195.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1400,1409,1407,1416,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_196.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_196.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_222.cpp," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmCommandArgument_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmCommandArgument_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmCommandArgument_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1400,1409,1416,1425,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_197.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_197.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmCommandArgument_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,1579,1584,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_198.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_198.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_223.cpp,"void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmCommandArgument_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmCommandArgument_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmCommandArgument_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmCommandArgument_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmCommandArgument_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmCommandArgument_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1543,1548,1599,1604,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_199.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_199.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_224.cpp," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
"," */
YY_BUFFER_STATE cmCommandArgument_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmCommandArgument_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmCommandArgument_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmCommandArgument_yylex() will
",1612,1617,1625,1630,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_200.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_200.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1674,1679,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_201.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_201.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1683,1688,"YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_202.cpp,"YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_202.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_225.cpp,"YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmCommandArgument_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a yybytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","YY_BUFFER_STATE cmCommandArgument_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmCommandArgument_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmCommandArgument_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmCommandArgument_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmCommandArgument_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmCommandArgument_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmCommandArgument_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmCommandArgument_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1650,1655,1699,1706,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_203.cpp,"{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_203.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1814,1821,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_204.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_204.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_226.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmCommandArgument_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmCommandArgument_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmCommandArgument_yy_switch_to_buffer
 */
void cmCommandArgument_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmCommandArgument_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmCommandArgument_yyget_debug  (yyscan_t yyscanner)
",1802,1809,1829,1836,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_205.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_205.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
      ï¬¬ï¿½_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ï¬¬ï¿½>yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr  yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ï¿½ )
    *(destï¿½) = *(sourceï¿½);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size = b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars = number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmExpr_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmExpr_yy_load_buffer_state(yyscanner );
}

{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 21 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmExpr_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmExpr_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmExpr_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 22);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,968,991,"YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_206.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_206.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
      ï¬¬ï¿½_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ï¬¬ï¿½>yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr  yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ï¿½ )
    *(destï¿½) = *(sourceï¿½);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size = b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars = number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmExpr_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmExpr_yy_load_buffer_state(yyscanner );
}

{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 21 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmExpr_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmExpr_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmExpr_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 22);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,991,1014,"YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_207.cpp,"YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_207.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_228.cpp,"
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 86 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""


#line 736 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""

  if ( yyg->yy_init )
    {
    yyg->yy_init = 0;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if ( ! yyg->yy_start )
      yyg->yy_start = 1;  /* first start state */

    if ( ! yyin )
      yyin = stdin;

    if ( ! yyout )
      yyout = stdout;

    if ( ! YY_CURRENT_BUFFER ) {
      cmExpr_yyensure_buffer_stack (yyscanner);
      YY_CURRENT_BUFFER_LVALUE =
        cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
    }

    cmExpr_yy_load_buffer_state(yyscanner );
    }

  for(;;)    /* loops until end-of-file is reached */
    {
    yy_cp = yyg->yy_c_buf_p;

    /* Support of yytext. */
    *yy_cp = yyg->yy_hold_char;

    /* yy_bp points to the position in yy_ch_buf of the start of
     * the current run.
     */
    yy_bp = yy_cp;

    yy_current_state = yyg->yy_start;
yy_match:
    do
      {
      YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
      if ( yy_accept[yy_current_state] )
        {
        yyg->yy_last_accepting_state = yy_current_state;
        yyg->yy_last_accepting_cpos = yy_cp;
        }
      while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
        {
        yy_current_state = (int) yy_def[yy_current_state];
        if ( yy_current_state >= 23 )
          yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
      ï¬¬ï¿½_cp;
      }
    while ( yy_base[yy_current_state] != 21 );

yy_find_action:
    yy_act = yy_accept[yy_current_state];
    if ( yy_act == 0 )
      { /* have to back up */
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      yy_act = yy_accept[yy_current_state];
      }

    YY_DO_BEFORE_ACTION;

do_action:  /* This label is used only to access EOF actions. */

    switch ( yy_act )
  { /* beginning of action switch */
      case 0: /* must back up */
      /* undo the effects of YY_DO_BEFORE_ACTION */
      *yy_cp = yyg->yy_hold_char;
      yy_cp = yyg->yy_last_accepting_cpos;
      yy_current_state = yyg->yy_last_accepting_state;
      goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 88 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
case 2:
YY_RULE_SETUP
#line 90 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_PLUS; }
case 3:
YY_RULE_SETUP
#line 91 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MINUS; }
case 4:
YY_RULE_SETUP
#line 92 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_TIMES; }
case 5:
YY_RULE_SETUP
#line 93 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_DIVIDE; }
case 6:
YY_RULE_SETUP
#line 94 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_MOD; }
case 7:
YY_RULE_SETUP
#line 95 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OR; }
case 8:
YY_RULE_SETUP
#line 96 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_AND; }
case 9:
YY_RULE_SETUP
#line 97 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_XOR; }
case 10:
YY_RULE_SETUP
#line 98 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_NOT; }
case 11:
YY_RULE_SETUP
#line 99 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
case 12:
YY_RULE_SETUP
#line 100 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
case 13:
YY_RULE_SETUP
#line 101 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_OPENPARENT; }
case 14:
YY_RULE_SETUP
#line 102 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
case 15:
YY_RULE_SETUP
#line 104 ""/home/andy/vtk/CMake/Source/cmExprLexer.in.l""
ECHO;
  YY_BREAK
#line 894 ""/home/andy/vtk/CMake-bin/Source/cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
  yyterminate();

  case YY_END_OF_BUFFER:
    {
    /* Amount of text matched not including the EOB char. */
    int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

    /* Undo the effects of YY_DO_BEFORE_ACTION. */
    *yy_cp = yyg->yy_hold_char;
    YY_RESTORE_YY_MORE_OFFSET

    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
      {
      /* We're scanning a new file or input source.  It's
       * possible that this happened because the user
       * just pointed yyin at a new source and called
       * cmExpr_yylex().  If so, then we have to assure
       * consistency between YY_CURRENT_BUFFER and our
       * globals.  Here is the right place to do so, because
       * this is the first action (other than possibly a
       * back-up) that will match for the new input source.
       */
      yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
      YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
      }

    /* Note that here we test for yy_c_buf_p ""<="" to the position
     * of the first EOB in the buffer, since yy_c_buf_p will
     * already have been incremented past the NUL character
     * (since all states make transitions on EOB to the
     * end-of-buffer state).  Contrast this with the test
     * in input().
     */
    if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
      { /* This was really a NUL. */
      yy_state_type yy_next_state;

      yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

      yy_current_state = yy_get_previous_state( yyscanner );

      /* Okay, we're now positioned to make the NUL
       * transition.  We couldn't have
       * yy_get_previous_state() go ahead and do it
       * for us because it doesn't know how to deal
       * with the possibility of jamming (and we don't
       * want to build jamming into it because then it
       * will run more slowly).
       */

      yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

      yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

      if ( yy_next_state )
        {
        /* Consume the NUL. */
        yy_cp = ï¬¬ï¿½>yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
        }

      else
        {
        yy_cp = yyg->yy_c_buf_p;
        goto yy_find_action;
        }
      }

    else switch ( yy_get_next_buffer( yyscanner ) )
      {
      case EOB_ACT_END_OF_FILE:
        {
        yyg->yy_did_buffer_switch_on_eof = 0;

        if ( cmExpr_yywrap(yyscanner ) )
          {
          /* Note: because we've taken care in
           * yy_get_next_buffer() to have set up
           * yytext, we can now set up
           * yy_c_buf_p so that if some total
           * hoser (like flex itself) wants to
           * call the scanner after we return the
           * YY_NULL, it'll still work - another
           * YY_NULL will get returned.
           */
          yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

          yy_act = YY_STATE_EOF(YY_START);
          goto do_action;
          }

        else
          {
          if ( ! yyg->yy_did_buffer_switch_on_eof )
            YY_NEW_FILE;
          }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        yyg->yy_c_buf_p =
          yyg->yytext_ptr  yy_amount_of_matched_text;

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_match;

      case EOB_ACT_LAST_MATCH:
        yyg->yy_c_buf_p =
        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

        yy_current_state = yy_get_previous_state( yyscanner );

        yy_cp = yyg->yy_c_buf_p;
        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
        goto yy_find_action;
      }
    break;
    }

  default:
    YY_FATAL_ERROR(
      ""fatal flex scanner internal error--no action found"" );
  } /* end of action switch */
    } /* end of scanning one token */
return 0; /* this should not happen but it quiets some compilers */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ï¿½ )
    *(destï¿½) = *(sourceï¿½);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size = b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars = number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was
   reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
  yy_state_type yy_current_state;
  char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

  yy_current_state = yyg->yy_start;

  for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
    {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if ( yy_accept[yy_current_state] )
      {
      yyg->yy_last_accepting_state = yy_current_state;
      yyg->yy_last_accepting_cpos = yy_cp;
      }
    while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
      {
      yy_current_state = (int) yy_def[yy_current_state];
      if ( yy_current_state >= 23 )
        yy_c = yy_meta[(unsigned int) yy_c];
      }
    yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
  int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *yy_cp = yyg->yy_c_buf_p;

  YY_CHAR yy_c = 1;
  if ( yy_accept[yy_current_state] )
    {
    yyg->yy_last_accepting_state = yy_current_state;
    yyg->yy_last_accepting_cpos = yy_cp;
    }
  while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
    {
    yy_current_state = (int) yy_def[yy_current_state];
    if ( yy_current_state >= 23 )
      yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 22);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","
/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
yy_state_type yy_current_state;
char *yy_cp, *yy_bp;
int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if ( !yyg->yy_init )
{
yyg->yy_init = 1;

#ifdef YY_USER_INIT
YY_USER_INIT;
#endif

if ( ! yyg->yy_start )
yyg->yy_start = 1;/* first start state */

if ( ! yyin )
yyin = stdin;

if ( ! yyout )
yyout = stdout;

if ( ! YY_CURRENT_BUFFER ) {
cmExpr_yyensure_buffer_stack (yyscanner);
YY_CURRENT_BUFFER_LVALUE =
cmExpr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
}

cmExpr_yy_load_buffer_state(yyscanner );
}

{
#line 39 ""cmExprLexer.in.l""


#line 732 ""cmExprLexer.cxx""

while ( /*CONSTCOND*/1 )/* loops until end-of-file is reached */
{
yy_cp = yyg->yy_c_buf_p;

/* Support of yytext. */
*yy_cp = yyg->yy_hold_char;

/* yy_bp points to the position in yy_ch_buf of the start of
 * the current run.
 */
yy_bp = yy_cp;

yy_current_state = yyg->yy_start;
yy_match:
do
{
YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
ï¬¬ï¿½_cp;
}
while ( yy_base[yy_current_state] != 21 );

yy_find_action:
yy_act = yy_accept[yy_current_state];
if ( yy_act == 0 )
{ /* have to back up */
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
yy_act = yy_accept[yy_current_state];
}

YY_DO_BEFORE_ACTION;

do_action:/* This label is used only to access EOF actions. */

switch ( yy_act )
{ /* beginning of action switch */
case 0: /* must back up */
/* undo the effects of YY_DO_BEFORE_ACTION */
*yy_cp = yyg->yy_hold_char;
yy_cp = yyg->yy_last_accepting_cpos;
yy_current_state = yyg->yy_last_accepting_state;
goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 41 ""cmExprLexer.in.l""
{ yylvalp->Number = atoi(yytext); return exp_NUMBER; }
YY_BREAK
case 2:
YY_RULE_SETUP
#line 43 ""cmExprLexer.in.l""
{ return exp_PLUS; }
YY_BREAK
case 3:
YY_RULE_SETUP
#line 44 ""cmExprLexer.in.l""
{ return exp_MINUS; }
YY_BREAK
case 4:
YY_RULE_SETUP
#line 45 ""cmExprLexer.in.l""
{ return exp_TIMES; }
YY_BREAK
case 5:
YY_RULE_SETUP
#line 46 ""cmExprLexer.in.l""
{ return exp_DIVIDE; }
YY_BREAK
case 6:
YY_RULE_SETUP
#line 47 ""cmExprLexer.in.l""
{ return exp_MOD; }
YY_BREAK
case 7:
YY_RULE_SETUP
#line 48 ""cmExprLexer.in.l""
{ return exp_OR; }
YY_BREAK
case 8:
YY_RULE_SETUP
#line 49 ""cmExprLexer.in.l""
{ return exp_AND; }
YY_BREAK
case 9:
YY_RULE_SETUP
#line 50 ""cmExprLexer.in.l""
{ return exp_XOR; }
YY_BREAK
case 10:
YY_RULE_SETUP
#line 51 ""cmExprLexer.in.l""
{ return exp_NOT; }
YY_BREAK
case 11:
YY_RULE_SETUP
#line 52 ""cmExprLexer.in.l""
{ return exp_SHIFTLEFT; }
YY_BREAK
case 12:
YY_RULE_SETUP
#line 53 ""cmExprLexer.in.l""
{ return exp_SHIFTRIGHT; }
YY_BREAK
case 13:
YY_RULE_SETUP
#line 54 ""cmExprLexer.in.l""
{ return exp_OPENPARENT; }
YY_BREAK
case 14:
YY_RULE_SETUP
#line 55 ""cmExprLexer.in.l""
{ return exp_CLOSEPARENT; }
YY_BREAK
case 15:
YY_RULE_SETUP
#line 57 ""cmExprLexer.in.l""
ECHO;
YY_BREAK
#line 864 ""cmExprLexer.cxx""
case YY_STATE_EOF(INITIAL):
yyterminate();

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmExpr_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmExpr_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmExpr_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmExpr_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmExpr_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 23 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 22);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",676,684,1059,1082,"YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_208.cpp,"YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_208.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmExpr_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1311,1384,1318,1391,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_209.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_209.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_229.cpp," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
  if ( ! b->yy_ch_buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

  b->yy_is_our_buffer = 1;

  cmExpr_yy_init_buffer(b,file ,yyscanner);

  return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmExpr_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmExpr_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmExpr_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1311,1384,1327,1400,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_210.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_210.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len  2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ï¿½ )
    buf[i] = bytes[i];

  buf[len] = buf[lenï¿½] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmExpr_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmExpr_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1532,1605,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_211.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_211.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len  2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ï¿½ )
    buf[i] = bytes[i];

  buf[len] = buf[lenï¿½] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmExpr_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmExpr_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1581,1654,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_212.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_212.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len  2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ï¿½ )
    buf[i] = bytes[i];

  buf[len] = buf[lenï¿½] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmExpr_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmExpr_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1590,1663,"YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_213.cpp,"YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_213.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_230.cpp," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;

  if ( size < 2 ||
       base[size-2] != YY_END_OF_BUFFER_CHAR ||
       base[size-1] != YY_END_OF_BUFFER_CHAR )
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
  if ( ! b )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

  b->yy_buf_size = size - 2;  /* ""- 2"" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  cmExpr_yy_switch_to_buffer(b ,yyscanner );

  return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a yy_str.
 * @param yy_str a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yy_str , yyscan_t yyscanner)
{

  return cmExpr_yy_scan_bytes(yy_str,strlen(yy_str) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = len  2;
  buf = (char *) cmExpr_yyalloc(n ,yyscanner );
  if ( ! buf )
    YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

  for ( i = 0; i < len; ï¿½ )
    buf[i] = bytes[i];

  buf[len] = buf[lenï¿½] = YY_END_OF_BUFFER_CHAR;

  b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
  if ( ! b )
    YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
  do \
    { \
    /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
    yytext[yyleng] = yyg->yy_hold_char; \
    yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
    yyg->yy_hold_char = *yyg->yy_c_buf_p; \
    *yyg->yy_c_buf_p = '\0'; \
    yyleng = yyless_macro_arg; \
    } \
  while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," */
YY_BUFFER_STATE cmExpr_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmExpr_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmExpr_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmExpr_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmExpr_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

return cmExpr_yy_scan_bytes(yystr,(int) strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmExpr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmExpr_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmExpr_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmExpr_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmExpr_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmExpr_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1519,1592,1606,1681,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_214.cpp,"{
      (void) fprintf( stderr, ""%s\n"", msg );
  exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_214.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1721,1796,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_215.cpp,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_215.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_112.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_231.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmExpr_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmExpr_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmExpr_yy_switch_to_buffer
 */
void cmExpr_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmExpr_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmExpr_yyget_debug  (yyscan_t yyscanner)
",1709,1784,1736,1811,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_216.cpp,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_216.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_233.cpp,"yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
","yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
",1567,1561,1573,1567,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )","YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_217.cpp,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_217.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_113.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_234.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < _yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;
",1996,1990,2010,2004,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_218.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_218.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_235.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_219.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_219.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_114.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_236.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_220.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_220.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_115.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_237.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap)","s = curl_mvaprintf(fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_221.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_221.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_116.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_238.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4107,4103,4112,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_222.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_222.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_239.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,122,122,"vsnprintf(print_buffer, sizeof(print_buffer), message, args);","vsnprintf(print_buffer, sizeof(print_buffer), message, args);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_223.cpp,"{
  int ftp_code;
  ssize_t nread=0;
  va_list args;
  char print_buffer[50];

  va_start(args, message);
  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))
      ftp_code = -1;
  }

  (void)nread; /* Unused */
  return ftp_code;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_223.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 31, 0, 0, 4, 4, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 24, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 2, 2, 1, 0, 6, 0, 0, 6, 0, 13, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_242.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_242.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,731,745,"md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)","md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_224.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_224.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_243.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL))","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_225.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_225.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_122.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_244.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,2181,2202,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_226.cpp,"{
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_226.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_245.cpp,"  return CURLE_OK;
}

#ifdef USE_LIBIDN
/*
 * Initialise use of IDNA library.
 * It falls back to ASCII if $CHARSET isn't defined. This doesn't work for
 * idna_to_ascii_lz().
 */
static void idna_init (void)
{
#ifdef WIN32
  char buf[60];
  UINT cp = GetACP();

  if(!getenv(""CHARSET"") && cp > 0) {
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }
#else
  /* to do? */
#endif
}
#endif  /* USE_LIBIDN */

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
","  return CURLE_OK;
}

/* true globals -- for curl_global_init() and curl_global_cleanup() */
static unsigned int  initialized;
static long          init_flags;
",144,143,160,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_227.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_227.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_123.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_246.cpp,"  }
#endif

#ifdef USE_LIBIDN
  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
","  }
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
",262,239,270,242,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_228.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_228.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_124.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_247.cpp,"                             curl_off_t *size,
                             const char *fmt, ...)
{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}

/*
","                             curl_off_t *size,
                             const char *fmt, ...)
{
  char *s;
  CURLcode result;
  va_list ap;
  va_start(ap, fmt);
  s = curl_mvaprintf(fmt, ap);
  va_end(ap);

  if(!s)
    return CURLE_OUT_OF_MEMORY;

  result = AddFormData(formp, FORM_DATAMEM, s, 0, size);
  if(result)
    free(s);

  return result;
}

/*
",906,914,912,921,"vsnprintf(s, sizeof(s), fmt, ap)","s = curl_mvaprintf(fmt, ap)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_229.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_229.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_125.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_248.cpp,"  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
","  enum protection_level data_sec = conn->data_prot;
#endif

  write_len = strlen(cmd);
  if(write_len > (sizeof(s) -3))
    return CURLE_BAD_FUNCTION_ARGUMENT;

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len =2;
",4106,4102,4111,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_230.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_230.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/security.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_126.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_249.cpp,"  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
","  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsend(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
",122,122,122,122,"vsnprintf(print_buffer, sizeof(print_buffer), message, args);","vsnprintf(print_buffer, sizeof(print_buffer), message, args);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_231.cpp,"{
  int ftp_code;
  ssize_t nread=0;
  va_list args;
  char print_buffer[50];

  va_start(args, message);
  vsnprintf(print_buffer, sizeof(print_buffer), message, args);
  va_end(args);

  if(Curl_ftpsendf(conn, print_buffer)) {
    ftp_code = -1;
  }
  else {
    if(Curl_GetFTPResponse(&nread, conn, &ftp_code))
      ftp_code = -1;
  }

  (void)nread; /* Unused */
  return ftp_code;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_231.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 31, 0, 0, 4, 4, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 24, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 2, 2, 1, 0, 6, 0, 0, 6, 0, 13, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_252.cpp,"
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
","
  md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath);

  if(digest->qop && strcasecompare(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
",730,744,731,745,"md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)","md5this = (unsigned char *) aprintf(""%s:%s"", request, uripath)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_232.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_232.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_253.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_253.cpp,"  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN
  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr = len;
  }
","  left -= len;
  ptr = len;
#endif
#ifdef USE_LIBIDN2
  if(idn2_check_version(IDN2_VERSION)) {
    len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));
    left -= len;
    ptr = len;
  }
",111,111,116,116,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL))","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_233.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_233.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]"
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/vtls/openssl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_131.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_254.cpp,"
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
","
        lerr = SSL_get_verify_result(connssl->handle);
        if(lerr != X509_V_OK) {
          data->set.ssl.certverifyresult = lerr;
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
",2178,2198,2181,2202,"snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))","snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_234.cpp,"{
          snprintf(error_buffer, sizeof(error_buffer),
                   ""SSL certificate problem: %s"",
                   X509_verify_cert_error_string(lerr));
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_234.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,248,248,"sprintf(temp, ""%d"", cmVersion::GetMajorVersion())","sprintf(temp, ""%d"", cmVersion::GetMajorVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_235.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_235.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_144.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_299.cpp,"  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"",
                      cmStateEnums::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",244,244,253,253,"sprintf(temp, ""%d"", cmVersion::GetPatchVersion())","sprintf(temp, ""%d"", cmVersion::GetPatchVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_236.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_236.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
2fe3e55d53989c909be595b00a4749b75886accf,"cmState: Move CacheEntryType enum to separate namespace

Port dependent code to the change.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_145.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_300.cpp,"  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry(""CMAKE_NUMBER_OF_MAKEFILES"", num,
                                          ""number of local generators"",
                                          cmStateEnums::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1103,1103,1103,1103,"sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));","sprintf(num, ""%d"", static_cast<int>(this->Makefiles.size()));",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_237.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_237.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,486,487,"fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str())","fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_238.cpp,"{
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_238.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
a49751fb2eed0ca6415b243c35b23201b8060597,cmState: Move TargetType enum to separate namespace,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_146.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_301.cpp,"              ? ""NEW""
              : ""OLD"");

    if (targetType == cmState::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmState::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
","              ? ""NEW""
              : ""OLD"");

    if (targetType == cmStateEnums::EXECUTABLE) {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    } else // if (targetType == cmStateEnums::STATIC_LIBRARY)
    {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
",481,482,489,490,"fprintf(fout, ""add_executable(%s"", targetName.c_str())","fprintf(fout, ""add_executable(%s"", targetName.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_239.cpp,"{
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_239.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* ï¿½ for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,1393,1367,"YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_240.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_240.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* ï¿½ for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,1416,1390,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_241.cpp,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_241.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* ï¿½ for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,1484,1458,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_242.cpp,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_242.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* ï¿½ for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,1528,1502,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_243.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_243.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_306.cpp,"    unput(yytext[strlen(yytext)-1]);
    }
}
        YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 106 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
        YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 116 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 117 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 127 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 142 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 145 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 147 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""

        YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 151 ""cmFortranLexer.in.l""

        YY_BREAK
case 35:
YY_RULE_SETUP
#line 153 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 155 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 157 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 166 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 168 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 171 ""cmFortranLexer.in.l""
/* Ignore */
        YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 172 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
        YY_BREAK
case 44:
YY_RULE_SETUP
#line 174 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 176 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
        YY_BREAK
case 45:
YY_RULE_SETUP
#line 183 ""cmFortranLexer.in.l""
ECHO;
        YY_BREAK
#line 1291 ""cmFortranLexer.cxx""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmFortran_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmFortran_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
        } /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        yy_size_t num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                yy_size_t new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmFortran_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;
        yy_current_state = YY_AT_BOL();

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 173 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 173 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 172);

        (void)yyg;
        return yy_is_jam ? 0 : yy_current_state;
}

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

        /* undo effects of setting up yytext */
        *yy_cp = yyg->yy_hold_char;

        if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                { /* need to shift things up to make room */
                /* ï¿½ for EOB chars. */
                yy_size_t number_to_move = yyg->yy_n_chars  2;
                char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
                                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
                char *source =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

                while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        *--dest = *--source;

                yy_cp = (int) (dest - source);
                yy_bp = (int) (dest - source);
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

                if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
                        YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
                }

        *--yy_cp = (char) c;

        yyg->yytext_ptr = yy_bp;
        yyg->yy_hold_char = *yy_cp;
        yyg->yy_c_buf_p = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","    unput(yytext[strlen(yytext)-1]);
    }
}
YY_BREAK
case 8:
/* rule 8 can match eol */
YY_RULE_SETUP
#line 99 ""cmFortranLexer.in.l""
{
  unput ('\n');
  BEGIN(INITIAL);
  return UNTERMINATED_STRING;
}
case 9:
YY_RULE_SETUP
#line 105 ""cmFortranLexer.in.l""
{
  cmFortranParser_StringAppend(yyextra, yytext[0]);
}
YY_BREAK
case 10:
/* rule 10 can match eol */
YY_RULE_SETUP
#line 109 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* Treat comments like */
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 110 ""cmFortranLexer.in.l""
{ return EOSTMT; } /* empty lines */
case 12:
YY_RULE_SETUP
#line 112 ""cmFortranLexer.in.l""
{ return CPP_LINE_DIRECTIVE; }
case 13:
/* rule 13 can match eol */
YY_RULE_SETUP
#line 113 ""cmFortranLexer.in.l""
{
  yytext[yyleng-1] = 0;
  yylvalp->string = strdup(strchr(yytext, '<')ï¿½);
  return CPP_INCLUDE_ANGLE;
}
case 14:
YY_RULE_SETUP
#line 118 ""cmFortranLexer.in.l""
{ return CPP_INCLUDE; }
case 15:
YY_RULE_SETUP
#line 119 ""cmFortranLexer.in.l""
{ return F90PPR_INCLUDE; }
case 16:
YY_RULE_SETUP
#line 120 ""cmFortranLexer.in.l""
{ return COCO_INCLUDE; }
case 17:
YY_RULE_SETUP
#line 122 ""cmFortranLexer.in.l""
{ return CPP_DEFINE; }
case 18:
YY_RULE_SETUP
#line 123 ""cmFortranLexer.in.l""
{ return F90PPR_DEFINE; }
case 19:
YY_RULE_SETUP
#line 125 ""cmFortranLexer.in.l""
{ return CPP_UNDEF; }
case 20:
YY_RULE_SETUP
#line 126 ""cmFortranLexer.in.l""
{ return F90PPR_UNDEF; }
case 21:
YY_RULE_SETUP
#line 128 ""cmFortranLexer.in.l""
{ return CPP_IFDEF; }
case 22:
YY_RULE_SETUP
#line 129 ""cmFortranLexer.in.l""
{ return CPP_IFNDEF; }
case 23:
YY_RULE_SETUP
#line 130 ""cmFortranLexer.in.l""
{ return CPP_IF; }
case 24:
YY_RULE_SETUP
#line 131 ""cmFortranLexer.in.l""
{ return CPP_ELIF; }
case 25:
YY_RULE_SETUP
#line 132 ""cmFortranLexer.in.l""
{ return CPP_ELSE; }
case 26:
YY_RULE_SETUP
#line 133 ""cmFortranLexer.in.l""
{ return CPP_ENDIF; }
case 27:
YY_RULE_SETUP
#line 135 ""cmFortranLexer.in.l""
{ return F90PPR_IFDEF; }
case 28:
YY_RULE_SETUP
#line 136 ""cmFortranLexer.in.l""
{ return F90PPR_IFNDEF; }
case 29:
YY_RULE_SETUP
#line 137 ""cmFortranLexer.in.l""
{ return F90PPR_IF; }
case 30:
YY_RULE_SETUP
#line 138 ""cmFortranLexer.in.l""
{ return F90PPR_ELIF; }
case 31:
YY_RULE_SETUP
#line 139 ""cmFortranLexer.in.l""
{ return F90PPR_ELSE; }
case 32:
YY_RULE_SETUP
#line 140 ""cmFortranLexer.in.l""
{ return F90PPR_ENDIF; }
/* Line continuations, possible involving comments.  */
case 33:
/* rule 33 can match eol */
YY_RULE_SETUP
#line 143 ""cmFortranLexer.in.l""

YY_BREAK
case 34:
/* rule 34 can match eol */
YY_RULE_SETUP
#line 144 ""cmFortranLexer.in.l""

YY_BREAK
case 35:
YY_RULE_SETUP
#line 146 ""cmFortranLexer.in.l""
{ return COMMA; }
case 36:
YY_RULE_SETUP
#line 148 ""cmFortranLexer.in.l""
{ return DCOLON; }
case 37:
/* rule 37 can match eol */
YY_RULE_SETUP
#line 150 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 38:
YY_RULE_SETUP
#line 152 ""cmFortranLexer.in.l""
{ return ASSIGNMENT_OP; }
case 39:
YY_RULE_SETUP
#line 154 ""cmFortranLexer.in.l""
{
  yylvalp->string = strdup(yytext);
  return WORD;
}
case 40:
YY_RULE_SETUP
#line 159 ""cmFortranLexer.in.l""
{ return GARBAGE; }
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 161 ""cmFortranLexer.in.l""
{ return EOSTMT; }
case 42:
YY_RULE_SETUP
#line 164 ""cmFortranLexer.in.l""
/* Ignore */
YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 165 ""cmFortranLexer.in.l""
/* Ignore line-endings preceded by \ */
YY_BREAK
case 44:
YY_RULE_SETUP
#line 167 ""cmFortranLexer.in.l""
{ return *yytext; }
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(free_fmt):
case YY_STATE_EOF(fixed_fmt):
case YY_STATE_EOF(str_sq):
case YY_STATE_EOF(str_dq):
#line 169 ""cmFortranLexer.in.l""
{
  if(!cmFortranParser_FilePop(yyextra) )
    {
    return YY_NULL;
    }
}
YY_BREAK
case 45:
YY_RULE_SETUP
#line 176 ""cmFortranLexer.in.l""
ECHO;
YY_BREAK
#line 1276 ""cmFortranLexer.cxx""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmFortran_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmFortran_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmFortran_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
int num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
int new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmFortran_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = NULL;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmFortran_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((int) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmFortran_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;
yy_current_state = YY_AT_BOL();

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 173 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (flex_int16_t) yy_c];
yy_is_jam = (yy_current_state == 172);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
int number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1070,1044,1629,1605,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )","YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_244.cpp,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_244.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_307.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_307.cpp," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmFortran_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmFortran_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1785,1763,1792,1770,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_245.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_245.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_307.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_307.cpp," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmFortran_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmFortran_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmFortran_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmFortran_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1785,1763,1801,1779,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_246.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_246.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_308.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_308.cpp,"void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmFortran_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
        yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmFortran_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1924,1902,1960,1938,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_247.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_247.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_308.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_308.cpp,"void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmFortran_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
        yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmFortran_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmFortran_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmFortran_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmFortran_yyensure_buffer_stack (yyscan_t yyscanner)
{
int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmFortran_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1924,1902,1980,1958,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_248.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_248.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_309.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_309.cpp," */
YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmFortran_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will
"," */
YY_BUFFER_STATE cmFortran_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

if ( size < 2 ||
     base[size-2] != YY_END_OF_BUFFER_CHAR ||
     base[size-1] != YY_END_OF_BUFFER_CHAR )
/* They forgot to leave room for the EOB's. */
return NULL;

b = (YY_BUFFER_STATE) cmFortran_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" );

b->yy_buf_size = size - 2;/* ""- 2"" to take care of EOB's */
b->yy_buf_pos = b->yy_ch_buf = base;
b->yy_is_our_buffer = 0;
b->yy_input_file = NULL;
b->yy_n_chars = b->yy_buf_size;
b->yy_is_interactive = 0;
b->yy_at_bol = 1;
b->yy_fill_buffer = 0;
b->yy_buffer_status = YY_BUFFER_NEW;

cmFortran_yy_switch_to_buffer(b ,yyscanner );

return b;
}

/** Setup the input buffer state to scan a string. The next call to cmFortran_yylex() will
",1993,1971,2006,1984,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_249.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_249.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_310.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        yy_size_t i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmFortran_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmFortran_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",2041,2019,2055,2033,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_250.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_250.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_310.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        yy_size_t i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmFortran_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmFortran_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",2041,2019,2064,2042,"YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_251.cpp,"YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_251.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_310.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_310.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        yy_size_t i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmFortran_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t)
{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmFortran_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = (yy_size_t) _yybytes_len  2;
buf = (char *) cmFortran_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmFortran_yy_scan_bytes()"" );

for ( i = 0; i < (size_t)_yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmFortran_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmFortran_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",2041,2019,2080,2060,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_252.cpp,"{
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_252.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_311.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmFortran_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmFortran_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
",2183,2163,2195,2175,"YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" )","YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_253.cpp,"YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_253.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
f70c71c5a9759324d9e610bc919832b7500fd116,"cmFortranLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Also drop the duplicate copyright notice block from the generated file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_149.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_311.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_311.cpp,"}

/** Set the current line number.
 * @param line_number The line number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmFortran_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmFortran_yy_switch_to_buffer
 */
void cmFortran_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmFortran_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmFortran_yyget_debug  (yyscan_t yyscanner)
",2183,2163,2210,2190,"YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" )","YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_254.cpp,"YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_254.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_315.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_315.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,237,238,"snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])","snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_255.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_255.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_152.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_315.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_315.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,243,245,"snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] )","snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_256.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_256.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_154.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_317.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_317.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,1283,1314,"fprintf(out, ""#\n# Fatal libcurl error\n"")","fprintf(out, ""#\n# Fatal libcurl error\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_257.cpp,"{
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_257.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_258.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_258.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_259.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_259.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_260.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_260.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_261.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_261.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_262.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_262.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_263.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_263.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_264.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_264.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data))",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_265.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_265.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_266.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_266.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_267.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_267.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_268.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_268.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_269.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_269.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_270.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_270.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_271.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_271.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_272.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_272.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_273.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_273.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_155.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_318.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_318.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_274.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_274.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_322.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_322.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec)","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_275.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_275.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_161.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_326.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_326.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_276.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_276.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]"
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_164.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_329.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_329.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,2797,3079,"fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)","fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_277.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_277.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_332.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_332.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,237,238,"snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])","snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_278.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_278.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_167.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_332.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_332.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,243,245,"snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] )","snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_279.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_279.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_169.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_334.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_334.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,1283,1314,"fprintf(out, ""#\n# Fatal libcurl error\n"")","fprintf(out, ""#\n# Fatal libcurl error\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_280.cpp,"{
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_280.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_281.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_281.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_282.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_282.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_283.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_283.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_284.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_284.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_285.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_285.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_286.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_286.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_287.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_287.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data))",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_288.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_288.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_289.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_289.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_290.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_290.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_291.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_291.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_292.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_292.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_293.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_293.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_294.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_294.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_295.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_295.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_296.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_296.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_170.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_335.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_335.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_297.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_297.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_339.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_339.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec)","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_298.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_298.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_176.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_343.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_343.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_299.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_299.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_179.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_346.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_346.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,2797,3079,"fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)","fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_300.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_300.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,499,501,"snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize)","snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_301.cpp,"snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_301.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,510,512,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize )","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_302.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_302.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_349.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_349.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,518,520,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time)","snprintf(buf, sizeof(buf), ""%d"", state->retry_time)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_303.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_303.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_350.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,237,238,"snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])","snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_304.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_304.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/base64.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_183.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_350.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_350.cpp,"               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }
    output = 4;
  }
  *output = '\0';
  *outptr = base64data; /* return pointer to new data, allocated memory */

  free(convbuf);

  *outlen = strlen(base64data); /* return the length of the new data */

  return CURLE_OK;
}
","               table64[obuf[0]],
               table64[obuf[1]]);
      break;

    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;

    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]]);
      break;
    }
    output = 4;
  }

  /* Zero terminate */
  *output = '\0';

  /* Return the pointer to the new data (allocated memory) */
  *outptr = base64data;

  free(convbuf);

  /* Return the length of the new data */
  *outlen = strlen(base64data);

  return CURLE_OK;
}
",233,233,243,245,"snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] )","snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_305.cpp,"{
    case 1: /* only one byte read */
      snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);
      break;
    default:
      snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_305.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_185.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_352.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_352.cpp,"      return 1; /* failure */
  }

  if(c) {
    char *format_ptr;

    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

  if(!use_stdout)
","      return 1; /* failure */
  }

  fputs(""# Netscape HTTP Cookie File\n""
        ""# https://curl.haxx.se/docs/http-cookies.html\n""
        ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
        out);

  for(co = c->cookies; co; co = co->next) {
    if(!co->domain)
      continue;
    format_ptr = get_netscape_format(co);
    if(format_ptr == NULL) {
      fprintf(out, ""#\n# Fatal libcurl error\n"");
      if(!use_stdout)
        fclose(out);
      return 1;
    }
    fprintf(out, ""%s\n"", format_ptr);
    free(format_ptr);
  }

  if(!use_stdout)
",1267,1301,1283,1314,"fprintf(out, ""#\n# Fatal libcurl error\n"")","fprintf(out, ""#\n# Fatal libcurl error\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_306.cpp,"{
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_306.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,169,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_307.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_307.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,475,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_308.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_308.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,637,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_309.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_309.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,670,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_310.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_310.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,693,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_311.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_311.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,723,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_312.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_312.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,726,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_313.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_313.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,922,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data))",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_314.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_314.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,957,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_315.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_315.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,980,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_316.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_316.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1000,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_317.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_317.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1009,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_318.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_318.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1041,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_319.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_319.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1064,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_320.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_320.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1082,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_321.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_321.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1092,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_322.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_322.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_353.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_353.cpp,"  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",      5,  SASL_MECH_LOGIN },
  { ""PLAIN"",      5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",   8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"", 10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",     6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",   8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",       4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",    7,  SASL_MECH_XOAUTH2 },
  { ZERO_NULL,    0,  0 }
};

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
#define DIGEST_QOP_VALUE_AUTH             (1 << 0)
#define DIGEST_QOP_VALUE_AUTH_INT         (1 << 1)
#define DIGEST_QOP_VALUE_AUTH_CONF        (1 << 2)

#define DIGEST_QOP_VALUE_STRING_AUTH      ""auth""
#define DIGEST_QOP_VALUE_STRING_AUTH_INT  ""auth-int""
#define DIGEST_QOP_VALUE_STRING_AUTH_CONF ""auth-conf""

/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  result = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(result) { \
    free(b); \
    return result; \
  }

#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH)
/*
 * Returns 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
int Curl_sasl_digest_get_pair(const char *str, char *value, char *content,
                              const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value = 0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c = 0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c = 0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c = 0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content = 0;

  *endptr = str;

  return 0; /* all is fine! */
}
#endif

#if !defined(CURL_DISABLE_CRYPTO_AUTH) && !defined(USE_WINDOWS_SSPI)
/* Convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void sasl_digest_md5_to_ascii(unsigned char *source, /* 16 bytes */
                                     unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i = 0; i < 16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *sasl_digest_string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

/* Retrieves the value for a corresponding key from the challenge string
 * returns TRUE if the key could be found, FALSE if it does not exists
 */
static bool sasl_digest_get_key_value(const char *chlg,
                                      const char *key,
                                      char *value,
                                      size_t max_val_len,
                                      char end_char)
{
  char *find_pos;
  size_t i;

  find_pos = strstr(chlg, key);
  if(!find_pos)
    return FALSE;

  find_pos = strlen(key);

  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ï¿½)
    value[i] = *find_posï¿½;
  value[i] = '\0';

  return TRUE;
}

static CURLcode sasl_digest_get_qop_values(const char *options, int *value)
{
  char *tmp;
  char *token;
  char *tok_buf;

  /* Initialise the output */
  *value = 0;

  /* Tokenise the list of qop values. Use a temporary clone of the buffer since
     strtok_r() ruins it. */
  tmp = strdup(options);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;

  token = strtok_r(tmp, "","", &tok_buf);
  while(token != NULL) {
    if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH))
      *value |= DIGEST_QOP_VALUE_AUTH;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT))
      *value |= DIGEST_QOP_VALUE_AUTH_INT;
    else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_CONF))
      *value |= DIGEST_QOP_VALUE_AUTH_CONF;

    token = strtok_r(NULL, "","", &tok_buf);
  }

  free(tmp);

  return CURLE_OK;
}
#endif /* !CURL_DISABLE_CRYPTO_AUTH && !USE_WINDOWS_SSPI */

#if !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_build_spn()
 *
 * This is used to build a SPN string in the format service/host.
 *
 * Parameters:
 *
 * service  [in] - The service type such as www, smtp, pop or imap.
 * host     [in] - The host name or realm.
 *
 * Returns a pointer to the newly allocated SPN.
 */
char *Curl_sasl_build_spn(const char *service, const char *host)
{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}
#endif

/*
 * sasl_create_plain_message()
 *
 * This is used to generate an already encoded PLAIN message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_plain_message(struct SessionHandle *data,
                                          const char *userp,
                                          const char *passwdp,
                                          char **outptr, size_t *outlen)
{
  CURLcode result;
  char *plainauth;
  size_t ulen;
  size_t plen;

  ulen = strlen(userp);
  plen = strlen(passwdp);

  plainauth = malloc(2 * ulen  plen  2);
  if(!plainauth) {
    *outlen = 0;
    *outptr = NULL;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Calculate the reply */
  memcpy(plainauth, userp, ulen);
  plainauth[ulen] = '\0';
  memcpy(plainauth  ulen  1, userp, ulen);
  plainauth[2 * ulen  1] = '\0';
  memcpy(plainauth  2 * ulen  2, passwdp, plen);

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, plainauth, 2 * ulen  plen  2, outptr,
                              outlen);
  free(plainauth);
  return result;
}

/*
 * sasl_create_login_message()
 *
 * This is used to generate an already encoded LOGIN message containing the
 * user name or password ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * valuep  [in]     - The user name or user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_login_message(struct SessionHandle *data,
                                          const char *valuep, char **outptr,
                                          size_t *outlen)
{
  size_t vlen = strlen(valuep);

  if(!vlen) {
    /* Calculate an empty reply */
    *outptr = strdup(""="");
    if(*outptr) {
      *outlen = (size_t) 1;
      return CURLE_OK;
    }

    *outlen = 0;
    return CURLE_OUT_OF_MEMORY;
  }

  /* Base64 encode the value */
  return Curl_base64_encode(data, valuep, vlen, outptr, outlen);
}

/*
 * sasl_create_external_message()
 *
 * This is used to generate an already encoded EXTERNAL message containing
 * the user name ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_external_message(struct SessionHandle *data,
                                             const char *user, char **outptr,
                                             size_t *outlen)
{
  /* This is the same formatting as the login message. */
  return sasl_create_login_message(data, user, outptr, outlen);
}

#ifndef CURL_DISABLE_CRYPTO_AUTH
 /*
 * sasl_decode_cram_md5_message()
 *
 * This is used to decode an already encoded CRAM-MD5 challenge message.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_cram_md5_message(const char *chlg64, char **outptr,
                                             size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlg64len = strlen(chlg64);

  *outptr = NULL;
  *outlen = 0;

  /* Decode the challenge if necessary */
  if(chlg64len && *chlg64 != '=')
    result = Curl_base64_decode(chlg64, (unsigned char **) outptr, outlen);

    return result;
 }

 /*
 * sasl_create_cram_md5_message()
 *
 * This is used to generate an already encoded CRAM-MD5 response message ready
 * for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg    [in]     - The challenge.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_cram_md5_message(struct SessionHandle *data,
                                             const char *chlg,
                                             const char *userp,
                                             const char *passwdp,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

#ifndef USE_WINDOWS_SSPI
/*
 * sasl_decode_digest_md5_message()
 *
 * This is used internally to decode an already encoded DIGEST-MD5 challenge
 * message into the seperate attributes.
 *
 * Parameters:
 *
 * chlg64  [in]     - The base64 encoded challenge message.
 * nonce   [in/out] - The buffer where the nonce will be stored.
 * nlen    [in]     - The length of the nonce buffer.
 * realm   [in/out] - The buffer where the realm will be stored.
 * rlen    [in]     - The length of the realm buffer.
 * alg     [in/out] - The buffer where the algorithm will be stored.
 * alen    [in]     - The length of the algorithm buffer.
 * qop     [in/out] - The buffer where the qop-options will be stored.
 * qlen    [in]     - The length of the qop buffer.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_decode_digest_md5_message(const char *chlg64,
                                               char *nonce, size_t nlen,
                                               char *realm, size_t rlen,
                                               char *alg, size_t alen,
                                               char *qop, size_t qlen)
{
  CURLcode result = CURLE_OK;
  unsigned char *chlg = NULL;
  size_t chlglen = 0;
  size_t chlg64len = strlen(chlg64);

  /* Decode the base-64 encoded challenge message */
  if(chlg64len && *chlg64 != '=') {
    result = Curl_base64_decode(chlg64, &chlg, &chlglen);
    if(result)
      return result;
  }

  /* Ensure we have a valid challenge message */
  if(!chlg)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Retrieve nonce string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""nonce=\"""", nonce, nlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve realm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""realm=\"""", realm, rlen, '\""')) {
    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
    strcpy(realm, """");
  }

  /* Retrieve algorithm string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""algorithm="", alg, alen, ',')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  /* Retrieve qop-options string from the challenge */
  if(!sasl_digest_get_key_value((char *)chlg, ""qop=\"""", qop, qlen, '\""')) {
    free(chlg);
    return CURLE_BAD_CONTENT_ENCODING;
  }

  free(chlg);

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_md5_message()
 *
 * This is used to generate an already encoded DIGEST-MD5 response message
 * ready for sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * chlg64  [in]     - The base64 encoded challenge message.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * service [in]     - The service type such as www, smtp, pop or imap.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN  1];
  char HA2_hex[2 * MD5_DIGEST_LEN  1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN  1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; iï¿½)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}

/*
 * Curl_sasl_decode_digest_http_message()
 *
 * This is used to decode a HTTP DIGEST challenge message into the seperate
 * attributes.
 *
 * Parameters:
 *
 * chlg    [in]     - The challenge message.
 * digest  [in/out] - The digest data struct being used and modified.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest)
{
  bool before = FALSE; /* got a nonce before */
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  char *token = NULL;
  char *tmp = NULL;

  /* If we already have received a nonce, keep that in mind */
  if(digest->nonce)
    before = TRUE;

  /* Clean up any former leftovers and initialise to defaults */
  Curl_sasl_digest_cleanup(digest);

  for(;;) {
    char value[DIGEST_MAX_VALUE_LENGTH];
    char content[DIGEST_MAX_CONTENT_LENGTH];

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Extract a value=content pair */
    if(!Curl_sasl_digest_get_pair(chlg, value, content, &chlg)) {
      if(Curl_raw_equal(value, ""nonce"")) {
        digest->nonce = strdup(content);
        if(!digest->nonce)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""stale"")) {
        if(Curl_raw_equal(content, ""true"")) {
          digest->stale = TRUE;
          digest->nc = 1; /* we make a new nonce now */
        }
      }
      else if(Curl_raw_equal(value, ""realm"")) {
        digest->realm = strdup(content);
        if(!digest->realm)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""opaque"")) {
        digest->opaque = strdup(content);
        if(!digest->opaque)
          return CURLE_OUT_OF_MEMORY;
      }
      else if(Curl_raw_equal(value, ""qop"")) {
        char *tok_buf;
        /* Tokenize the list and choose auth if possible, use a temporary
            clone of the buffer since strtok_r() ruins it */
        tmp = strdup(content);
        if(!tmp)
          return CURLE_OUT_OF_MEMORY;

        token = strtok_r(tmp, "","", &tok_buf);
        while(token != NULL) {
          if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
            foundAuth = TRUE;
          }
          else if(Curl_raw_equal(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
            foundAuthInt = TRUE;
          }
          token = strtok_r(NULL, "","", &tok_buf);
        }

        free(tmp);

        /* Select only auth or auth-int. Otherwise, ignore */
        if(foundAuth) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
        else if(foundAuthInt) {
          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
          if(!digest->qop)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else if(Curl_raw_equal(value, ""algorithm"")) {
        digest->algorithm = strdup(content);
        if(!digest->algorithm)
          return CURLE_OUT_OF_MEMORY;

        if(Curl_raw_equal(content, ""MD5-sess""))
          digest->algo = CURLDIGESTALGO_MD5SESS;
        else if(Curl_raw_equal(content, ""MD5""))
          digest->algo = CURLDIGESTALGO_MD5;
        else
          return CURLE_BAD_CONTENT_ENCODING;
      }
      else {
        /* unknown specifier, ignore it! */
      }
    }
    else
      break; /* we're done here */

    /* Pass all additional spaces here */
    while(*chlg && ISSPACE(*chlg))
      chlgï¿½;

    /* Allow the list to be comma-separated */
    if(',' == *chlg)
      chlgï¿½;
  }

  /* We had a nonce since before, and we got another one now without
     'stale=true'. This means we provided bad credentials in the previous
     request */
  if(before && !digest->stale)
    return CURLE_BAD_CONTENT_ENCODING;

  /* We got this header without a nonce, that's a bad Digest line! */
  if(!digest->nonce)
    return CURLE_BAD_CONTENT_ENCODING;

  return CURLE_OK;
}

/*
 * Curl_sasl_create_digest_http_message()
 *
 * This is used to generate a HTTP DIGEST response message ready for sending
 * to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * userp   [in]     - The user name.
 * passdwp [in]     - The user's password.
 * request [in]     - The HTTP request.
 * uripath [in]     - The path of the HTTP uri.
 * digest  [in/out] - The digest data struct being used and modified.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uripath,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen)
{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->ncï¿½; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}

/*
 * Curl_sasl_digest_cleanup()
 *
 * This is used to clean up the digest specific data.
 *
 * Parameters:
 *
 * digest    [in/out] - The digest data struct being cleaned up.
 *
 */
void Curl_sasl_digest_cleanup(struct digestdata *digest)
{
  Curl_safefree(digest->nonce);
  Curl_safefree(digest->cnonce);
  Curl_safefree(digest->realm);
  Curl_safefree(digest->opaque);
  Curl_safefree(digest->qop);
  Curl_safefree(digest->algorithm);

  digest->nc = 0;
  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  digest->stale = FALSE; /* default means normal, not stale */
}
#endif  /* !USE_WINDOWS_SSPI */

#endif  /* CURL_DISABLE_CRYPTO_AUTH */

#if defined(USE_NTLM) && !defined(USE_WINDOWS_SSPI)
/*
 * Curl_sasl_ntlm_cleanup()
 *
 * This is used to clean up the ntlm specific data.
 *
 * Parameters:
 *
 * ntlm    [in/out] - The ntlm data struct being cleaned up.
 *
 */
void Curl_sasl_ntlm_cleanup(struct ntlmdata *ntlm)
{
  /* Free the target info */
  Curl_safefree(ntlm->target_info);

  /* Reset any variables */
  ntlm->target_info_len = 0;
}
#endif /* USE_NTLM && !USE_WINDOWS_SSPI*/

/*
 * sasl_create_xoauth2_message()
 *
 * This is used to generate an already encoded OAuth 2.0 message ready for
 * sending to the recipient.
 *
 * Parameters:
 *
 * data    [in]     - The session handle.
 * user    [in]     - The user name.
 * bearer  [in]     - The bearer token.
 * outptr  [in/out] - The address where a pointer to newly allocated memory
 *                    holding the result will be stored upon completion.
 * outlen  [out]    - The length of the output message.
 *
 * Returns CURLE_OK on success.
 */
static CURLcode sasl_create_xoauth2_message(struct SessionHandle *data,
                                            const char *user,
                                            const char *bearer,
                                            char **outptr, size_t *outlen)
{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}

/*
 * Curl_sasl_cleanup()
 *
","  size_t        len;   /* Name length */
  unsigned int  bit;   /* Flag bit */
} mechtable[] = {
  { ""LOGIN"",        5,  SASL_MECH_LOGIN },
  { ""PLAIN"",        5,  SASL_MECH_PLAIN },
  { ""CRAM-MD5"",     8,  SASL_MECH_CRAM_MD5 },
  { ""DIGEST-MD5"",   10, SASL_MECH_DIGEST_MD5 },
  { ""GSSAPI"",       6,  SASL_MECH_GSSAPI },
  { ""EXTERNAL"",     8,  SASL_MECH_EXTERNAL },
  { ""NTLM"",         4,  SASL_MECH_NTLM },
  { ""XOAUTH2"",      7,  SASL_MECH_XOAUTH2 },
  { ""OAUTHBEARER"",  11, SASL_MECH_OAUTHBEARER },
  { ZERO_NULL,      0,  0 }
};

/*
 * Curl_sasl_cleanup()
 *
",56,57,1181,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_323.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_323.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_357.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_357.cpp,"    if(result)
      return result;

    if(fstated) {
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year  1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }
    /* if we fstat()ed the file, set the file size to make it available post-
       transfer */
    if(fstated)
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
","    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year  1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }
",479,486,491,495,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec)","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_324.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_324.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_192.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_361.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_361.cpp,"
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
  }

  major_status = Curl_gss_init_sec_context(data,
                                           &minor_status,
                                           &neg_ctx->context,
                                           neg_ctx->server_name,
                                           &Curl_spnego_mech_oid,
                                           GSS_C_NO_CHANNEL_BINDINGS,
                                           &input_token,
                                           &output_token,
                                           TRUE,
                                           NULL);
  Curl_safefree(input_token.value);

  neg_ctx->status = major_status;
  if(GSS_ERROR(major_status)) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    Curl_gss_log_error(conn->data, minor_status,
                       ""gss_init_sec_context() failed: "");
    return CURLE_OUT_OF_MEMORY;
  }

  if(!output_token.value || !output_token.length) {
    if(output_token.value)
      gss_release_buffer(&discard_st, &output_token);
    return CURLE_OUT_OF_MEMORY;
  }

  neg_ctx->output_token = output_token;

  return CURLE_OK;
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);
  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
","
#include ""curl_setup.h""

#if !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""rawstr.h""
#include ""http_negotiate.h""
#include ""vauth/vauth.h""

/* The last 3 #include files should be in this order */
#include ""curl_printf.h""
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct Curl_easy *data = conn->data;
  size_t len;

  /* Point to the username, password, service and host */
  const char *userp;
  const char *passwdp;
  const char *service;
  const char *host;

  /* Point to the correct struct with this */
  struct negotiatedata *neg_ctx;

  if(proxy) {
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
              data->set.str[STRING_PROXY_SERVICE_NAME] : ""HTTP"";
    host = conn->proxy.name;
    neg_ctx = &data->state.proxyneg;
  }
  else {
    userp = conn->user;
    passwdp = conn->passwd;
    service = data->set.str[STRING_SERVICE_NAME] ?
              data->set.str[STRING_SERVICE_NAME] : ""HTTP"";
    host = conn->host.name;
    neg_ctx = &data->state.negotiate;
  }

  /* Not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

  /* Obtain the input token, if any */
  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(!len) {
    /* Is this the first call in a new negotiation? */
    if(neg_ctx->context) {
      /* The server rejected our authentication and hasn't suppled any more
      negotiation mechanisms */
      return CURLE_LOGIN_DENIED;
    }
  }

  /* Initilise the security context and decode our challenge */
  return Curl_auth_decode_spnego_message(data, userp, passwdp, service, host,
                                         header, neg_ctx);
}

CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
{
  struct negotiatedata *neg_ctx = proxy ? &conn->data->state.proxyneg :
    &conn->data->state.negotiate;
  char *base64 = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;

  result = Curl_auth_create_spnego_message(conn->data, neg_ctx, &base64, &len);
  if(result)
    return result;

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);

  if(proxy) {
    Curl_safefree(conn->allocptr.proxyuserpwd);
    conn->allocptr.proxyuserpwd = userp;
",22,22,173,110,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_325.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_325.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/multi.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_195.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_364.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_364.cpp,"}

#ifdef DEBUGBUILD
void Curl_multi_dump(const struct Curl_multi *multi_handle)
{
  struct Curl_multi *multi=(struct Curl_multi *)multi_handle;
  struct SessionHandle *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
","}

#ifdef DEBUGBUILD
void Curl_multi_dump(struct Curl_multi *multi)
{
  struct Curl_easy *data;
  int i;
  fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive);
",2789,3072,2797,3079,"fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)","fprintf(stderr, ""* Multi status: %d handles, %d alive\n"",
          multi->num_easy, multi->num_alive)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_326.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_326.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,499,501,"snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize)","snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_327.cpp,"snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_327.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,510,512,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize )","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_328.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_328.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_367.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_367.cpp,"             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_TSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_BLKSIZE);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½,
                              TFTP_OPTION_INTERVAL);
    sbytes = tftp_option_add(state, sbytes,
                              (char *)state->spacket.dataë¼êµºï¿½, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
","             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4  strlen(filename)  strlen(mode);

    /* optional addition of TFTP options */
    if(!data->set.tftp_no_options) {
      /* add tsize option */
      if(data->set.upload && (data->state.infilesize != -1))
        snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
                 data->state.infilesize);
      else
        strcpy(buf, ""0""); /* the destination is large enough */

      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_TSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
      /* add blksize option */
      snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_BLKSIZE);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);

      /* add timeout option */
      snprintf(buf, sizeof(buf), ""%d"", state->retry_time);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½,
                                TFTP_OPTION_INTERVAL);
      sbytes = tftp_option_add(state, sbytes,
                                (char *)state->spacket.dataë¼êµºï¿½, buf);
    }

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
",494,494,518,520,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time)","snprintf(buf, sizeof(buf), ""%d"", state->retry_time)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_329.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_329.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_368.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_368.cpp,"
  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == NULL) || (*p == '\0')) {
    sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry));
    p = tmp;
  }
","
  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == CM_NULLPTR) || (*p == '\0')) {
    sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry));
    p = tmp;
  }
",1432,1433,1436,1437,"sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry))","sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_330.cpp,"{
    sprintf(tmp, ""%lu "", (unsigned long)archive_entry_uid(entry));
    p = tmp;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_330.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_369.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_369.cpp,"  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != NULL && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
","  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != CM_NULLPTR && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
",1443,1444,1443,1444,"fprintf(out, ""%-*s "", (int)u_width, p);","fprintf(out, ""%-*s "", (int)u_width, p);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_331.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_331.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_199.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_369.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_369.cpp,"  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != NULL && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
","  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != CM_NULLPTR && p[0] != '\0') {
    fprintf(out, ""%s"", p);
    w = strlen(p);
  } else {
",1443,1444,1447,1448,"fprintf(out, ""%s"", p)","fprintf(out, ""%s"", p)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_332.cpp,"{
    fprintf(out, ""%s"", p);
    w = strlen(p);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_332.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
1d6909a287bb73b5ec7bf51ec56f7efcf2a869eb,use CM_NULLPTR,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_200.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_370.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_370.cpp,"
    gg->CreateGenerationObjects();
    cmLocalGenerator* lg = gg->LocalGenerators[0];
    std::string includeFlags = lg->GetIncludeFlags(includeDirs, 0, language);

    std::string definitions = mf->GetSafeDefinition(""PACKAGE_DEFINITIONS"");
    printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str());
","
    gg->CreateGenerationObjects();
    cmLocalGenerator* lg = gg->LocalGenerators[0];
    std::string includeFlags =
      lg->GetIncludeFlags(includeDirs, CM_NULLPTR, language);

    std::string definitions = mf->GetSafeDefinition(""PACKAGE_DEFINITIONS"");
    printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str());
",463,463,469,470,"printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str())","printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_333.cpp,"{
    std::string includes = mf->GetSafeDefinition(""PACKAGE_INCLUDE_DIRS"");
    std::vector<std::string> includeDirs;
    cmSystemTools::ExpandListArgument(includes, includeDirs);

    gg->CreateGenerationObjects();
    cmLocalGenerator* lg = gg->LocalGenerators[0];
    std::string includeFlags = lg->GetIncludeFlags(includeDirs, 0, language);

    std::string definitions = mf->GetSafeDefinition(""PACKAGE_DEFINITIONS"");
    printf(""%s %s\n"", includeFlags.c_str(), definitions.c_str());
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_333.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 51, 0, 0, 5, 5, 0, 0, 4, 5, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 9, 0, 0, 3, 0, 11, 0, 0, 0, 0, 0, 0]"
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,447,-1,"fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_334.cpp,"{
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_334.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]"
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,451,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_335.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_335.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_207.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_377.cpp,"              fname.c_str());
    }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if (this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"") !=
        0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(
        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    } else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"") != 0) {
      std::string flag = ""-DCMAKE_OSX_ARCHITECTURES="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"") != 0) {
      std::string flag = ""-DCMAKE_OSX_SYSROOT="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
    }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if (this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"") != 0) {
      std::string flag = ""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag = this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
    }
    if (const char* cxxDef =
          this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_TARGET="";
      flag = cxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* cDef =
          this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_TARGET="";
      flag = cDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcxxDef = this->Makefile->GetDefinition(
          ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcxxDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* tcDef = this->Makefile->GetDefinition(
          ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN"")) {
      std::string flag = ""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag = tcDef;
      cmakeFlags.push_back(flag);
    }
    if (const char* rootDef = this->Makefile->GetDefinition(""CMAKE_SYSROOT"")) {
      std::string flag = ""-DCMAKE_SYSROOT="";
      flag = rootDef;
      cmakeFlags.push_back(flag);
    }
    if (this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"") !=
        0) {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_START_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }
    if (const char* lssDef =
          this->Makefile->GetDefinition(""CMAKE_LINK_SEARCH_END_STATIC"")) {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
","              fname.c_str());
    }

    // Forward a set of variables to the inner project cache.
    {
      std::set<std::string> vars;
      vars.insert(kCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_C_COMPILER_TARGET);
      vars.insert(kCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN);
      vars.insert(kCMAKE_CXX_COMPILER_TARGET);
      vars.insert(kCMAKE_ENABLE_EXPORTS);
      vars.insert(kCMAKE_LINK_SEARCH_END_STATIC);
      vars.insert(kCMAKE_LINK_SEARCH_START_STATIC);
      vars.insert(kCMAKE_OSX_ARCHITECTURES);
      vars.insert(kCMAKE_OSX_DEPLOYMENT_TARGET);
      vars.insert(kCMAKE_OSX_SYSROOT);
      vars.insert(kCMAKE_POSITION_INDEPENDENT_CODE);
      vars.insert(kCMAKE_SYSROOT);

      /* for the TRY_COMPILEs we want to be able to specify the architecture.
         So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
         CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
         have the tests run for each specific architecture. Since
         cmLocalGenerator doesn't allow building for ""the other""
         architecture only via CMAKE_OSX_ARCHITECTURES.
         */
      if (const char* tcArchs = this->Makefile->GetDefinition(
            kCMAKE_TRY_COMPILE_OSX_ARCHITECTURES)) {
        vars.erase(kCMAKE_OSX_ARCHITECTURES);
        std::string flag = ""-DCMAKE_OSX_ARCHITECTURES=""  std::string(tcArchs);
        cmakeFlags.push_back(flag);
      }

      for (std::set<std::string>::iterator vi = vars.begin(); vi != vars.end();
           ï«¸ï¿½) {
        std::string const& var = *vi;
        if (const char* val = this->Makefile->GetDefinition(var)) {
          std::string flag = ""-D""  var  ""=""  val;
          cmakeFlags.push_back(flag);
        }
      }
    }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
",383,405,455,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_336.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_336.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_379.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_379.cpp,"}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 274 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 280 ""cmListFileLexer.in.l""
ECHO;
YY_BREAK
#line 1242 ""cmListFileLexer.c""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmListFileLexer_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmListFileLexer_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
yy_size_t num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
yy_size_t new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmListFileLexer_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
yy_is_jam = (yy_current_state == 76);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
yy_size_t number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1197,1213,1336,1352,"YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" )","YY_FATAL_ERROR(
			""fatal flex scanner internal error--no action found"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_337.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_337.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_379.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_379.cpp,"}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 274 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 280 ""cmListFileLexer.in.l""
ECHO;
YY_BREAK
#line 1242 ""cmListFileLexer.c""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmListFileLexer_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmListFileLexer_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
yy_size_t num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
yy_size_t new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmListFileLexer_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
yy_is_jam = (yy_current_state == 76);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
yy_size_t number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1197,1213,1358,1375,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )","YY_FATAL_ERROR(
		""fatal flex scanner internal error--end of buffer missed"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_338.cpp,"YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_338.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_379.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_379.cpp,"}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 274 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 280 ""cmListFileLexer.in.l""
ECHO;
YY_BREAK
#line 1242 ""cmListFileLexer.c""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmListFileLexer_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmListFileLexer_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
yy_size_t num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
yy_size_t new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmListFileLexer_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
yy_is_jam = (yy_current_state == 76);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
yy_size_t number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1197,1213,1426,1443,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )","YY_FATAL_ERROR(
				""fatal error - scanner input buffer overflow"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_339.cpp,"YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_339.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_379.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_379.cpp,"}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ï¬¬ï¿½>yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr  yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ï¿½ )
                *(destï¿½) = *(sourceï¿½);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size = b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars = number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
","}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 274 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 280 ""cmListFileLexer.in.l""
ECHO;
YY_BREAK
#line 1242 ""cmListFileLexer.c""

case YY_END_OF_BUFFER:
{
/* Amount of text matched not including the EOB char. */
int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

/* Undo the effects of YY_DO_BEFORE_ACTION. */
*yy_cp = yyg->yy_hold_char;
YY_RESTORE_YY_MORE_OFFSET

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
{
/* We're scanning a new file or input source.  It's
 * possible that this happened because the user
 * just pointed yyin at a new source and called
 * cmListFileLexer_yylex().  If so, then we have to assure
 * consistency between YY_CURRENT_BUFFER and our
 * globals.  Here is the right place to do so, because
 * this is the first action (other than possibly a
 * back-up) that will match for the new input source.
 */
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
}

/* Note that here we test for yy_c_buf_p ""<="" to the position
 * of the first EOB in the buffer, since yy_c_buf_p will
 * already have been incremented past the NUL character
 * (since all states make transitions on EOB to the
 * end-of-buffer state).  Contrast this with the test
 * in input().
 */
if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
{ /* This was really a NUL. */
yy_state_type yy_next_state;

yyg->yy_c_buf_p = yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

/* Okay, we're now positioned to make the NUL
 * transition.  We couldn't have
 * yy_get_previous_state() go ahead and do it
 * for us because it doesn't know how to deal
 * with the possibility of jamming (and we don't
 * want to build jamming into it because then it
 * will run more slowly).
 */

yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;

if ( yy_next_state )
{
/* Consume the NUL. */
yy_cp = ï¬¬ï¿½>yy_c_buf_p;
yy_current_state = yy_next_state;
goto yy_match;
}

else
{
yy_cp = yyg->yy_c_buf_p;
goto yy_find_action;
}
}

else switch ( yy_get_next_buffer( yyscanner ) )
{
case EOB_ACT_END_OF_FILE:
{
yyg->yy_did_buffer_switch_on_eof = 0;

if ( cmListFileLexer_yywrap(yyscanner ) )
{
/* Note: because we've taken care in
 * yy_get_next_buffer() to have set up
 * yytext, we can now set up
 * yy_c_buf_p so that if some total
 * hoser (like flex itself) wants to
 * call the scanner after we return the
 * YY_NULL, it'll still work - another
 * YY_NULL will get returned.
 */
yyg->yy_c_buf_p = yyg->yytext_ptr  YY_MORE_ADJ;

yy_act = YY_STATE_EOF(YY_START);
goto do_action;
}

else
{
if ( ! yyg->yy_did_buffer_switch_on_eof )
YY_NEW_FILE;
}
break;
}

case EOB_ACT_CONTINUE_SCAN:
yyg->yy_c_buf_p =
yyg->yytext_ptr  yy_amount_of_matched_text;

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_match;

case EOB_ACT_LAST_MATCH:
yyg->yy_c_buf_p =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

yy_current_state = yy_get_previous_state( yyscanner );

yy_cp = yyg->yy_c_buf_p;
yy_bp = yyg->yytext_ptr  YY_MORE_ADJ;
goto yy_find_action;
}
break;
}

default:
YY_FATAL_ERROR(
""fatal flex scanner internal error--no action found"" );
} /* end of action switch */
} /* end of scanning one token */
} /* end of user's declarations */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *EOB_ACT_LAST_MATCH -
 *EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
char *source = yyg->yytext_ptr;
yy_size_t number_to_move, i;
int ret_val;

if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] )
YY_FATAL_ERROR(
""fatal flex scanner internal error--end of buffer missed"" );

if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
{ /* Don't try to fill the buffer, so this is an EOF. */
if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
{
/* We matched a single character, the EOB, so
 * treat this as a final EOF.
 */
return EOB_ACT_END_OF_FILE;
}

else
{
/* We matched some text prior to the EOB, first
 * process it.
 */
return EOB_ACT_LAST_MATCH;
}
}

/* Try to read more data. */

/* First move last chars to start of buffer. */
number_to_move = (yy_size_t) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

for ( i = 0; i < number_to_move; ï¿½ )
*(destï¿½) = *(sourceï¿½);

if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
/* don't do the read, it's not guaranteed to return an EOF,
 * just force an EOF
 */
YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

else
{
yy_size_t num_to_read =
YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

while ( num_to_read <= 0 )
{ /* Not enough room in the buffer - grow it. */

/* just a shorter name for the current buffer */
YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

int yy_c_buf_p_offset =
(int) (yyg->yy_c_buf_p - b->yy_ch_buf);

if ( b->yy_is_our_buffer )
{
yy_size_t new_size = b->yy_buf_size * 2;

if ( new_size <= 0 )
b->yy_buf_size = b->yy_buf_size / 8;
else
b->yy_buf_size *= 2;

b->yy_ch_buf = (char *)
/* Include room in for 2 EOB chars. */
cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size  2 ,yyscanner );
}
else
/* Can't grow it, we don't own it. */
b->yy_ch_buf = 0;

if ( ! b->yy_ch_buf )
YY_FATAL_ERROR(
""fatal error - scanner input buffer overflow"" );

yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
number_to_move - 1;

}

if ( num_to_read > YY_READ_BUF_SIZE )
num_to_read = YY_READ_BUF_SIZE;

/* Read in more data. */
YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
yyg->yy_n_chars, num_to_read );

YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
}

if ( yyg->yy_n_chars == 0 )
{
if ( number_to_move == YY_MORE_ADJ )
{
ret_val = EOB_ACT_END_OF_FILE;
cmListFileLexer_yyrestart(yyin  ,yyscanner);
}

else
{
ret_val = EOB_ACT_LAST_MATCH;
YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
YY_BUFFER_EOF_PENDING;
}
}

else
ret_val = EOB_ACT_CONTINUE_SCAN;

if ((yyg->yy_n_chars  number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
/* Extend the array by 50%, plus the number we really need. */
int new_size = yyg->yy_n_chars  number_to_move  (yyg->yy_n_chars >> 1);
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
}

yyg->yy_n_chars = number_to_move;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars  1] = YY_END_OF_BUFFER_CHAR;

yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
yy_state_type yy_current_state;
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

yy_current_state = yyg->yy_start;

for ( yy_cp = yyg->yytext_ptr  YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ï¬¬ï¿½_cp )
{
YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
}

return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
char *yy_cp = yyg->yy_c_buf_p;

YY_CHAR yy_c = 1;
if ( yy_accept[yy_current_state] )
{
yyg->yy_last_accepting_state = yy_current_state;
yyg->yy_last_accepting_cpos = yy_cp;
}
while ( yy_chk[yy_base[yy_current_state]  yy_c] != yy_current_state )
{
yy_current_state = (int) yy_def[yy_current_state];
if ( yy_current_state >= 77 )
yy_c = yy_meta[(unsigned int) yy_c];
}
yy_current_state = yy_nxt[yy_base[yy_current_state]  (unsigned int) yy_c];
yy_is_jam = (yy_current_state == 76);

(void)yyg;
return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

/* undo effects of setting up yytext */
*yy_cp = yyg->yy_hold_char;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
{ /* need to shift things up to make room */
/* ï¿½ for EOB chars. */
yy_size_t number_to_move = yyg->yy_n_chars  2;
char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
YY_CURRENT_BUFFER_LVALUE->yy_buf_size  2];
char *source =
&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
*--dest = *--source;

yy_cp = (int) (dest - source);
yy_bp = (int) (dest - source);
YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf  2 )
YY_FATAL_ERROR( ""flex scanner push-back overflow"" );
}

*--yy_cp = (char) c;

    if ( c == '\n' ){
        --yylineno;
    }

yyg->yytext_ptr = yy_bp;
yyg->yy_hold_char = *yy_cp;
yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
",1197,1213,1470,1487,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_340.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_340.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_380.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_380.cpp," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1692,1756,1699,1763,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_341.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_341.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_380.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_380.cpp," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
"," */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;

b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
if ( ! b )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_buf_size = (yy_size_t)size;

/* yy_ch_buf has to be 2 characters longer than the size given because
 * we need to put in 2 end-of-buffer characters.
 */
b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size  2 ,yyscanner );
if ( ! b->yy_ch_buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

b->yy_is_our_buffer = 1;

cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

return b;
}

/** Destroy the buffer.
",1692,1756,1708,1772,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_342.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_342.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_381.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_381.cpp,"void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmListFileLexer_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmListFileLexer_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1831,1895,1867,1931,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_343.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_343.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_381.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_381.cpp,"void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmListFileLexer_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
","void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
if (!YY_CURRENT_BUFFER)
return;

cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
YY_CURRENT_BUFFER_LVALUE = NULL;
if (yyg->yy_buffer_stack_top > 0)
--yyg->yy_buffer_stack_top;

if (YY_CURRENT_BUFFER) {
cmListFileLexer_yy_load_buffer_state(yyscanner );
yyg->yy_did_buffer_switch_on_eof = 1;
}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

if (!yyg->yy_buffer_stack) {

/* First allocation is just for 2 elements, since we don't know if this
 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 * immediate realloc on the next call.
         */
num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
(num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

yyg->yy_buffer_stack_max = num_to_alloc;
yyg->yy_buffer_stack_top = 0;
return;
}

if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

/* Increase the buffer to prepare for a possible push. */
yy_size_t grow_size = 8 /* arbitrary grow size */;

num_to_alloc = yyg->yy_buffer_stack_max  grow_size;
yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
(yyg->yy_buffer_stack,
num_to_alloc * sizeof(struct yy_buffer_state*)
, yyscanner);
if ( ! yyg->yy_buffer_stack )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

/* zero only the new slots.*/
memset(yyg->yy_buffer_stack  yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
yyg->yy_buffer_stack_max = num_to_alloc;
}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
",1831,1895,1887,1951,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_344.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_344.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_383.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_383.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < _yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
",1948,2012,1962,2026,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_345.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_345.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_383.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_383.cpp," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len  2;
        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ï¿½ )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
"," * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
{
YY_BUFFER_STATE b;
char *buf;
yy_size_t n;
yy_size_t i;

/* Get memory for full buffer, including space for trailing EOB's. */
n = _yybytes_len  2;
buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
if ( ! buf )
YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

for ( i = 0; i < _yybytes_len; ï¿½ )
buf[i] = yybytes[i];

buf[_yybytes_len] = buf[_yybytes_lenï¿½] = YY_END_OF_BUFFER_CHAR;

b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
if ( ! b )
YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

/* It's okay to grow etc. this buffer, and we should throw it
 * away when we're done.
 */
b->yy_is_our_buffer = 1;

return b;
}

#ifndef YY_EXIT_FAILURE
",1948,2012,1971,2035,"YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" )","YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_346.cpp,"YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" )",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_346.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_384.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_384.cpp,"
static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
        (void)yyscanner;
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

","
static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
(void)yyg;
(void) fprintf( stderr, ""%s\n"", msg );
exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
do \
{ \
/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
yytext[yyleng] = yyg->yy_hold_char; \
yyg->yy_c_buf_p = yytext  yyless_macro_arg; \
yyg->yy_hold_char = *yyg->yy_c_buf_p; \
*yyg->yy_c_buf_p = '\0'; \
yyleng = yyless_macro_arg; \
} \
while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

",1984,2048,1988,2053,"(void) fprintf( stderr, ""%s\n"", msg )","(void) fprintf( stderr, ""%s\n"", msg )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_347.cpp,"{
        (void)yyscanner;
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_347.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_385.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_385.cpp,"}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
",2091,2156,2103,2168,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_348.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_348.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_208.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_385.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_385.cpp,"}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
","}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );

    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );

    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void cmListFileLexer_yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
",2091,2156,2118,2183,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" )",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_349.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_349.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_212.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_392.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_392.cpp,"while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO)
break;/* no more hole */
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
","while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO) {
/* no more hole */
if (archive_entry_sparse_count(entry) == 0) {
/* Potentially a fully-sparse file. */
check_fully_sparse = 1;
}
break;
}
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
",1191,1197,1196,1208,"archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"")","archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_350.cpp,"{
			if (errno == ENXIO)
				break;/* no more hole */
			archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"");
			exit_sts = ARCHIVE_FAILED;
			goto exit_setup_sparse;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_350.cpp,"[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_393.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_393.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(tree_current_access_path(t), &svfs);
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(tree_current_access_path(t), &svfs);
#endif
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
#if defined(HAVE_FSTATVFS)
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
#endif
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
",1708,1724,1708,1724,"archive_set_error(&a->archive, errno, ""fchdir failed"");","archive_set_error(&a->archive, errno, ""fchdir failed"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_351.cpp,"{
			archive_set_error(&a->archive, errno, ""fchdir failed"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_351.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_213.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_394.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_394.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(""."", &svfs);
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(""."", &svfs);
#endif
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
",1724,1744,1724,1744,"archive_set_error(&a->archive, errno, ""fchdir failed"");","archive_set_error(&a->archive, errno, ""fchdir failed"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_352.cpp,"{
			archive_set_error(&a->archive, errno, ""fchdir failed"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_352.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_395.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_395.cpp,"struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t len;
int r;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",852,856,859,863,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_353.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_353.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_214.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_396.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_396.cpp,"*last_entry = entry;

if (is_form_d) {
/*
 * This form places the file name as last parameter.
 */
name = line  line_len -1;
while (line_len > 0) {
if (*name != '\r' && *name != '\n' &&
    *name != '\t' && *name != ' ')
break;
name--;
line_len--;
}
len = 0;
while (line_len > 0) {
if (*name == '\r' || *name == '\n' ||
    *name == '\t' || *name == ' ') {
nameï¿½;
break;
}
name--;
line_len--;
lenï¿½;
}
end = name;
} else {
len = strcspn(line, "" \t\r\n"");
name = line;
line = len;
end = line  line_len;
}

if ((entry->name = malloc(len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, len);
entry->name[len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
","*last_entry = entry;

if (is_form_d) {
/* Filename is last item on line. */
/* Adjust line_len to trim trailing whitespace */
while (line_len > 0) {
char last_character = line[line_len - 1];
if (last_character == '\r'
    || last_character == '\n'
    || last_character == '\t'
    || last_character == ' ') {
line_len--;
} else {
break;
}
}
/* Name starts after the last whitespace separator */
name = line;
for (i = 0; i < line_len; iï¿½) {
if (line[i] == '\r'
    || line[i] == '\n'
    || line[i] == '\t'
    || line[i] == ' ') {
name = line  i  1;
}
}
name_len = line  line_len - name;
end = name;
} else {
/* Filename is first item on line */
name_len = strcspn(line, "" \t\r\n"");
name = line;
line = name_len;
end = line  line_len;
}
/* name/name_len is the name within the line. */
/* line..end brackets the entire line except the name */

if ((entry->name = malloc(name_len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, name_len);
entry->name[name_len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
",873,877,907,916,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_354.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_354.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_397.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_397.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1943,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_355.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_355.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_397.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_397.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1947,1944,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_356.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_356.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_215.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_398.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_398.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,1967,1975,"fprintf(stderr, ""unknowntag_end:%s\n"", name)","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_357.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_357.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_216.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_400.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_400.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,848,879,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"")","archive_wstrcat(&s, wp)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_358.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_358.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_402.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_402.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,525,586,"archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")","archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_359.cpp,"{
				archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_359.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_217.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_402.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_402.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,539,562,"archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")","archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_360.cpp,"{
				archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_360.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_403.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_403.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,233,235,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"")","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_361.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_361.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_404.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_404.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,244,246,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"")","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_362.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_362.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_405.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_405.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,336,338,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"")","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_363.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_363.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_218.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_406.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_406.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,375,377,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."")","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_364.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_364.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_407.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_407.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,537,539,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_365.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_365.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_219.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_407.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_407.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,543,545,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_366.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_366.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_221.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_409.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_409.cpp,"while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO)
break;/* no more hole */
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
","while (off_s < size) {
off_s = lseek(*fd, off_s, SEEK_DATA);
if (off_s == (off_t)-1) {
if (errno == ENXIO) {
/* no more hole */
if (archive_entry_sparse_count(entry) == 0) {
/* Potentially a fully-sparse file. */
check_fully_sparse = 1;
}
break;
}
archive_set_error(&a->archive, errno,
    ""lseek(SEEK_HOLE) failed"");
exit_sts = ARCHIVE_FAILED;
",1191,1197,1196,1208,"archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"")","archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_367.cpp,"{
			if (errno == ENXIO)
				break;/* no more hole */
			archive_set_error(&a->archive, errno,
			    ""lseek(SEEK_HOLE) failed"");
			exit_sts = ARCHIVE_FAILED;
			goto exit_setup_sparse;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_367.cpp,"[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_410.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_410.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(tree_current_access_path(t), &svfs);
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(tree_current_access_path(t), &svfs);
#endif
r = statfs(tree_current_access_path(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, tree_current_access_path(t));
#endif
} else {
#ifdef HAVE_FSTATFS
#if defined(HAVE_FSTATVFS)
vr = fstatvfs(tree_current_dir_fd(t), &svfs);
#endif
r = fstatfs(tree_current_dir_fd(t), &sfs);
if (r == 0)
xr = get_xfer_size(t, tree_current_dir_fd(t), NULL);
",1708,1724,1708,1724,"archive_set_error(&a->archive, errno, ""fchdir failed"");","archive_set_error(&a->archive, errno, ""fchdir failed"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_368.cpp,"{
			archive_set_error(&a->archive, errno, ""fchdir failed"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_368.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_411.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_411.cpp,"archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
vr = statvfs(""."", &svfs);
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
","archive_set_error(&a->archive, errno, ""fchdir failed"");
return (ARCHIVE_FAILED);
}
#if defined(HAVE_STATVFS)
vr = statvfs(""."", &svfs);
#endif
r = statfs(""."", &sfs);
if (r == 0)
xr = get_xfer_size(t, -1, ""."");
",1724,1744,1724,1744,"archive_set_error(&a->archive, errno, ""fchdir failed"");","archive_set_error(&a->archive, errno, ""fchdir failed"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_369.cpp,"{
			archive_set_error(&a->archive, errno, ""fchdir failed"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_369.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_412.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_412.cpp,"struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t len;
int r;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
","struct mtree_entry *entry;
struct mtree_option *iter;
const char *next, *eq, *name, *end;
size_t name_len, len;
int r, i;

if ((entry = malloc(sizeof(*entry))) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
",852,856,859,863,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_370.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_370.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_223.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_413.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_413.cpp,"*last_entry = entry;

if (is_form_d) {
/*
 * This form places the file name as last parameter.
 */
name = line  line_len -1;
while (line_len > 0) {
if (*name != '\r' && *name != '\n' &&
    *name != '\t' && *name != ' ')
break;
name--;
line_len--;
}
len = 0;
while (line_len > 0) {
if (*name == '\r' || *name == '\n' ||
    *name == '\t' || *name == ' ') {
nameï¿½;
break;
}
name--;
line_len--;
lenï¿½;
}
end = name;
} else {
len = strcspn(line, "" \t\r\n"");
name = line;
line = len;
end = line  line_len;
}

if ((entry->name = malloc(len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, len);
entry->name[len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
","*last_entry = entry;

if (is_form_d) {
/* Filename is last item on line. */
/* Adjust line_len to trim trailing whitespace */
while (line_len > 0) {
char last_character = line[line_len - 1];
if (last_character == '\r'
    || last_character == '\n'
    || last_character == '\t'
    || last_character == ' ') {
line_len--;
} else {
break;
}
}
/* Name starts after the last whitespace separator */
name = line;
for (i = 0; i < line_len; iï¿½) {
if (line[i] == '\r'
    || line[i] == '\n'
    || line[i] == '\t'
    || line[i] == ' ') {
name = line  i  1;
}
}
name_len = line  line_len - name;
end = name;
} else {
/* Filename is first item on line */
name_len = strcspn(line, "" \t\r\n"");
name = line;
line = name_len;
end = line  line_len;
}
/* name/name_len is the name within the line. */
/* line..end brackets the entire line except the name */

if ((entry->name = malloc(name_len  1)) == NULL) {
archive_set_error(&a->archive, errno, ""Can't allocate memory"");
return (ARCHIVE_FATAL);
}

memcpy(entry->name, name, name_len);
entry->name[name_len] = '\0';
parse_escapes(entry->name, entry);

for (iter = *global; iter != NULL; iter = iter->next) {
",873,877,907,916,"archive_set_error(&a->archive, errno, ""Can't allocate memory"")","archive_set_error(&a->archive, errno, ""Can't allocate memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_371.cpp,"{
		archive_set_error(&a->archive, errno, ""Can't allocate memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_371.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_414.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_414.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1943,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_372.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_372.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_414.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_414.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
","{
struct unknown_tag *tag;

tag = malloc(sizeof(*tag));
if (tag == NULL) {
archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
",1939,1939,1947,1944,"archive_set_error(&a->archive, ENOMEM, ""Out of memory"")","archive_set_error(&a->archive, ENOMEM, ""Out of memory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_373.cpp,"{
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_373.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_224.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_415.cpp,"{
struct unknown_tag *tag;

#if DEBUG
fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL)
xar->xmlsts = xar->xmlsts_unknown;
}
}

","{
struct unknown_tag *tag;

tag = xar->unknowntags;
if (tag == NULL || name == NULL)
return;
if (strcmp(tag->name.s, name) == 0) {
xar->unknowntags = tag->next;
archive_string_free(&(tag->name));
free(tag);
if (xar->unknowntags == NULL) {
#if DEBUG
fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);
#endif
xar->xmlsts = xar->xmlsts_unknown;
}
}
}

",1963,1963,1967,1975,"fprintf(stderr, ""unknowntag_end:%s\n"", name)","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_374.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_374.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_225.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_417.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_417.cpp,"}
}

/* Read the extra data. */
if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return (ARCHIVE_FATAL);
}

process_extra(h, extra_length, zip_entry);
__archive_read_consume(a, extra_length);

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
","}
}

/* Make sure directories end in '/' */
if ((zip_entry->mode & AE_IFMT) == AE_IFDIR) {
wp = archive_entry_pathname_w(entry);
if (wp != NULL) {
len = wcslen(wp);
if (len > 0 && wp[len - 1] != L'/') {
struct archive_wstring s;
archive_string_init(&s);
archive_wstrcat(&s, wp);
archive_wstrappend_wchar(&s, L'/');
archive_entry_copy_pathname_w(entry, s.s);
}
} else {
cp = archive_entry_pathname(entry);
len = (cp != NULL)?strlen(cp):0;
if (len > 0 && cp[len - 1] != '/') {
struct archive_string s;
archive_string_init(&s);
archive_strcat(&s, cp);
archive_strappend_char(&s, '/');
archive_entry_set_pathname(entry, s.s);
}
}
}

if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
/* If this came from the central dir, it's size info
 * is definitive, so ignore the length-at-end flag. */
",843,868,848,879,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"")","archive_wstrcat(&s, wp)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_375.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_375.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_419.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_419.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,525,586,"archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")","archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_376.cpp,"{
				archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_376.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_lz4.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_226.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_419.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_419.cpp,"struct private_data *data = (struct private_data *)f->data;
int outsize;

if (data->compression_level < 3) {
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
} else {
if (data->lz4_stream == NULL) {
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
}

if (outsize) {
","struct private_data *data = (struct private_data *)f->data;
int outsize;

#define DICT_SIZE(64 * 1024)
#ifdef HAVE_LZ4HC_H
if (data->compression_level >= 3) {
if (data->lz4_stream == NULL) {
#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
data->lz4_stream = LZ4_createStreamHC();
LZ4_resetStreamHC(data->lz4_stream, data->compression_level);
#else
data->lz4_stream =
    LZ4_createHC(data->in_buffer_allocated);
#endif
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDictHC(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_HC_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#else
outsize = LZ4_compressHC2_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, data->compression_level);
#endif
} else
#endif
{
if (data->lz4_stream == NULL) {
data->lz4_stream = LZ4_createStream();
if (data->lz4_stream == NULL) {
archive_set_error(f->archive, ENOMEM,
    ""Can't allocate data for compression""
    "" buffer"");
return (ARCHIVE_FATAL);
}
}
else
LZ4_loadDict(data->lz4_stream, data->in_buffer_allocated, DICT_SIZE);

#if LZ4_VERSION_MAJOR >= 1 && LZ4_VERSION_MINOR >= 7
outsize = LZ4_compress_fast_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size, 1);
#else
outsize = LZ4_compress_limitedOutput_continue(
    data->lz4_stream, p, data->out  4, (int)length,
    (int)data->block_size);
#endif
}

if (outsize) {
",518,547,539,562,"archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")","archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_377.cpp,"{
				archive_set_error(f->archive, ENOMEM,
				    ""Can't allocate data for compression""
				    "" buffer"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_377.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_420.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_420.cpp,"    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
","    &data->child_stdout);
if (child == -1) {
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#if defined(_WIN32) && !defined(__CYGWIN__)
",231,233,233,235,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"")","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_378.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_378.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_421.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_421.cpp,"close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't initialise filter"");
return (ARCHIVE_FATAL);
}
#else
","close(data->child_stdout);
data->child_stdout = -1;
archive_set_error(f->archive, EINVAL,
    ""Can't launch external program: %s"", cmd);
return (ARCHIVE_FATAL);
}
#else
",242,244,244,246,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"")","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_379.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_379.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_422.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_422.cpp,"ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to filter"");
return (ARCHIVE_FATAL);
}
length -= ret;
","ret = child_write(f, data, buf, length);
if (ret == -1 || ret == 0) {
archive_set_error(f->archive, EIO,
    ""Can't write to program: %s"", data->program_name);
return (ARCHIVE_FATAL);
}
length -= ret;
",334,336,336,338,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"")","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_380.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_380.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_227.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_423.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_423.cpp,"
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Read from filter failed unexpectedly."");
ret = ARCHIVE_FATAL;
goto cleanup;
}
","
if (bytes_read == -1) {
archive_set_error(f->archive, errno,
    ""Error reading from program: %s"", data->program_name);
ret = ARCHIVE_FATAL;
goto cleanup;
}
",373,375,375,377,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."")","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_381.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_381.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_424.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_424.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,536,539,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_382.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_382.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_228.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_424.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_424.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > ZIP_4GB_MAX)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ZIP_4GB_MAX) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",532,535,542,545,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_383.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_383.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
",486,515,486,515,"fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);","fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_384.cpp,"{
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_384.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
",486,515,490,-1,"f(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str())",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_385.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_385.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_425.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_425.cpp,"      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
","      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    if (targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }
    else // if (targetType == cmState::STATIC_LIBRARY)
      {
      /* Put the static library at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual static library.  */
      fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());
      }
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ï«ï¿½)
      {
",486,515,493,518,"fprintf(fout, ""add_executable(%s"", targetName.c_str())","(targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      }",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_386.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_386.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_426.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_426.cpp,"                symbol.erase(0,1);
                }
              }
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
","                symbol.erase(0,1);
                }
              }
            /*
            Check whether it is ""Scalar deleting destructor"" and
            ""Vector deleting destructor""
",296,298,301,-1,"fprintf(this->FileOut,""EXPORTS \n"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_387.cpp,"{
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_387.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_427.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_427.cpp,"                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",319,317,322,320,"fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str())",this->DataSymbols.insert(symbol),-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_388.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_388.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_427.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_427.cpp,"                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  this->DataSymbols.insert(symbol);
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     this->Symbols.insert(symbol);
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",319,317,326,324,"fprintf(this->FileOut, ""\t%s\n"", symbol.c_str())",this->Symbols.insert(symbol),-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_389.cpp,"{
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_389.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_428.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_428.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

",340,338,345,-1,"fprintf(this->FileOut,""IMPORTS \n"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_390.cpp,"{
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_390.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_230.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_428.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_428.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            this->DataSymbols.insert(symbol);
         }
      }

",340,338,347,341,"fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1)",this->DataSymbols.insert(symbol),-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_391.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_391.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]"
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_429.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_429.cpp,"
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param column_no The column number to set.
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
","
        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmFortran_yyset_column (int  column_no , yyscan_t yyscanner)
",2174,2192,2177,2195,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" )",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_392.cpp,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_392.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_430.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_430.cpp,"
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}
","
        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );

    yycolumn = column_no;
}
",2189,2207,2192,2210,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner)","YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" )",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_393.cpp,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_393.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]"
7f8bb857b8ab714b80acfa6a6e2c34195fabff6f,VS6: Port to cmGeneratorTarget.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_232.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_431.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_431.cpp,"
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmTarget& target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
","
void
cmLocalVisualStudio6Generator
::AddUtilityCommandHack(cmGeneratorTarget *target, int count,
                        std::vector<std::string>& depends,
                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target->GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
",575,570,585,580,"sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count)","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_394.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_394.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_433.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_433.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,954,976,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"")",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_395.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_395.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_434.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_434.cpp,"if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_WARN);
}

/* Copy filename into work buffer. */
","if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_FATAL);
}

/* Copy filename into work buffer. */
",180,180,181,181,"archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"")","archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_396.cpp,"{
		archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_396.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_435.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_435.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,263,270,"archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"")","archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_397.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_397.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_435.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_435.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,268,275,"archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"")","archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_398.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_398.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_436.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_436.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,313,320,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"")","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_399.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_399.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_235.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_437.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_437.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
}

r = archive_entry_copy_pathname_l(entry,
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
return (ARCHIVE_FATAL);
}

r = archive_entry_copy_pathname_l(entry,
",1225,1225,1225,1225,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_400.cpp,"{
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"");
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_400.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_438.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_438.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,1396,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_401.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_401.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_439.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_439.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,1486,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_402.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_402.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_441.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_441.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,1219,1220,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry))","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_403.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_403.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_442.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_442.cpp,"    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argcï¿½] = mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
","    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argcï¿½] = (unsigned long)mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
",1370,1376,1375,1381,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"")","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_404.cpp,"{
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_404.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_443.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_443.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,1609,1620,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val)","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_405.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_405.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_238.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_445.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_445.cpp,"{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
","{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  code->numentries = 0;
  code->numallocatedentries = 0;
  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
",2406,2408,2410,2414,"archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."")","archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_406.cpp,"{
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_406.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_446.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_446.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",248,418,259,429,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize)","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_407.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_407.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_448.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_448.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",748,980,751,983,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression))","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_408.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_408.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_449.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_449.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1037,1790,1042,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_409.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_409.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_451.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_451.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)malloc(sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}
memset(zip, 0, sizeof(*zip));

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)calloc(1, sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
",1427,2223,1432,2228,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_410.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_410.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_239.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_452.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_452.cpp,"/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
if ((p = __archive_read_ahead(a, filename_length  extra_length, NULL))
    == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
","/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
p = __archive_read_ahead(a, filename_length  extra_length,
NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
",1823,2626,1828,2632,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_411.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_411.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_240.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_453.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_453.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,239,255,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size)","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_412.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_412.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_454.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_454.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,1469,1470,"archive_set_error(&a->archive, 0,
		    ""Write request too large"")","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_413.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_413.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_455.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_455.cpp,"
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
","
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
",1940,1954,1944,1960,"archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"")","archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_414.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_414.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_456.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_456.cpp,"en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
","en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
",1950,1966,1954,1972,"archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"")","archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_415.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_415.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_457.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_457.cpp," * impact.
 */
if (lchmod(a->name, mode) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
#endif
} else if (!S_ISDIR(a->mode)) {
"," * impact.
 */
if (lchmod(a->name, mode) != 0) {
switch (errno) {
case ENOTSUP:
case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
case EOPNOTSUPP:
#endif
/*
 * if lchmod is defined but the platform
 * doesn't support it, silently ignore
 * error
 */
break;
default:
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
}
#endif
} else if (!S_ISDIR(a->mode)) {
",3056,3082,3059,3098,"archive_set_error(&a->archive, errno,
			    ""Can't set permissions to 0%o"", (int)mode)","archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_416.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Can't set permissions to 0%o"", (int)mode);
			r = ARCHIVE_WARN;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_416.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_459.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_459.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",425,532,429,537,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_417.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_417.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_459.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_459.cpp,"if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) > 0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > 0xffffffff) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
","if (zip->flags & ZIP_FLAG_AVOID_ZIP64) {
/* Reject entries over 4GB. */
if (archive_entry_size_is_set(entry)
    && (archive_entry_size(entry) >
ARCHIVE_LITERAL_LL(0xffffffff))) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Files > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
}
/* Reject entries if archive is > 4GB. */
if (zip->written_bytes > ARCHIVE_LITERAL_LL(0xffffffff)) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Archives > 4GB require Zip64 extensions"");
return ARCHIVE_FAILED;
",425,532,435,543,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_418.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");
			return ARCHIVE_FAILED;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_418.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_460.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_460.cpp,"zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, Z_DEFAULT_COMPRESSION,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
","zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, zip->deflate_compression_level,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
",758,986,763,991,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"")","archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_419.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_419.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_463.cpp,"if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format_read_data_block function registered"");
return (ARCHIVE_FATAL);
}

","if (a->format->read_data == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
    ""Internal error: ""
    ""No format->read_data function registered"");
return (ARCHIVE_FATAL);
}

",953,975,954,976,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"")","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"")",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_420.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_420.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_464.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_464.cpp,"if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_WARN);
}

/* Copy filename into work buffer. */
","if (strncmp(h  AR_fmag_offset, ""`\n"", 2) != 0) {
archive_set_error(&a->archive, EINVAL,
    ""Incorrect file header signature"");
return (ARCHIVE_FATAL);
}

/* Copy filename into work buffer. */
",180,180,181,181,"archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"")","archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_421.cpp,"{
		archive_set_error(&a->archive, EINVAL,
		    ""Incorrect file header signature"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_421.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_465.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_465.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,263,270,"archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"")","archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_422.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Invalid string table"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_422.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_465.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_465.cpp,"if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_WARN);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_WARN);
}

/* Read the filename table into memory. */
","if (entry_size == 0) {
archive_set_error(&a->archive, EINVAL,
    ""Invalid string table"");
return (ARCHIVE_FATAL);
}
if (ar->strtab != NULL) {
archive_set_error(&a->archive, EINVAL,
    ""More than one string tables exist"");
return (ARCHIVE_FATAL);
}

/* Read the filename table into memory. */
",262,269,268,275,"archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"")","archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_423.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""More than one string tables exist"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_423.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_466.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_466.cpp," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_WARN);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
"," */
if (ar->strtab == NULL || number > ar->strtab_size) {
archive_set_error(&a->archive, EINVAL,
    ""Can't find long filename for GNU/SVR4 archive entry"");
archive_entry_copy_pathname(entry, filename);
/* Parse the time, owner, mode, size fields. */
ar_parse_common_header(ar, entry, h);
return (ARCHIVE_FATAL);
}

archive_entry_copy_pathname(entry, &ar->strtab[(size_t)number]);
",311,318,313,320,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"")","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_424.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_424.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_246.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_467.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_467.cpp,"archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
}

r = archive_entry_copy_pathname_l(entry,
","archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Pathname is too long"");
return (ARCHIVE_FATAL);
}

r = archive_entry_copy_pathname_l(entry,
",1225,1225,1225,1225,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_425.cpp,"{
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Pathname is too long"");
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_425.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_468.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_468.cpp,"lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
if (!lha->end_of_entry_cleanup) {
if ((lha->setflag & CRC_IS_SET) &&
    lha->crc != lha->entry_crc_calculated) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""LHa data CRC error"");
return (ARCHIVE_WARN);
}

/* End-of-entry cleanup done. */
lha->end_of_entry_cleanup = 1;
}
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (ARCHIVE_EOF);
}

if (lha->entry_is_compressed)
","lha->entry_unconsumed = 0;
}
if (lha->end_of_entry) {
*offset = lha->entry_offset;
*size = 0;
*buff = NULL;
return (lha_end_of_entry(a));
}

if (lha->entry_is_compressed)
",1390,1374,1396,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_426.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_426.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_247.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_469.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_469.cpp,"ssize_t bytes_avail;
int r;

/* If the buffer hasn't been allocated, allocate it now. */
if (lha->uncompressed_buffer == NULL) {
lha->uncompressed_buffer_size = 64 * 1024;
lha->uncompressed_buffer
    = (unsigned char *)malloc(lha->uncompressed_buffer_size);
if (lha->uncompressed_buffer == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""No memory for lzh decompression"");
return (ARCHIVE_FATAL);
}
}

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
","ssize_t bytes_avail;
int r;

/* If we haven't yet read any data, initialize the decompressor. */
if (!lha->decompress_init) {
r = lzh_decode_init(&(lha->strm), lha->method);
",1477,1449,1486,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_427.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_427.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_471.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_471.cpp,"}

/*
 * Check for a mismatch between the type in the specification and
 * the type of the contents object on disk.
 */
if (st != NULL) {
if (
((st->st_mode & S_IFMT) == S_IFREG &&
 archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
|| ((st->st_mode & S_IFMT) == S_IFLNK &&
archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
|| ((st->st_mode & S_IFSOCK) == S_IFSOCK &&
archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
|| ((st->st_mode & S_IFMT) == S_IFCHR &&
archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
|| ((st->st_mode & S_IFMT) == S_IFBLK &&
archive_entry_filetype(entry) == AE_IFBLK)
#endif
|| ((st->st_mode & S_IFMT) == S_IFDIR &&
archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
|| ((st->st_mode & S_IFMT) == S_IFIFO &&
archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional entry
   to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""mtree specification has different type for %s"",
archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return r;
}
}

/*
 * If there is a contents file on disk, pick some of the metadata
 * from that file.  For most of these, we only set it from the contents
 * if it wasn't already parsed from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME)) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
","}

/*
 * Check for a mismatch between the type in the specification
 * and the type of the contents object on disk.
 */
if (st != NULL) {
if (((st->st_mode & S_IFMT) == S_IFREG &&
      archive_entry_filetype(entry) == AE_IFREG)
#ifdef S_IFLNK
  ||((st->st_mode & S_IFMT) == S_IFLNK &&
      archive_entry_filetype(entry) == AE_IFLNK)
#endif
#ifdef S_IFSOCK
  ||((st->st_mode & S_IFSOCK) == S_IFSOCK &&
      archive_entry_filetype(entry) == AE_IFSOCK)
#endif
#ifdef S_IFCHR
  ||((st->st_mode & S_IFMT) == S_IFCHR &&
      archive_entry_filetype(entry) == AE_IFCHR)
#endif
#ifdef S_IFBLK
  ||((st->st_mode & S_IFMT) == S_IFBLK &&
      archive_entry_filetype(entry) == AE_IFBLK)
#endif
  ||((st->st_mode & S_IFMT) == S_IFDIR &&
      archive_entry_filetype(entry) == AE_IFDIR)
#ifdef S_IFIFO
  ||((st->st_mode & S_IFMT) == S_IFIFO &&
      archive_entry_filetype(entry) == AE_IFIFO)
#endif
) {
/* Types match. */
} else {
/* Types don't match; bail out gracefully. */
if (mtree->fd >= 0)
close(mtree->fd);
mtree->fd = -1;
if (parsed_kws & MTREE_HAS_OPTIONAL) {
/* It's not an error for an optional
 * entry to not match disk. */
*use_next = 1;
} else if (r == ARCHIVE_OK) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""mtree specification has different""
    "" type for %s"",
    archive_entry_pathname(entry));
r = ARCHIVE_WARN;
}
return (r);
}
}

/*
 * If there is a contents file on disk, pick some of the
 * metadata from that file.  For most of these, we only
 * set it from the contents if it wasn't already parsed
 * from the specification.
 */
if (st != NULL) {
if (((parsed_kws & MTREE_HAS_DEVICE) == 0 ||
(parsed_kws & MTREE_HAS_NOCHANGE) != 0) &&
(archive_entry_filetype(entry) == AE_IFCHR ||
 archive_entry_filetype(entry) == AE_IFBLK))
archive_entry_set_rdev(entry, st->st_rdev);
if ((parsed_kws & (MTREE_HAS_GID | MTREE_HAS_GNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_gid(entry, st->st_gid);
if ((parsed_kws & (MTREE_HAS_UID | MTREE_HAS_UNAME))
== 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0)
archive_entry_set_uid(entry, st->st_uid);
if ((parsed_kws & MTREE_HAS_MTIME) == 0 ||
    (parsed_kws & MTREE_HAS_NOCHANGE) != 0) {
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
archive_entry_set_mtime(entry, st->st_mtime,
st->st_mtimespec.tv_nsec);
",1175,1177,1219,1220,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry))","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_428.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_428.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_472.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_472.cpp,"    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argcï¿½] = mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
","    ""Missing number"");
return ARCHIVE_WARN;
}
numbers[argcï¿½] = (unsigned long)mtree_atol(&p);
if (argc > MAX_PACK_ARGS) {
archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Too many arguments"");
",1370,1376,1375,1381,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"")","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_429.cpp,"{
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_429.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_473.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_473.cpp,"}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry, AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry, AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry, AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry, AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry, AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
","}
case 'c':
if (strcmp(val, ""char"") == 0) {
archive_entry_set_filetype(entry,
AE_IFCHR);
break;
}
case 'd':
if (strcmp(val, ""dir"") == 0) {
archive_entry_set_filetype(entry,
AE_IFDIR);
break;
}
case 'f':
if (strcmp(val, ""fifo"") == 0) {
archive_entry_set_filetype(entry,
AE_IFIFO);
break;
}
if (strcmp(val, ""file"") == 0) {
archive_entry_set_filetype(entry,
AE_IFREG);
break;
}
case 'l':
if (strcmp(val, ""link"") == 0) {
archive_entry_set_filetype(entry,
AE_IFLNK);
break;
}
default:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Unrecognized file type \""%s\""; ""
    ""assuming \""file\"""", val);
archive_entry_set_filetype(entry, AE_IFREG);
return (ARCHIVE_WARN);
}
",1583,1589,1609,1620,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val)","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_430.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_430.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_249.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_475.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_475.cpp,"{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
","{
  int i, j, codebits = 0, symbolsleft = numsymbols;

  code->numentries = 0;
  code->numallocatedentries = 0;
  if (new_node(code) < 0) {
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
",2406,2408,2410,2414,"archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."")","archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_431.cpp,"{
    archive_set_error(&a->archive, ENOMEM,
                      ""Unable to allocate memory for node data."");
    return (ARCHIVE_FATAL);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_431.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_476.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_476.cpp,"{
unsigned offset = 0;

while (offset < extra_length - 4)
{
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);
offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
","{
unsigned offset = 0;

while (offset < extra_length - 4) {
unsigned short headerid = archive_le16dec(p  offset);
unsigned short datasize = archive_le16dec(p  offset  2);

offset = 4;
if (offset  datasize > extra_length)
break;
#ifdef DEBUG
fprintf(stderr, ""Header id 0x%04x, length %d\n"",
    headerid, datasize);
#endif
switch (headerid) {
",244,414,255,425,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize)","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize)",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_432.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_432.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_478.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_478.cpp,"zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name;

return (ret);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
","zip->end_of_entry = 1;

/* Set up a more descriptive format name. */
archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
    version / 10, version % 10,
    compression_name(zip->entry->compression));
a->archive.archive_format_name = zip->format_name.s;

return (ret);
}

static int
check_authentication_code(struct archive_read *a, const void *_p)
{
struct zip *zip = (struct zip *)(a->format->data);

/* Check authentication code. */
if (zip->hctx_valid) {
const void *p;
uint8_t hmac[20];
size_t hmac_len = 20;
int cmp;

archive_hmac_sha1_final(&zip->hctx, hmac, &hmac_len);
if (_p == NULL) {
/* Read authentication code. */
p = __archive_read_ahead(a, AUTH_CODE_SIZE, NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file data"");
return (ARCHIVE_FATAL);
}
} else {
p = _p;
}
cmp = memcmp(hmac, p, AUTH_CODE_SIZE);
__archive_read_consume(a, AUTH_CODE_SIZE);
if (cmp != 0) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""ZIP bad Authentication code"");
return (ARCHIVE_WARN);
}
}
return (ARCHIVE_OK);
}

/*
 * Read ""uncompressed"" data.  There are three cases:
 *  1) We know the size of the data.  This is always true for the
",744,976,747,979,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression))","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_433.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_433.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_479.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_479.cpp,"if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

if (zip->entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
zip->has_encrypted_entries = 1;
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Encrypted file is unsupported"");
return (ARCHIVE_FAILED);
}

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
","if (AE_IFREG != (zip->entry->mode & AE_IFMT))
return (ARCHIVE_EOF);

__archive_read_consume(a, zip->unconsumed);
zip->unconsumed = 0;

if (zip->init_decryption) {
zip->has_encrypted_entries = 1;
if (zip->entry->zip_flags & ZIP_STRONG_ENCRYPTED)
r = read_decryption_header(a);
else if (zip->entry->compression == WINZIP_AES_ENCRYPTION)
r = init_WinZip_AES_decryption(a);
else
r = init_traditional_PKWARE_decryption(a);
if (r != ARCHIVE_OK)
return (r);
zip->init_decryption = 0;
}

switch(zip->entry->compression) {
case 0:  /* No compression. */
r =  zip_read_data_none(a, buff, size, offset);
",1033,1786,1038,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_434.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_434.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_481.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_481.cpp,"archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)malloc(sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}
memset(zip, 0, sizeof(*zip));

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
","archive_check_magic(_a, ARCHIVE_READ_MAGIC,
    ARCHIVE_STATE_NEW, ""archive_read_support_format_zip"");

zip = (struct zip *)calloc(1, sizeof(*zip));
if (zip == NULL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate zip data"");
return (ARCHIVE_FATAL);
}

/* Streamable reader doesn't support mac extensions. */
zip->process_mac_extensions = 0;
",1423,2219,1428,2224,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"")","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_435.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip data"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_435.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_250.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_482.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_482.cpp,"/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
if ((p = __archive_read_ahead(a, filename_length  extra_length, NULL))
    == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
","/* We're done with the regular data; get the filename and
 * extra data. */
__archive_read_consume(a, 46);
p = __archive_read_ahead(a, filename_length  extra_length,
NULL);
if (p == NULL) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_FILE_FORMAT,
    ""Truncated ZIP file header"");
return ARCHIVE_FATAL;
}
",1819,2622,1824,2628,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"")","archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_436.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Truncated ZIP file header"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_436.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_251.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_483.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_483.cpp,"{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ)
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
else if (f->code == ARCHIVE_FILTER_LZMA)
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary dize for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
","{
static const lzma_stream lzma_stream_init_data = LZMA_STREAM_INIT;
int ret;
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
lzma_mt mt_options;
#endif

data->stream = lzma_stream_init_data;
data->stream.next_out = data->compressed;
data->stream.avail_out = data->compressed_buffer_size;
if (f->code == ARCHIVE_FILTER_XZ) {
#ifdef HAVE_LZMA_STREAM_ENCODER_MT
if (data->threads != 1) {
bzero(&mt_options, sizeof(mt_options));
mt_options.threads = data->threads;
mt_options.timeout = 300;
mt_options.filters = data->lzmafilters;
mt_options.check = LZMA_CHECK_CRC64;
ret = lzma_stream_encoder_mt(&(data->stream),
    &mt_options);
} else
#endif
ret = lzma_stream_encoder(&(data->stream),
    data->lzmafilters, LZMA_CHECK_CRC64);
} else if (f->code == ARCHIVE_FILTER_LZMA) {
ret = lzma_alone_encoder(&(data->stream), &data->lzma_opt);
} else {/* ARCHIVE_FILTER_LZIP */
int dict_size = data->lzma_opt.dict_size;
int ds, log2dic, wedges;

/* Calculate a coded dictionary size */
if (dict_size < (1 << 12) || dict_size > (1 << 27)) {
archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
    ""Unacceptable dictionary size for lzip: %d"",
    dict_size);
return (ARCHIVE_FATAL);
}
",221,223,239,255,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size)","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_437.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_437.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_484.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_484.cpp,"return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Write request too large"");
return (ARCHIVE_WARN);
}
return (ARCHIVE_OK);
}

static ssize_t
","return (r);
if ((size_t)r < size) {
archive_set_error(&a->archive, 0,
    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
return (ARCHIVE_WARN);
}
#if ARCHIVE_VERSION_NUMBER < 3999000
return (ARCHIVE_OK);
#else
return (size);
#endif
}

static ssize_t
",1467,1468,1469,1470,"archive_set_error(&a->archive, 0,
		    ""Write request too large"")","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_438.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_438.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_485.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_485.cpp,"
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
","
if (!S_ISDIR(a->st.st_mode)) {
/* A non-dir is in the way, unlink it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't unlink already-existing object"");
",1940,1954,1944,1960,"archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"")","archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_439.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_439.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_486.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_486.cpp,"en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
","en = create_filesystem_object(a);
} else if (!S_ISDIR(a->mode)) {
/* A dir is in the way of a non-dir, rmdir it. */
if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
(void)clear_nochange_fflags(a);
if (rmdir(a->name) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't replace existing directory with non-directory"");
",1950,1966,1954,1972,"archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"")","archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_440.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_440.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_487.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_487.cpp," * impact.
 */
if (lchmod(a->name, mode) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
#endif
} else if (!S_ISDIR(a->mode)) {
"," * impact.
 */
if (lchmod(a->name, mode) != 0) {
switch (errno) {
case ENOTSUP:
case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
case EOPNOTSUPP:
#endif
/*
 * if lchmod is defined but the platform
 * doesn't support it, silently ignore
 * error
 */
break;
default:
archive_set_error(&a->archive, errno,
    ""Can't set permissions to 0%o"", (int)mode);
r = ARCHIVE_WARN;
}
}
#endif
} else if (!S_ISDIR(a->mode)) {
",3054,3082,3057,3098,"archive_set_error(&a->archive, errno,
			    ""Can't set permissions to 0%o"", (int)mode)","archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_441.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Can't set permissions to 0%o"", (int)mode);
			r = ARCHIVE_WARN;
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_441.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_489.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_489.cpp,"zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, Z_DEFAULT_COMPRESSION,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
","zip->stream.opaque = Z_NULL;
zip->stream.next_out = zip->buf;
zip->stream.avail_out = (uInt)zip->len_buf;
if (deflateInit2(&zip->stream, zip->deflate_compression_level,
    Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't init deflate compressor"");
",758,983,763,988,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"")","archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_442.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't init deflate compressor"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_442.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
bbef3c2da83b7a69d1f99b21dc92d5506d98fb35,cmLocalGenerator: Add current binary directory accessor.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_255.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_491.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_491.cpp,"                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
","                        const cmCustomCommand& origCommand)
{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                            target.GetName().size()  30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
",578,578,583,583,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count)","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_443.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_443.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
3339a7508e2d90cbc832490e64f593c1ab935097,CTest: Port away from cmLocalGenerator.,[],Source/CTest/cmCTestScriptHandler.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_256.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_492.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_492.cpp,"
void cmCTestScriptHandler::UpdateElapsedTime()
{
  if (this->LocalGenerator)
    {
    // set the current elapsed time
    char timeString[20];
    int itime = static_cast<unsigned int>(cmSystemTools::GetTime()
                                          - this->ScriptStartTime);
    sprintf(timeString,""%i"",itime);
    this->LocalGenerator->GetMakefile()->AddDefinition(""CTEST_ELAPSED_TIME"",
                                                   timeString);
    }
}

","
void cmCTestScriptHandler::UpdateElapsedTime()
{
  if (this->Makefile)
    {
    // set the current elapsed time
    char timeString[20];
    int itime = static_cast<unsigned int>(cmSystemTools::GetTime()
                                          - this->ScriptStartTime);
    sprintf(timeString,""%i"",itime);
    this->Makefile->AddDefinition(""CTEST_ELAPSED_TIME"", timeString);
    }
}

",179,173,188,182,"sprintf(timeString,""%i"",itime)","sprintf(timeString,""%i"",itime)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_444.cpp,"{
    // set the current elapsed time
    char timeString[20];
    int itime = static_cast<unsigned int>(cmSystemTools::GetTime()
                                          - this->ScriptStartTime);
    sprintf(timeString,""%i"",itime);
    this->LocalGenerator->GetMakefile()->AddDefinition(""CTEST_ELAPSED_TIME"",
                                                   timeString);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_444.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 22, 0, 0, 2, 2, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 11, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 6, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]"
2e6063068c94d4045e699fed51e6d1e9af344bbf,"Merge branch 'improve-variable-help-formatting' into revert-cmake-W-options

Resolve conflicts in

 Help/variable/CMAKE_ERROR_DEPRECATED.rst
 Help/variable/CMAKE_WARN_DEPRECATED.rst

by integrating changes from both sides.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_257.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_493.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_493.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1111,1148,1114,1151,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()))","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_445.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_445.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
6c442e5a899e07a85038c4f9c65dfe224ac9485e,"ccmake: Pass format string to 'printw' (#15738)

printw takes a format string as first argument, so don't pass variable
strings to it directly.",[u'https://gitlab.kitware.com/cmake/cmake/issues/15738'],Source/CursesDialog/cmCursesLongMessageForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_258.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_494.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_494.cpp,"  sprintf(versionë§å¹éï¿½, ""%s"", vertmp);
  version[width] = '\0';

  curses_move(y-4,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);
  curses_move(y-3,0);
  printw(version);
  pos_form_cursor(this->Form);
}

","  sprintf(versionë§å¹éï¿½, ""%s"", vertmp);
  version[width] = '\0';

  char fmt_s[] = ""%s"";
  curses_move(y-4,0);
  attron(A_STANDOUT);
  printw(fmt_s, bar);
  attroff(A_STANDOUT);
  curses_move(y-3,0);
  printw(fmt_s, version);
  pos_form_cursor(this->Form);
}

",80,80,80,80,"sprintf(version+sideSpace, ""%s"", vertmp);","sprintf(version+sideSpace, ""%s"", vertmp);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_446.cpp,"{
  int x,y;
  getmaxyx(stdscr, y, x);

  char bar[cmCursesMainForm::MAX_WIDTH];
  size_t size = strlen(this->Title.c_str());
  if ( size >= cmCursesMainForm::MAX_WIDTH )
    {
    size = cmCursesMainForm::MAX_WIDTH-1;
    }
  strncpy(bar, this->Title.c_str(), size);
  for(size_t i=size-1; i<cmCursesMainForm::MAX_WIDTH; i++) bar[i] = ' ';

  int width;
  if (x < cmCursesMainForm::MAX_WIDTH )
    {
    width = x;
    }
  else
    {
    width = cmCursesMainForm::MAX_WIDTH-1;
    }

  bar[width] = '\0';

  char version[cmCursesMainForm::MAX_WIDTH];
  char vertmp[128];
  sprintf(vertmp,""CMake Version %s"", cmVersion::GetCMakeVersion());
  size_t sideSpace = (width-strlen(vertmp));
  for(size_t i=0; i<sideSpace; i++) { version[i] = ' '; }
  sprintf(version+sideSpace, ""%s"", vertmp);
  version[width] = '\0';

  curses_move(y-4,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);
  curses_move(y-3,0);
  printw(version);
  pos_form_cursor(this->Form);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_446.cpp,"[2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 111, 0, 0, 7, 10, 0, 0, 6, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 35, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 7, 0, 4, 2, 1, 0, 16, 0, 0, 18, 0, 23, 0, 2, 0, 0, 2, 0]"
6c442e5a899e07a85038c4f9c65dfe224ac9485e,"ccmake: Pass format string to 'printw' (#15738)

printw takes a format string as first argument, so don't pass variable
strings to it directly.",[u'https://gitlab.kitware.com/cmake/cmake/issues/15738'],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_259.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_495.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_495.cpp,"    }

  curses_move(y-4,0);
  char fmt[512] = ""Press [enter] to edit option"";
  if ( process )
    {
    strcpy(fmt, ""                           "");
    }
  printw(fmt);
  curses_move(y-3,0);
  printw(firstLine);
  curses_move(y-2,0);
  printw(secondLine);
  curses_move(y-1,0);
  printw(thirdLine);

  if (cw)
    {
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);
    curses_move(0,65-static_cast<unsigned int>(strlen(firstLine))-1);
    printw(firstLine);
    }
//    }

","    }

  curses_move(y-4,0);
  char fmt_s[] = ""%s"";
  char fmt[512] = ""Press [enter] to edit option"";
  if ( process )
    {
    strcpy(fmt, ""                           "");
    }
  printw(fmt_s, fmt);
  curses_move(y-3,0);
  printw(fmt_s, firstLine);
  curses_move(y-2,0);
  printw(fmt_s, secondLine);
  curses_move(y-1,0);
  printw(fmt_s, thirdLine);

  if (cw)
    {
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);
    curses_move(0,65-static_cast<unsigned int>(strlen(firstLine))-1);
    printw(fmt_s, firstLine);
    }
//    }

",451,451,469,470,"sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages)","sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_447.cpp,"{
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);
    curses_move(0,65-static_cast<unsigned int>(strlen(firstLine))-1);
    printw(firstLine);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_447.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 13, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]"
db7f069a4b33f3e8b45142b67289e51c142c90b4,"Windows: Fix 64-bit DLL module definition file generation on VS 2015

With 64-bit Windows builds, there is no need to remove the leading
underscore from all the symbols.  This is because it does not have one
in the .obj file unless it is really in the name.  This did not cause
any trouble until VS 2015 which has some system functions that have a
leading underscore that end up in the .def file.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_260.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_496.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_496.cpp,"                  symbol.erase(posAt);
               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
","                  symbol.erase(posAt);
               }
            }
            // For 64 bit builds we don't need to remove _
            if(!this->Is64Bit)
              {
              if (symbol[0] == '_')
                {
                symbol.erase(0,1);
                }
              }
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
",287,288,293,301,"fprintf(this->FileOut,""EXPORTS \n"")","fprintf(this->FileOut,""EXPORTS \n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_448.cpp,"{
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_448.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
c5cc3441b379e2bc6e70efd6dbd530edebbf0024,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_261.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_497.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_497.cpp,"    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sitï¿½ )
      {
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
","    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sitï¿½ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
",604,601,609,606,"sprintf(argument, ""%s"", sit->c_str())","sprintf(argument, ""%s"", sit->c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_449.cpp,"{
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_449.cpp,"[0, 0, 0, 0, 5, 0, 0, 1, 5, 0, 2, 0, 0, 0, 0, 50, 0, 0, 2, 2, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 1, 0, 0, 0, 7, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]"
1b79433a6d7cdd1da1a0af74240f2299c78e4112,"KWSys 2015-08-28 (dc3fdd7f)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ dc3fdd7f | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' cdaf522c..dc3fdd7f
Brad King (9):
      15a16826 Remove include <kwsys/ios/*> and kwsys_ios:: compatibility layer
      a5799c17 Remove unused KWSYS_IOS_USE_{SSTREAM,STRSTREAM_H,STRSTREA_H} checks
      198957cf Remove unused KWSYS_IOS_USE_SSTREAM check
      24d2b60e Remove support for pre-Cï¯ streams
      2a581c30 Remove support for pre-Cï¯ std::string missing operators
      5f3fd465 Remove support for pre-Cï¯ STL
      cded1574 Remove support for pre-Cï¯ STL from hash_map and hash_set
      f130a3ab Remove kwsys/cstddef compatibility header
      dc3fdd7f Remove support for pre-Cï¯ template capabilities",[],CommandLineArguments.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_262.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_498.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_498.cpp,"    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sitï¿½ )
      {
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
","    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sitï¿½ )
      {
      str << std::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
",604,601,609,606,"sprintf(argument, ""%s"", sit->c_str())","sprintf(argument, ""%s"", sit->c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_450.cpp,"{
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, ""%s"", sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""opt""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" opt""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=opt""); break;
        case CommandLineArguments::MULTI_ARGUMENT:  strcat(argument, "" opt opt ...""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_450.cpp,"[0, 0, 0, 0, 5, 0, 0, 1, 5, 0, 2, 0, 0, 0, 0, 50, 0, 0, 2, 2, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 1, 0, 0, 0, 7, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_501.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_501.cpp,"          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
","          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
",1274,1274,1282,1283,"fprintf(out, ""#\n# Fatal libcurl error\n"")","fprintf(out, ""#\n# Fatal libcurl error\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_451.cpp,"{
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_451.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_265.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_502.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_502.cpp,"      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }
  }

","      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

",1286,1287,1287,1288,"f(out, ""%s\n"", format_ptr)","f(out, ""%s\n"", format_ptr)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_452.cpp,"{
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_452.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 5, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_503.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_503.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,185,181,"*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)","*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_453.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_453.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_503.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_503.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,191,188,"DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_454.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_454.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_503.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_503.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,204,201,"*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)","*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_455.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
      authp->done = TRUE;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_455.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 6, 0, 9, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_266.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_503.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_503.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,210,208,"DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_456.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
      authp->done = TRUE;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_456.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 6, 0, 9, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_504.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_504.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,336,305,"fprintf(stderr, ""\n****\n"");","fprintf(stderr, ""\n****\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_457.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_457.cpp,[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_267.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_504.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_504.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,337,306,"fprintf(stderr, ""**** Header %s\n "", header)","fprintf(stderr, ""**** Header %s\n "", header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_458.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_458.cpp,[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_506.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_506.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,395,393,"*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)","*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_459.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_459.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_506.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_506.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,398,396,"DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_460.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_460.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_268.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_507.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_507.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
",409,407,413,411,"*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)","*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_461.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_461.cpp,[]
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_508.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_508.cpp,"    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init() != CURLE_OK) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
","    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init()) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
",243,242,247,246,"DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_462.cpp,"{
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_462.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_509.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_509.cpp,"  idna_init();
#endif

  if(Curl_resolver_global_init() != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
","  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
",265,264,269,268,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_463.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_463.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_510.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_510.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,368,367,"DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_464.cpp,"{
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_464.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_269.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_510.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_510.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,376,375,"DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""))","DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_465.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_465.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_512.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_512.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1944,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_466.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_466.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_512.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_512.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1948,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_467.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_467.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2001,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_468.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_468.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2003,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_469.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_469.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_271.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_513.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_513.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2007,2021,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_470.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_470.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_514.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_514.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,295,299,"snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_471.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct SessionHandle *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode error;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->proxyuser;
    pwd = conn->proxypasswd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_471.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 87, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_514.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_514.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,307,311,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_472.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct SessionHandle *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode error;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->proxyuser;
    pwd = conn->proxypasswd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_472.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 87, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_272.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_515.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_515.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,2158,2202,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range)","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_473.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_473.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_516.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value=0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        headerï¿½;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        headerï¿½;
      if(',' == *header)
        /* allow the list to be comma-separated */
        headerï¿½;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,262,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_474.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_474.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,370,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data))",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_475.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_475.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_273.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_517.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,403,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_476.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_476.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,61,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_477.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_477.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,83,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_478.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_478.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_274.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_518.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_518.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,93,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_479.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_479.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_519.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_519.cpp,"
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

","
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        Curl_add_buffer_free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

",139,139,140,140,"host_port = aprintf(""%s:%hu"", hostname, remote_port)","host_port = aprintf(""%s:%hu"", hostname, remote_port)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_480.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_480.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_520.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_520.cpp,"                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
","                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
",159,159,167,167,"host = aprintf(""Host: %s\r\n"", hostheader)","host = aprintf(""Host: %s\r\n"", hostheader)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_481.cpp,"{
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_481.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/if2ip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_276.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_521.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_521.cpp,"}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          const char *interf, char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;
#endif

  if(getifaddrs(&head) >= 0) {
    for(iface=head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12]="""";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;
#endif
              if(scopeid != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope ID matches the remote address we want to
                   connect to: global (0) for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
","}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          unsigned int remote_scope_id, const char *interf,
                          char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;

#ifndef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  (void) remote_scope_id;
#endif

#endif

  if(getifaddrs(&head) >= 0) {
    for(iface = head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12] = """";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              unsigned int ifscope = Curl_ipv6_scope(iface->ifa_addr);

              if(ifscope != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope matches the remote address we want to
                   connect to: global for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }

              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;

              /* If given, scope id should match. */
              if(remote_scope_id && scopeid != remote_scope_id) {
                if(res == IF2IP_NOT_FOUND)
                  res = IF2IP_AF_NOT_SUPPORTED;

                continue;
              }
#endif
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
",84,114,123,170,"snprintf(scope, sizeof(scope), ""%%%u"", scopeid)","snprintf(scope, sizeof(scope), ""%%%u"", scopeid)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_482.cpp,"snprintf(scope, sizeof(scope), ""%%%u"", scopeid)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_482.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_523.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_523.cpp,"          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
","          ""# http://curl.haxx.se/docs/http-cookies.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);

    for(co = c->cookies; co; co = co->next) {
      if(!co->domain)
        continue;
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
",1274,1274,1282,1283,"fprintf(out, ""#\n# Fatal libcurl error\n"")","fprintf(out, ""#\n# Fatal libcurl error\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_483.cpp,"{
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_483.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/cookie.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_524.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_524.cpp,"      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }
  }

","      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
    }
  }

",1286,1287,1287,1288,"f(out, ""%s\n"", format_ptr)","f(out, ""%s\n"", format_ptr)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_484.cpp,"{
      format_ptr = get_netscape_format(co);
      if(format_ptr == NULL) {
        fprintf(out, ""#\n# Fatal libcurl error\n"");
        if(!use_stdout)
          fclose(out);
        return 1;
      }
      fprintf(out, ""%s\n"", format_ptr);
      free(format_ptr);
      co=co->next;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_484.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 5, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_525.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_525.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,185,181,"*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)","*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_485.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_485.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_525.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_525.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,191,188,"DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_486.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_486.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_525.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_525.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,204,201,"*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)","*allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_487.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
      authp->done = TRUE;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_487.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 6, 0, 9, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_279.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_525.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_525.cpp,"  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    error = Curl_ntlm_create_type1_message(userp, passwdp, ntlm, &base64,
                                           &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    error = Curl_ntlm_create_type3_message(conn->data, userp, passwdp,
                                           ntlm, &base64, &len);
    if(error)
      return error;

    if(base64) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
","  case NTLMSTATE_TYPE1:
  default: /* for the weird cases we (re)start here */
    /* Create a type-1 message */
    result = Curl_sasl_create_ntlm_type1_message(userp, passwdp, ntlm, &base64,
                                                 &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    }
    break;

  case NTLMSTATE_TYPE2:
    /* We already received the type-2 message, create a type-3 message */
    result = Curl_sasl_create_ntlm_type3_message(conn->data, userp, passwdp,
                                                 ntlm, &base64, &len);
    if(result)
      return result;

    if(base64) {
      free(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;

      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
",175,171,210,208,"DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_488.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy ? ""Proxy-"" : """",
                              base64);
      free(base64);
      if(!*allocuserpwd)
        return CURLE_OUT_OF_MEMORY;
      DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));

      ntlm->state = NTLMSTATE_TYPE3; /* we send a type-3 */
      authp->done = TRUE;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_488.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 5, 0, 0, 6, 0, 9, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_526.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_526.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,336,305,"fprintf(stderr, ""\n****\n"");","fprintf(stderr, ""\n****\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_489.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_489.cpp,[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_msgs.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_280.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_526.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_526.cpp,"    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });
#endif
  free(buffer);

  return CURLE_OK;
}

#ifdef USE_WINDOWS_SSPI
void Curl_ntlm_sspi_cleanup(struct ntlmdata *ntlm)
{
  Curl_safefree(ntlm->type_2);

  if(ntlm->has_handles) {
    s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
    s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
    ntlm->has_handles = 0;
  }

  ntlm->max_token_length = 0;
  Curl_safefree(ntlm->output_token);

  Curl_sspi_free_identity(ntlm->p_identity);
  ntlm->p_identity = NULL;
}
#endif

#ifndef USE_WINDOWS_SSPI
/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
","    fprintf(stderr, ""\n****\n"");
    fprintf(stderr, ""**** Header %s\n "", header);
  });

  free(type2);

  return result;
}

/* copy the source to the destination and fill in zeroes in every
   other destination byte! */
static void unicodecpy(unsigned char *dest, const char *src, size_t length)
",336,305,337,306,"fprintf(stderr, ""**** Header %s\n "", header)","fprintf(stderr, ""**** Header %s\n "", header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_490.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_490.cpp,[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_528.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_528.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,395,393,"*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)","*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_491.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_491.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_528.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_528.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    Curl_safefree(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
    DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));
    free(conn->response_header);
    conn->response_header = NULL;
    break;
  case NTLMSTATE_TYPE2:
",391,389,398,396,"DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))","DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_492.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_492.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/curl_ntlm_wb.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_281.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_529.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_529.cpp,"    if(res)
      return res;

    Curl_safefree(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
","    if(res)
      return res;

    free(*allocuserpwd);
    *allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header);
",409,407,413,411,"*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)","*allocuserpwd = aprintf(""%sAuthorization: %s\r\n"",
                            proxy ? ""Proxy-"" : """",
                            conn->response_header)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_493.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_493.cpp,[]
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_530.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_530.cpp,"    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init() != CURLE_OK) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
","    }

  if(flags & CURL_GLOBAL_WIN32)
    if(win32_init()) {
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }
",243,242,247,246,"DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_494.cpp,"{
      DEBUGF(fprintf(stderr, ""Error: win32_init failed\n""));
      return CURLE_FAILED_INIT;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_494.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_531.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_531.cpp,"  idna_init();
#endif

  if(Curl_resolver_global_init() != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
","  idna_init();
#endif

  if(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }
",265,264,269,268,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_495.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_495.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_532.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_532.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,368,367,"DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""))","DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_496.cpp,"{
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_496.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/easy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_282.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_532.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_532.cpp," */
CURL *curl_easy_init(void)
{
  CURLcode res;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    res = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(res) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  res = Curl_open(&data);
  if(res != CURLE_OK) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
"," */
CURL *curl_easy_init(void)
{
  CURLcode result;
  struct SessionHandle *data;

  /* Make sure we inited the global SSL stuff */
  if(!initialized) {
    result = curl_global_init(CURL_GLOBAL_DEFAULT);
    if(result) {
      /* something in the global init failed, return nothing */
      DEBUGF(fprintf(stderr, ""Error: curl_global_init failed\n""));
      return NULL;
    }
  }

  /* We use curl_open() with undefined URL so far */
  result = Curl_open(&data);
  if(result) {
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }
",357,356,376,375,"DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""))","DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_497.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: Curl_open failed\n""));
    return NULL;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_497.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_534.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_534.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1944,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_498.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_498.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_534.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_534.cpp,"        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);

          if(conn->bits.tunnel_proxy ||
             conn->proxytype == CURLPROXY_SOCKS5 ||
             conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
             conn->proxytype == CURLPROXY_SOCKS4 ||
             conn->proxytype == CURLPROXY_SOCKS4A)
            /* proxy tunnel -> use other host info because ip_addr_str is the
               proxy address not the ftp host */
            snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);
          else
            /* use the same IP we are already connected to */
            snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);
        }
      }
      else
","        }
        if(ptr) {
          ftpc->newport = (unsigned short)(num & 0xffff);
          ftpc->newhost = strdup(control_address(conn));
          if(!ftpc->newhost)
            return CURLE_OUT_OF_MEMORY;
        }
      }
      else
",1933,1967,1948,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_499.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_499.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2001,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_500.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_500.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2003,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_501.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_501.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_284.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_535.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_535.cpp,"
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the one we used
         for the control connection */
      infof(data, ""Skips %d.%d.%d.%d for data connection, uses %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->ip_addr_str);
      if(conn->bits.tunnel_proxy ||
         conn->proxytype == CURLPROXY_SOCKS5 ||
         conn->proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
         conn->proxytype == CURLPROXY_SOCKS4 ||
         conn->proxytype == CURLPROXY_SOCKS4A)
        /* proxy tunnel -> use other host info because ip_addr_str is the
           proxy address not the ftp host */
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);
      else
        snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);
    }
    else
      snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
","
    /* we got OK from server */
    if(data->set.ftp_skip_ip) {
      /* told to ignore the remotely given IP but instead use the host we used
         for the control connection */
      infof(data, ""Skip %d.%d.%d.%d for data connection, re-use %s instead\n"",
            ip[0], ip[1], ip[2], ip[3],
            conn->host.name);
      ftpc->newhost = strdup(control_address(conn));
    }
    else
      ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);

    if(!ftpc->newhost)
      return CURLE_OUT_OF_MEMORY;

    ftpc->newport = (unsigned short)(((port[0]<<8)  port[1]) & 0xffff);
  }
  else if(ftpc->count1 == 0) {
",1986,2010,2007,2021,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_502.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_502.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_536.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_536.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,295,299,"snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)","snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_503.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct SessionHandle *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode error;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->proxyuser;
    pwd = conn->proxypasswd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_503.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 87, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_536.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_536.cpp,"
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
","
  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
",294,298,307,311,"*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization)","*userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_504.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct SessionHandle *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode error;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->proxyuser;
    pwd = conn->proxypasswd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  error = Curl_base64_encode(data,
                             data->state.buffer, strlen(data->state.buffer),
                             &authorization, &size);
  if(error)
    return error;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  Curl_safefree(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy?""Proxy-"":"""",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_504.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 87, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_285.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_537.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_537.cpp,"    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
","    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
       !Curl_checkheaders(conn, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !Curl_checkheaders(conn, ""Content-Range:"")) {

      /* if a line like this was already allocated, free the previous one */
      free(conn->allocptr.rangeline);

      if(data->set.set_resume_from < 0) {
        /* Upload resume was asked for, but we don't know the size of the
",2153,2198,2158,2202,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range)","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_505.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_505.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_538.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_538.cpp,"
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""curl_md5.h""
#include ""http_digest.h""
#include ""strtok.h""
#include ""curl_memory.h""
#include ""vtls/vtls.h"" /* for Curl_rand() */
#include ""non-ascii.h"" /* included for Curl_convert_... prototypes */
#include ""warnless.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

#define MAX_VALUE_LENGTH 256
#define MAX_CONTENT_LENGTH 1024

static void digest_cleanup_one(struct digestdata *dig);

/*
 * Return 0 on success and then the buffers are filled in fine.
 *
 * Non-zero means failure to parse.
 */
static int get_pair(const char *str, char *value, char *content,
                    const char **endptr)
{
  int c;
  bool starts_with_quote = FALSE;
  bool escape = FALSE;

  for(c=MAX_VALUE_LENGTH-1; (*str && (*str != '=') && c--); )
    *valueï¿½ = *strï¿½;
  *value=0;

  if('=' != *strï¿½)
    /* eek, no match */
    return 1;

  if('\""' == *str) {
    /* this starts with a quote so it must end with one as well! */
    strï¿½;
    starts_with_quote = TRUE;
  }

  for(c=MAX_CONTENT_LENGTH-1; *str && c--; strï¿½) {
    switch(*str) {
    case '\\':
      if(!escape) {
        /* possibly the start of an escaped quote */
        escape = TRUE;
        *contentï¿½ = '\\'; /* even though this is an escape character, we still
                              store it as-is in the target buffer */
        continue;
      }
      break;
    case ',':
      if(!starts_with_quote) {
        /* this signals the end of the content if we didn't get a starting
           quote and then we do ""sloppy"" parsing */
        c=0; /* the end */
        continue;
      }
      break;
    case '\r':
    case '\n':
      /* end of string */
      c=0;
      continue;
    case '\""':
      if(!escape && starts_with_quote) {
        /* end of string */
        c=0;
        continue;
      }
      break;
    }
    escape = FALSE;
    *contentï¿½ = *str;
  }
  *content=0;

  *endptr = str;

  return 0; /* all is fine! */
}

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLdigest Curl_input_digest(struct connectdata *conn,
                             bool proxy,
                             const char *header) /* rest of the *-authenticate:
                                                    header */
{
  char *token = NULL;
  char *tmp = NULL;
  bool foundAuth = FALSE;
  bool foundAuthInt = FALSE;
  struct SessionHandle *data=conn->data;
  bool before = FALSE; /* got a nonce before */
  struct digestdata *d;

  if(proxy) {
    d = &data->state.proxydigest;
  }
  else {
    d = &data->state.digest;
  }

  if(checkprefix(""Digest"", header)) {
    header = strlen(""Digest"");

    /* If we already have received a nonce, keep that in mind */
    if(d->nonce)
      before = TRUE;

    /* clear off any former leftovers and init to defaults */
    digest_cleanup_one(d);

    for(;;) {
      char value[MAX_VALUE_LENGTH];
      char content[MAX_CONTENT_LENGTH];

      while(*header && ISSPACE(*header))
        headerï¿½;

      /* extract a value=content pair */
      if(!get_pair(header, value, content, &header)) {
        if(Curl_raw_equal(value, ""nonce"")) {
          d->nonce = strdup(content);
          if(!d->nonce)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""stale"")) {
          if(Curl_raw_equal(content, ""true"")) {
            d->stale = TRUE;
            d->nc = 1; /* we make a new nonce now */
          }
        }
        else if(Curl_raw_equal(value, ""realm"")) {
          d->realm = strdup(content);
          if(!d->realm)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""opaque"")) {
          d->opaque = strdup(content);
          if(!d->opaque)
            return CURLDIGEST_NOMEM;
        }
        else if(Curl_raw_equal(value, ""qop"")) {
          char *tok_buf;
          /* tokenize the list and choose auth if possible, use a temporary
             clone of the buffer since strtok_r() ruins it */
          tmp = strdup(content);
          if(!tmp)
            return CURLDIGEST_NOMEM;
          token = strtok_r(tmp, "","", &tok_buf);
          while(token != NULL) {
            if(Curl_raw_equal(token, ""auth"")) {
              foundAuth = TRUE;
            }
            else if(Curl_raw_equal(token, ""auth-int"")) {
              foundAuthInt = TRUE;
            }
            token = strtok_r(NULL, "","", &tok_buf);
          }
          free(tmp);
          /*select only auth o auth-int. Otherwise, ignore*/
          if(foundAuth) {
            d->qop = strdup(""auth"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
          else if(foundAuthInt) {
            d->qop = strdup(""auth-int"");
            if(!d->qop)
              return CURLDIGEST_NOMEM;
          }
        }
        else if(Curl_raw_equal(value, ""algorithm"")) {
          d->algorithm = strdup(content);
          if(!d->algorithm)
            return CURLDIGEST_NOMEM;
          if(Curl_raw_equal(content, ""MD5-sess""))
            d->algo = CURLDIGESTALGO_MD5SESS;
          else if(Curl_raw_equal(content, ""MD5""))
            d->algo = CURLDIGESTALGO_MD5;
          else
            return CURLDIGEST_BADALGO;
        }
        else {
          /* unknown specifier, ignore it! */
        }
      }
      else
        break; /* we're done here */

      /* pass all additional spaces here */
      while(*header && ISSPACE(*header))
        headerï¿½;
      if(',' == *header)
        /* allow the list to be comma-separated */
        headerï¿½;
    }
    /* We had a nonce since before, and we got another one now without
       'stale=true'. This means we provided bad credentials in the previous
       request */
    if(before && !d->stale)
      return CURLDIGEST_BAD;

    /* We got this header without a nonce, that's a bad Digest line! */
    if(!d->nonce)
      return CURLDIGEST_BAD;
  }
  else
    /* else not a digest, get out */
    return CURLDIGEST_NONE;

  return CURLDIGEST_FINE;
}

/* convert md5 chunk to RFC2617 (section 3.1.3) -suitable ascii string*/
static void md5_to_ascii(unsigned char *source, /* 16 bytes */
                         unsigned char *dest) /* 33 bytes */
{
  int i;
  for(i=0; i<16; iï¿½)
    snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);
}

/* Perform quoted-string escaping as described in RFC2616 and its errata */
static char *string_quoted(const char *source)
{
  char *dest, *d;
  const char *s = source;
  size_t n = 1; /* null terminator */

  /* Calculate size needed */
  while(*s) {
    ï¿½;
    if(*s == '""' || *s == '\\') {
      ï¿½;
    }
    ï¿½;
  }

  dest = malloc(n);
  if(dest) {
    s = source;
    d = dest;
    while(*s) {
      if(*s == '""' || *s == '\\') {
        *dï¿½ = '\\';
      }
      *dï¿½ = *sï¿½;
    }
    *d = 0;
  }

  return dest;
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
","
#include ""urldata.h""
#include ""rawstr.h""
#include ""curl_sasl.h""
#include ""http_digest.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

/* Test example headers:

WWW-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""
Proxy-Authenticate: Digest realm=""testrealm"", nonce=""1053604598""

*/

CURLcode Curl_input_digest(struct connectdata *conn,
                           bool proxy,
                           const char *header) /* rest of the *-authenticate:
                                                  header */
{
  struct SessionHandle *data = conn->data;

  /* Point to the correct struct with this */
  struct digestdata *digest;

  if(proxy) {
    digest = &data->state.proxydigest;
  }
  else {
    digest = &data->state.digest;
  }

  if(!checkprefix(""Digest"", header))
    return CURLE_BAD_CONTENT_ENCODING;

  header = strlen(""Digest"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  return Curl_sasl_decode_digest_http_message(header, digest);
}

CURLcode Curl_output_digest(struct connectdata *conn,
                            bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath)
{
  CURLcode result;
  struct SessionHandle *data = conn->data;
  unsigned char *path;
  char *tmp;
  char *response;
  size_t len;
  bool have_chlg;

  /* Point to the address of the pointer that holds the string to send to the
     server, which is for a plain host or for a HTTP proxy */
  char **allocuserpwd;

  /* Point to the name and password for this */
  const char *userp;
  const char *passwdp;

  /* Point to the correct struct with this */
  struct digestdata *digest;
  struct auth *authp;

  if(proxy) {
    digest = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    digest = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
",26,26,262,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_506.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_506.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,370,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data))",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_507.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_507.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_286.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_539.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_539.cpp,"
  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
","
  /* not set means empty */
  if(!userp)
    userp = """";

  if(!passwdp)
    passwdp = """";

#if defined(USE_WINDOWS_SSPI)
  have_chlg = digest->input_token ? TRUE : FALSE;
#else
  have_chlg = digest->nonce ? TRUE : FALSE;
#endif

  if(!have_chlg) {
    authp->done = FALSE;
    return CURLE_OK;
  }

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
",352,112,403,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_508.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_508.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,61,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_509.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_509.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,83,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_510.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_510.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_287.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_540.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_540.cpp,"
#include ""curl_setup.h""

#ifdef HAVE_GSSAPI
#ifdef HAVE_OLD_GSSMIT
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#define NCOMPAT 1
#endif

#ifndef CURL_DISABLE_HTTP

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_memory.h""
#include ""url.h""

#define _MPRINTF_REPLACE /* use our functions only */
#include <curl/mprintf.h>

/* The last #include file should be: */
#include ""memdebug.h""

static int
get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service)  1  strlen(proxy ? conn->proxy.name :
                                              conn->host.name)  1;
  if(token.length  1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}

static void
log_gss_error(struct connectdata *conn, OM_uint32 error_status,
              const char *prefix)
{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len  status_string.length  1) {
        snprintf(buf  len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len = status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}

/* returning zero (0) means success, everything else is treated as ""failure""
   with no care exactly what the failure was */
int Curl_input_negotiate(struct connectdata *conn, bool proxy,
                         const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  int ret;
  size_t len;
  size_t rawlen = 0;
  CURLcode error;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return -1;
  }

  if(neg_ctx->server_name == NULL &&
      (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
    return ret;

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    error = Curl_base64_decode(header,
                               (unsigned char **)&input_token.value, &rawlen);
    if(error || rawlen == 0)
      return -1;
    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
","
#include ""curl_setup.h""

#if defined(HAVE_GSSAPI) && !defined(CURL_DISABLE_HTTP) && defined(USE_SPNEGO)

#include ""urldata.h""
#include ""sendf.h""
#include ""curl_gssapi.h""
#include ""rawstr.h""
#include ""curl_base64.h""
#include ""http_negotiate.h""
#include ""curl_sasl.h""
#include ""url.h""
#include ""curl_printf.h""

/* The last #include files should be: */
#include ""curl_memory.h""
#include ""memdebug.h""

CURLcode Curl_input_negotiate(struct connectdata *conn, bool proxy,
                              const char *header)
{
  struct SessionHandle *data = conn->data;
  struct negotiatedata *neg_ctx = proxy?&data->state.proxyneg:
    &data->state.negotiate;
  OM_uint32 major_status, minor_status, discard_st;
  gss_buffer_desc spn_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
  size_t len;
  size_t rawlen = 0;
  CURLcode result;

  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
    /* We finished successfully our part of authentication, but server
     * rejected it (since we're again here). Exit with an error since we
     * can't invent anything better */
    Curl_cleanup_negotiate(data);
    return CURLE_LOGIN_DENIED;
  }

  if(!neg_ctx->server_name) {
    /* Generate our SPN */
    char *spn = Curl_sasl_build_gssapi_spn(
      proxy ? data->set.str[STRING_PROXY_SERVICE_NAME] :
      data->set.str[STRING_SERVICE_NAME],
      proxy ? conn->proxy.name : conn->host.name);
    if(!spn)
      return CURLE_OUT_OF_MEMORY;

    /* Populate the SPN structure */
    spn_token.value = spn;
    spn_token.length = strlen(spn);

    /* Import the SPN */
    major_status = gss_import_name(&minor_status, &spn_token,
                                   GSS_C_NT_HOSTBASED_SERVICE,
                                   &neg_ctx->server_name);
    if(GSS_ERROR(major_status)) {
      Curl_gss_log_error(data, minor_status, ""gss_import_name() failed: "");

      free(spn);

      return CURLE_OUT_OF_MEMORY;
    }

    free(spn);
  }

  header = strlen(""Negotiate"");
  while(*header && ISSPACE(*header))
    headerï¿½;

  len = strlen(header);
  if(len > 0) {
    result = Curl_base64_decode(header, (unsigned char **)&input_token.value,
                                &rawlen);
    if(result)
      return result;

    if(!rawlen) {
      infof(data, ""Negotiate handshake failure (empty challenge message)\n"");

      return CURLE_BAD_CONTENT_ENCODING;
    }

    input_token.length = rawlen;

    DEBUGASSERT(input_token.value != NULL);
",22,22,93,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_511.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_511.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_541.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_541.cpp,"
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

","
      host_port = aprintf(""%s:%hu"", hostname, remote_port);
      if(!host_port) {
        Curl_add_buffer_free(req_buffer);
        return CURLE_OUT_OF_MEMORY;
      }

",139,139,140,140,"host_port = aprintf(""%s:%hu"", hostname, remote_port)","host_port = aprintf(""%s:%hu"", hostname, remote_port)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_512.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_512.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_542.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_542.cpp,"                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
","                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
",159,159,167,167,"host = aprintf(""Host: %s\r\n"", hostheader)","host = aprintf(""Host: %s\r\n"", hostheader)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_513.cpp,"{
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_513.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/if2ip.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_289.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_543.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_543.cpp,"}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          const char *interf, char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;
#endif

  if(getifaddrs(&head) >= 0) {
    for(iface=head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12]="""";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;
#endif
              if(scopeid != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope ID matches the remote address we want to
                   connect to: global (0) for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
","}

if2ip_result_t Curl_if2ip(int af, unsigned int remote_scope,
                          unsigned int remote_scope_id, const char *interf,
                          char *buf, int buf_size)
{
  struct ifaddrs *iface, *head;
  if2ip_result_t res = IF2IP_NOT_FOUND;

#ifndef ENABLE_IPV6
  (void) remote_scope;

#ifndef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  (void) remote_scope_id;
#endif

#endif

  if(getifaddrs(&head) >= 0) {
    for(iface = head; iface != NULL; iface=iface->ifa_next) {
      if(iface->ifa_addr != NULL) {
        if(iface->ifa_addr->sa_family == af) {
          if(curl_strequal(iface->ifa_name, interf)) {
            void *addr;
            char *ip;
            char scope[12] = """";
            char ipstr[64];
#ifdef ENABLE_IPV6
            if(af == AF_INET6) {
              unsigned int scopeid = 0;
              unsigned int ifscope = Curl_ipv6_scope(iface->ifa_addr);

              if(ifscope != remote_scope) {
                /* We are interested only in interface addresses whose
                   scope matches the remote address we want to
                   connect to: global for global, link-local for
                   link-local, etc... */
                if(res == IF2IP_NOT_FOUND) res = IF2IP_AF_NOT_SUPPORTED;
                continue;
              }

              addr = &((struct sockaddr_in6 *)iface->ifa_addr)->sin6_addr;
#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
              /* Include the scope of this interface as part of the address */
              scopeid =
                ((struct sockaddr_in6 *)iface->ifa_addr)->sin6_scope_id;

              /* If given, scope id should match. */
              if(remote_scope_id && scopeid != remote_scope_id) {
                if(res == IF2IP_NOT_FOUND)
                  res = IF2IP_AF_NOT_SUPPORTED;

                continue;
              }
#endif
              if(scopeid)
                snprintf(scope, sizeof(scope), ""%%%u"", scopeid);
            }
",84,114,123,170,"snprintf(scope, sizeof(scope), ""%%%u"", scopeid)","snprintf(scope, sizeof(scope), ""%%%u"", scopeid)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_514.cpp,"snprintf(scope, sizeof(scope), ""%%%u"", scopeid)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_514.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]"
f8be9ba9c258698ed88a7510cf2ba3335491f3da,"cmGlobalGenerator: Base progress on Makefiles, not LocalGenerators.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_545.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_545.cpp,"  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
","  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_MAKEFILES"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
",1148,1148,1151,1151,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()))","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()))",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_515.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_515.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_292.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_546.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_546.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,1900,2018,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError())","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_516.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_516.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_547.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_547.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,73,95,"fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");","fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_517.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_517.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_547.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_547.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,81,99,"fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"")","fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_518.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_518.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_547.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_547.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,82,100,"fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"")","fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_519.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_519.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_549.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_549.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,131,149,"fprintf(stdout, ""Output on stdout after recursive test.\n"")","fprintf(stdout, ""Output on stdout after recursive test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_520.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_520.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_549.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_549.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,132,150,"fprintf(stderr, ""Output on stderr after recursive test.\n"")","fprintf(stderr, ""Output on stderr after recursive test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_521.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_521.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_550.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_550.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,176,190,"fprintf(stdout, ""Output on stdout after sleep.\n"")","fprintf(stdout, ""Output on stdout after sleep.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_522.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_522.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 12, 0, 15, 3, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_550.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_550.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,177,191,"fprintf(stderr, ""Output on stderr after sleep.\n"")","fprintf(stderr, ""Output on stderr after sleep.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_523.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_523.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 12, 0, 15, 3, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_551.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,200,214,"fprintf(stdout, ""Output on stdout after grandchild test.\n"")","fprintf(stdout, ""Output on stdout after grandchild test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_524.cpp,"{
  /* Create a disowned grandchild to test handling of processes
     that exit before their children.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""108"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_524.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_551.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,201,215,"fprintf(stderr, ""Output on stderr after grandchild test.\n"")","fprintf(stderr, ""Output on stderr after grandchild test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_525.cpp,"{
  /* Create a disowned grandchild to test handling of processes
     that exit before their children.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""108"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_525.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_554.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_554.cpp,"      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 8)
    {
    /* This is the parent process for a requested test number.  */
    int states[8] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
","      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
",448,616,453,625,"f(stderr, ""Invalid test number %d.\n"", n)","f(stderr, ""Invalid test number %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_526.cpp,"{
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_526.cpp,"[0, 0, 0, 0, 0, 0, 10, 1, 9, 0, 2, 0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_555.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,515,694,"fprintf(stderr, ""Output on stderr before test %d.\n"", n);","fprintf(stderr, ""Output on stderr before test %d.\n"", n);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_527.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_527.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_555.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,521,701,"fprintf(stdout, ""Output on stdout after test %d.\n"", n)","fprintf(stdout, ""Output on stdout after test %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_528.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_528.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_293.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_555.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,522,702,"fprintf(stderr, ""Output on stderr after test %d.\n"", n)","fprintf(stderr, ""Output on stderr after test %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_529.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_529.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],ProcessWin32.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_294.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_556.cpp,"    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      DWORD original = GetLastError();
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, original,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                          KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }
      }

","    if(cp->ErrorMessage[0] == 0)
      {
      /* Format the error message.  */
      wchar_t err_msg[KWSYSPE_PIPE_BUFFER_SIZE];
      DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                                   FORMAT_MESSAGE_IGNORE_INSERTS, 0, error,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                   err_msg, KWSYSPE_PIPE_BUFFER_SIZE, 0);
      if(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());
        }
      if(!WideCharToMultiByte(CP_UTF8, 0, err_msg, -1, cp->ErrorMessage,
                              KWSYSPE_PIPE_BUFFER_SIZE, NULL, NULL))
        {
        /* WideCharToMultiByte failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());
        }
      }

",1886,2007,1900,2018,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError())","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_530.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_530.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_557.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_557.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,73,95,"fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");","fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_531.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_531.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_557.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_557.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,81,99,"fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"")","fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_532.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_532.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_557.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_557.cpp,"  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
","  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
  testProcess_sleep(15);
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
",73,95,82,100,"fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"")","fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_533.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output before sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output before sleep on stderr from timeout test.\n"");
  fflush(stdout);
  fflush(stderr);
#if defined(_WIN32)
  Sleep(15000);
#else
  sleep(15);
#endif
  fprintf(stdout, ""Output after sleep on stdout from timeout test.\n"");
  fprintf(stderr, ""Output after sleep on stderr from timeout test.\n"");
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_533.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 9, 0, 0, 10, 0, 13, 3, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_559.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_559.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,131,149,"fprintf(stdout, ""Output on stdout after recursive test.\n"")","fprintf(stdout, ""Output on stdout after recursive test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_534.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_534.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_559.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_559.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0, 0, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
",127,145,132,150,"fprintf(stderr, ""Output on stderr after recursive test.\n"")","fprintf(stderr, ""Output on stderr after recursive test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_535.cpp,"{
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""4"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before recursive test.\n"");
  fprintf(stderr, ""Output on stderr before recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Exception,
               kwsysProcess_Exception_Fault, 1, 1, 1, 0, 15, 0, 1, 0);
  fprintf(stdout, ""Output on stdout after recursive test.\n"");
  fprintf(stderr, ""Output on stderr after recursive test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_535.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_560.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_560.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,176,190,"fprintf(stdout, ""Output on stdout after sleep.\n"")","fprintf(stdout, ""Output on stdout after sleep.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_536.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_536.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 12, 0, 15, 3, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_560.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_560.cpp,"  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
  testProcess_sleep(1);
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
",168,186,177,191,"fprintf(stderr, ""Output on stderr after sleep.\n"")","fprintf(stderr, ""Output on stderr after sleep.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_537.cpp,"{
  (void)argc; (void)argv;
  fprintf(stdout, ""Output on stdout before sleep.\n"");
  fprintf(stderr, ""Output on stderr before sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  /* Sleep for 1 second.  */
#if defined(_WIN32)
  Sleep(1000);
#else
  sleep(1);
#endif
  fprintf(stdout, ""Output on stdout after sleep.\n"");
  fprintf(stderr, ""Output on stderr after sleep.\n"");
  fflush(stdout);
  fflush(stderr);
  return 0;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_537.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 12, 0, 15, 3, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_561.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_561.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,200,214,"fprintf(stdout, ""Output on stdout after grandchild test.\n"")","fprintf(stdout, ""Output on stdout after grandchild test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_538.cpp,"{
  /* Create a disowned grandchild to test handling of processes
     that exit before their children.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""108"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_538.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_561.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_561.cpp,"  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
","  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1, 0, 0);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
",196,210,201,215,"fprintf(stderr, ""Output on stderr after grandchild test.\n"")","fprintf(stderr, ""Output on stderr after grandchild test.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_539.cpp,"{
  /* Create a disowned grandchild to test handling of processes
     that exit before their children.  */
  int r;
  const char* cmd[4];
  (void)argc;
  cmd[0] = argv[0];
  cmd[1] = ""run"";
  cmd[2] = ""108"";
  cmd[3] = 0;
  fprintf(stdout, ""Output on stdout before grandchild test.\n"");
  fprintf(stderr, ""Output on stderr before grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  r = runChild(cmd, kwsysProcess_State_Disowned, kwsysProcess_Exception_None,
               1, 1, 1, 0, 10, 0, 1, 1);
  fprintf(stdout, ""Output on stdout after grandchild test.\n"");
  fprintf(stderr, ""Output on stderr after grandchild test.\n"");
  fflush(stdout);
  fflush(stderr);
  return r;
}",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_539.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 39, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 9, 0, 0, 14, 0, 23, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_564.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_564.cpp,"      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 8)
    {
    /* This is the parent process for a requested test number.  */
    int states[8] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
","      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 9: return test9(argc, argv);
      case 10: return test10(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      case 109: return test9_grandchild(argc, argv);
      case 110: return test10_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }
  else if(n >= 1 && n <= 10)
    {
    /* This is the parent process for a requested test number.  */
    int states[10] =
    {
      kwsysProcess_State_Exited,
      kwsysProcess_State_Exited,
",448,616,453,625,"f(stderr, ""Invalid test number %d.\n"", n)","f(stderr, ""Invalid test number %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_540.cpp,"{
    /* This is the child process for a requested test number.  */
    switch (n)
      {
      case 1: return test1(argc, argv);
      case 2: return test2(argc, argv);
      case 3: return test3(argc, argv);
      case 4: return test4(argc, argv);
      case 5: return test5(argc, argv);
      case 6: test6(argc, argv); return 0;
      case 7: return test7(argc, argv);
      case 8: return test8(argc, argv);
      case 108: return test8_grandchild(argc, argv);
      }
    fprintf(stderr, ""Invalid test number %d.\n"", n);
    return 1;
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_540.cpp,"[0, 0, 0, 0, 0, 0, 10, 1, 9, 0, 2, 0, 0, 0, 0, 31, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_565.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_565.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,515,694,"fprintf(stderr, ""Output on stderr before test %d.\n"", n);","fprintf(stderr, ""Output on stderr before test %d.\n"", n);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_541.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_541.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_565.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_565.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,521,701,"fprintf(stdout, ""Output on stdout after test %d.\n"", n)","fprintf(stdout, ""Output on stdout after test %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_542.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_542.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrlï¿½.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrlï¿½ and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],testProcess.c,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_565.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_565.cpp,"    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], 0,
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
","    fprintf(stderr, ""Output on stderr before test %d.\n"", n);
    fflush(stdout);
    fflush(stderr);
    r = runChild(cmd, states[n-1], exceptions[n-1], values[n-1], shares[n-1],
                 outputs[n-1], delays[n-1], timeouts[n-1],
                 polls[n-1], repeat[n-1], 0, createNewGroups[n-1],
                 interruptDelays[n-1]);
    fprintf(stdout, ""Output on stdout after test %d.\n"", n);
    fprintf(stderr, ""Output on stderr after test %d.\n"", n);
    fflush(stdout);
",515,694,522,702,"fprintf(stderr, ""Output on stderr after test %d.\n"", n)","fprintf(stderr, ""Output on stderr after test %d.\n"", n)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_543.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_543.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_566.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_566.cpp,"               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
","               }
            }
            if (symbol[0] == '_') symbol.erase(0,1);
            if (this->ImportFlag) {
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }
            /*
            Check whether it is ""Scalar deleting destructor"" and
",209,288,214,293,"fprintf(fout,""EXPORTS \n"")","fprintf(this->FileOut,""EXPORTS \n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_544.cpp,"{
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_544.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_567.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_567.cpp,"                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",228,307,234,314,"fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str())","fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_545.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_545.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_567.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_567.cpp,"                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                pSectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
","                symbol.compare(0, 4, vectorPrefix) )
            {
               SectChar =
                 this->
                 SectionHeaders[pSymbolTable->SectionNumber-1].Characteristics;
               if (!pSymbolTable->Type  && (SectChar & IMAGE_SCN_MEM_WRITE)) {
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               } else {
                  if ( pSymbolTable->Type  ||
                       !(SectChar & IMAGE_SCN_MEM_READ)) {
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  } else {
                     // printf("" strange symbol: %s \n"",symbol.c_str());
                  }
",228,307,238,318,"fprintf(fout, ""\t%s\n"", symbol.c_str())","fprintf(this->FileOut, ""\t%s\n"", symbol.c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_546.cpp,"{
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_546.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]"
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_568.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_568.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

",252,332,257,337,"fprintf(fout,""IMPORTS \n"")","fprintf(this->FileOut,""IMPORTS \n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_547.cpp,"{
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_547.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_568.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_568.cpp,"            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

","            symbol = stringTable  pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()ï¿½);
         }
      }

",252,332,259,339,"fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1)","fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_548.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_548.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]"
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,312,313,"fprintf(stderr, ""Couldn't open file with CreateFile()\n"")","fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename)",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_549.cpp,"{
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_549.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]"
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,319,320,"fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"")","fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_550.cpp,"{
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_550.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]"
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,327,328,"fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"")","fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_551.cpp,"{
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_551.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]"
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_297.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_569.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_569.cpp,"      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

   if (hFile == INVALID_HANDLE_VALUE) {
      fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);
      return false;
   }

   hFileMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
   if (hFileMapping == 0) {
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't open file mapping with CreateFileMapping()\n"");
      return false;
   }

   lpFileBase = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);
   if (lpFileBase == 0) {
      CloseHandle(hFileMapping);
      CloseHandle(hFile);
      fprintf(stderr, ""Couldn't map view of file with MapViewOfFile()\n"");
      return false;
   }

   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return false;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",309,310,333,334,"fprintf(stderr, ""File is an executable.  I don't dump those.\n"")","fprintf(stderr, ""File is an executable.  I don't dump those.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_552.cpp,"{
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_552.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,264,-1,"fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_553.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_553.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,267,-1,"fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"")",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_554.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_554.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,277,-1,"fprintf(fout, ""%04X "", i)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_555.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_555.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,279,-1,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_556.cpp,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_556.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,281,-1,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_557.cpp,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long)",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_557.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,283,-1,"fprintf(fout, "" %08X"", pSymbolTable->Value)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_558.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_558.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,287,-1,"fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) )",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_559.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_559.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,294,-1,"fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str())",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_560.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_560.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,341,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str())",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_561.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_561.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_571.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_571.cpp,"*----------------------------------------------------------------------
*/

static char sccsid[] = ""@(#) winDumpExts.c 1.2 95/10/03 15:27:34"";

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
*----------------------------------------------------------------------
* GetArgcArgv --
*
*      Break up a line into argc argv
*----------------------------------------------------------------------
*/
int
GetArgcArgv(std::string &s, char **argv)
{
   int quote = 0;
   int argc = 0;
   std::string::iterator bp = s.begin();

   while (1) {
      while (isspace(*bp)) {
         bpï¿½;
      }
      if (*bp == '\n' || *bp == '\0') {
         *bp = '\0';
         return argc;
      }
      if (*bp == '\""') {
         quote = 1;
         bpï¿½;
      }
      argv[argcï¿½] = &(*bp);

      while (*bp != '\0') {
         if (quote) {
            if (*bp == '\""') {
               quote = 0;
               *bp = '\0';
               bpï¿½;
               break;
            }
            bpï¿½;
            continue;
         }
         if (isspace(*bp)) {
            *bp = '\0';
            bpï¿½;
            break;
         }
         bpï¿½;
      }
   }
}

/*
*  The names of the first group of possible symbol table storage classes
*/
char * SzStorageClass1[] = {
   ""NULL"",""AUTOMATIC"",""EXTERNAL"",""STATIC"",""REGISTER"",""EXTERNAL_DEF"",""LABEL"",
   ""UNDEFINED_LABEL"",""MEMBER_OF_STRUCT"",""ARGUMENT"",""STRUCT_TAG"",
   ""MEMBER_OF_UNION"",""UNION_TAG"",""TYPE_DEFINITION"",""UNDEFINED_STATIC"",
   ""ENUM_TAG"",""MEMBER_OF_ENUM"",""REGISTER_PARAM"",""BIT_FIELD""
};

/*
* The names of the second group of possible symbol table storage classes
*/
char * SzStorageClass2[] = {
   ""BLOCK"",""FUNCTION"",""END_OF_STRUCT"",""FILE"",""SECTION"",""WEAK_EXTERNAL""
};

/*
*----------------------------------------------------------------------
* GetSZStorageClass --
*
*      Given a symbol storage class value, return a descriptive
*      ASCII string
*----------------------------------------------------------------------
*/
PSTR
GetSZStorageClass(BYTE storageClass)
{
   if ( storageClass <= IMAGE_SYM_CLASS_BIT_FIELD )
      return SzStorageClass1[storageClass];
   else if ( (storageClass >= IMAGE_SYM_CLASS_BLOCK)
      && (storageClass <= IMAGE_SYM_CLASS_WEAK_EXTERNAL) )
      return SzStorageClass2[storageClass-IMAGE_SYM_CLASS_BLOCK];
   else
      return ""???"";
}

void AddHex(std::string& buf, long val, bool caps=false)
{
   buf = ""0x"";
   size_t len=buf.length();
   while (val) {
      char hex = (char)(val & 16);
      val = val >> 4;
      if (hex<10) hex='0';
      else if (caps) hex='A'-10;
      else hex='a'-10;
      buf.insert(len, hex, 1);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionName --
*
*      Used by DumpSymbolTable, it gives meaningful names to
*      the non-normal section number.
*
* Results:
*      A name is returned in buffer
*----------------------------------------------------------------------
*/
void
GetSectionName(PIMAGE_SYMBOL pSymbolTable, std::string& buffer)
{
   DWORD section;

   section = pSymbolTable->SectionNumber;

   switch ( (SHORT)section )
   {
   case IMAGE_SYM_UNDEFINED: if (pSymbolTable->Value) buffer = ""COMM""; else buffer = ""UNDEF""; break;
   case IMAGE_SYM_ABSOLUTE:  buffer = ""ABS  ""; break;
   case IMAGE_SYM_DEBUG:     buffer = ""DEBUG""; break;
   default: AddHex(buffer, section, true);
   }
}

/*
*----------------------------------------------------------------------
* GetSectionCharacteristics --
*
*      Converts the Characteristics field of IMAGE_SECTION_HEADER
*      to print.
*
*  Results:
*       A definiton of the section symbol type
*----------------------------------------------------------------------
*/
void
GetSectionCharacteristics(PIMAGE_SECTION_HEADER pSectionHeaders, int nSectNum, std::string &buffer)
{
   DWORD SectChar;
   std::string TempBuf;
   buffer.clear();
   if (nSectNum > 0) {
      SectChar = pSectionHeaders[nSectNum-1].Characteristics;

      buffer = "" "";
      AddHex(buffer, SectChar);
      if       (SectChar & IMAGE_SCN_CNT_CODE)                buffer = "" Code"";
      else if  (SectChar & IMAGE_SCN_CNT_INITIALIZED_DATA)    buffer = "" Init. data"";
      else if  (SectChar & IMAGE_SCN_CNT_UNINITIALIZED_DATA ) buffer = "" UnInit data"";
      else                                                    buffer = "" Unknow type"";

      if   (SectChar & IMAGE_SCN_MEM_READ)  {
         buffer = "" Read"";
         if (SectChar & IMAGE_SCN_MEM_WRITE)
            buffer = "" and Write"";
         else buffer = "" only"";
      }
      else if (SectChar & IMAGE_SCN_MEM_WRITE)
         buffer ="" Write only"";

   }
}

/*
*----------------------------------------------------------------------
* DumpSymbolTable --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpSymbolTable(PIMAGE_SYMBOL pSymbolTable, PIMAGE_SECTION_HEADER pSectionHeaders, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable  pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
*----------------------------------------------------------------------
* DumpExternals --
*
*      Dumps a COFF symbol table from an EXE or OBJ.  We only use
*      it to dump tables from OBJs.
*----------------------------------------------------------------------
*/
void
DumpExternals(PIMAGE_SYMBOL pSymbolTable, FILE *fout, unsigned cSymbols)
{
   unsigned i;
   PSTR stringTable;
   std::string symbol;

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; iï¿½ ) {
      if (pSymbolTable->SectionNumber > 0 && pSymbolTable->Type == 0x20) {
         if (pSymbolTable->StorageClass == IMAGE_SYM_CLASS_EXTERNAL) {
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable  pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()ï¿½);
#endif
         }
      }

      /*
      * Take into account any aux symbols
      */
      i = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable = pSymbolTable->NumberOfAuxSymbols;
      pSymbolTableï¿½;
   }
}

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
","*----------------------------------------------------------------------
*/

#include <windows.h>
#include <stdio.h>
#include <string>
#include <fstream>

/*
 * Utility func, strstr with size
 */
const char* StrNStr(const char* start, const char* find, size_t &size) {
",71,71,343,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str()+1)",,-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_562.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_562.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_572.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_572.cpp,"            }

            while (isspace(symbol[0])) symbol.erase(0,1);
#ifdef _MSC_VER
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fort) {
               std::string::size_type posAt = symbol.find('@');
               if (posAt != std::string::npos) symbol.erase(posAt);
            }
#endif
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
","            }

            while (isspace(symbol[0])) symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (fImportFlag) {
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
",470,192,482,198,"fprintf(fout,""EXPORTS \n"")","fprintf(fout,""EXPORTS \n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_563.cpp,"{
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_563.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]"
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_299.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_573.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_573.cpp,"
   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
#if 0
      DumpExeFile( dosHeader );
#else
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
#endif
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
","
   dosHeader = (PIMAGE_DOS_HEADER)lpFileBase;
   if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;
   }
   /* Does it look like a i386 COFF OBJ file??? */
   else if (
",610,317,616,320,"fprintf(stderr, ""File is an executable.  I don't dump those.\n"")","fprintf(stderr, ""File is an executable.  I don't dump those.\n"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_564.cpp,"#if 0
      DumpExeFile( dosHeader );
#else
      fprintf(stderr, ""File is an executable.  I don't dump those.\n"");
      return;",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_564.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 2, 2, 0, 0, 0, 0, 0]"
faec4e611d08ea2f75d2127e3ca3f5e9a427465b,cmComputeTargetDepends: Change API to use cmGeneratorTarget.,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_574.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_574.cpp,"  for(int depender_index = 0; depender_index < n; ï§ê¥ºçï¿½_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ï©¸ï¿½)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
","  for(int depender_index = 0; depender_index < n; ï§ê¥ºçï¿½_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmGeneratorTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ï©¸ï¿½)
      {
      int dependee_index = *ni;
      cmGeneratorTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
",457,464,461,468,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str())","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_565.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_565.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 49, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 9, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]"
faec4e611d08ea2f75d2127e3ca3f5e9a427465b,cmComputeTargetDepends: Change API to use cmGeneratorTarget.,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_574.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_574.cpp,"  for(int depender_index = 0; depender_index < n; ï§ê¥ºçï¿½_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ï©¸ï¿½)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
","  for(int depender_index = 0; depender_index < n; ï§ê¥ºçï¿½_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmGeneratorTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ï©¸ï¿½)
      {
      int dependee_index = *ni;
      cmGeneratorTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }
",457,464,467,474,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"")","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"")",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_566.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_566.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 19, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 4, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]"
f971ab04cfdcb73e1ac2b182caf302172aebe6a8,"cmMacroCommand: Store the FilePath when creating the prototype.

Instead of setting it each time the macro is invoked.",[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_301.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_575.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_575.cpp,"    sprintf(argvName,""${ARGV%i}"",j);
    argVs.push_back(argvName);
    }
  if(!this->Functions.empty())
    {
    this->FilePath = this->Functions[0].FilePath;
    }
  // Invoke all the functions that were collected in the block.
  cmListFileFunction newLFF;
  // for each function
","    sprintf(argvName,""${ARGV%i}"",j);
    argVs.push_back(argvName);
    }
  // Invoke all the functions that were collected in the block.
  cmListFileFunction newLFF;
  // for each function
",122,122,122,122,"sprintf(argvName,""${ARGV%i}"",j);","sprintf(argvName,""${ARGV%i}"",j);",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_567.cpp,"{
    sprintf(argvName,""${ARGV%i}"",j);
    argVs.push_back(argvName);
    }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_567.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]"
59e21ffa134faf0b089d9a704b3763e7f6f237d5,Port static calls from cmLocalGenerator to cmOutputConverter.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_576.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_576.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",322,322,324,324,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str())","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str())",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_568.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_568.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]"
59e21ffa134faf0b089d9a704b3763e7f6f237d5,Port static calls from cmLocalGenerator to cmOutputConverter.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_302.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_576.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_576.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",322,322,326,326,"fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str())","fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str())",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_569.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_569.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]"
9486769866661e3aa76dd588ca5a7466e2969dc3,Don't use a cmLocalGenerator instance to call static methods.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_578.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",323,322,325,324,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str())","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str())",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_570.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_570.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]"
9486769866661e3aa76dd588ca5a7466e2969dc3,Don't use a cmLocalGenerator instance to call static methods.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_304.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_578.cpp,"      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
","      std::string langFlags = ""CMAKE_""  *li  ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
",323,322,327,326,"fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str())","fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str())",1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_571.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_571.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]"
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_579.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_579.cpp,"  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",427,381,427,381,"sprintf(temp, ""%d"", cmVersion::GetMinorVersion());","sprintf(temp, ""%d"", cmVersion::GetMinorVersion());",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_572.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_572.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_579.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_579.cpp,"  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",427,381,431,385,"sprintf(temp, ""%d"", cmVersion::GetMajorVersion())","sprintf(temp, ""%d"", cmVersion::GetMajorVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_573.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_573.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmCacheManager.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_305.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_579.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_579.cpp,"  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmCacheManager::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
","  sprintf(temp, ""%d"", cmVersion::GetMinorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MINOR_VERSION"", temp,
                      ""Minor version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetMajorVersion());
  this->AddCacheEntry(""CMAKE_CACHE_MAJOR_VERSION"", temp,
                      ""Major version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);
  sprintf(temp, ""%d"", cmVersion::GetPatchVersion());
  this->AddCacheEntry(""CMAKE_CACHE_PATCH_VERSION"", temp,
                      ""Patch version of cmake used to create the ""
                      ""current loaded cache"", cmState::INTERNAL);

  // Let us store the current working directory so that if somebody
  // Copies it, he will not be surprised
",427,381,435,389,"sprintf(temp, ""%d"", cmVersion::GetPatchVersion())","sprintf(temp, ""%d"", cmVersion::GetPatchVersion())",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_574.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_574.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
f081c5bdddcfcaaf5bee7b918fe5c7ff01faae35,cmState: Move CacheEntryType enum from cmCacheManager.,[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/Kitware_CMake_old_file_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_file_306.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_old_hunk_580.cpp,second/download/CMake/CMake-old-new/Kitware_CMake_new_hunk_580.cpp,"  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmCacheManager::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
","  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
",1116,1116,1116,1116,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));",-1,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_log_575.cpp,,second/download/CMake/CMake-old-new/Kitware_CMake_old_new_block_575.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]"
