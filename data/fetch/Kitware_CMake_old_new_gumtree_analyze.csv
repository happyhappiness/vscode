sha,message,issue,file_name,old_file,new_file,old_hunk_file,new_hunk_file,old_hunk,new_hunk,old_hunk_loc,new_hunk_loc,old_loc,new_loc,old_log,new_log,action_type,old_log_file,new_log_file,old_block,old_block_file,old_block_feature,old_function_file,old_fucntion_loc
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_1.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_1.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_2.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_0.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_0.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_0.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_0.cpp,58
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_4.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1.cpp,20
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_6.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_6.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_2.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_2.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_2.cpp,15
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_7.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_7.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_3.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_3.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_3.cpp,21
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_4.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_4.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_4.cpp,6
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_9.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_5.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_5.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_5.cpp,9
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_6.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_6.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_12.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_12.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_6.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_6.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_6.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_6.cpp,54
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_14.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_14.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_7.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_7.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_7.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_7.cpp,58
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_16.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_8.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_8.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_8.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_8.cpp,20
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_18.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_18.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_9.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_9.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_9.cpp,15
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_19.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_19.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_10.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_10.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_10.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_10.cpp,21
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_11.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_11.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_11.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_11.cpp,6
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_11.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_11.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_21.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_12.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_12.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_12.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_12.cpp,9
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_13.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_13.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_24.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_13.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_13.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_13.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_13.cpp,54
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_26.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    char header[80];
    snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, header, 0);
    if(result)
      return result;

",475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_14.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_14.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_14.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_14.cpp,58
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_28.cpp,"      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      char *buf = data->state.buffer;
      if(6 == sscanf(bufï¿½, ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
","      /* we got a time. Format should be: ""YYYYMMDDHHMMSS[.sss]"" where the
         last .sss part is optional and means fractions of a second */
      int year, month, day, hour, minute, second;
      if(6 == sscanf(&data->state.buffer[4], ""%04d%02d%02d%02d%02d%02d"",
                     &year, &month, &day, &hour, &minute, &second)) {
        /* we have a time, reformat it */
        char timebuf[24];
        time_t secs=time(NULL);

        snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(timebuf, &secs);
      }

#ifdef CURL_FTP_HTTPSTYLE_HEAD
",2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_15.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_15.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_15.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_15.cpp,20
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_30.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_30.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      char clbuf[128];
      snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, clbuf, 0);
      if(result)
        return result;
    }
",2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_16.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_16.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_16.cpp,15
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_31.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}

/* pickoneauth() selects the most favourable authentication method from the
","    pwd = conn->passwd;
  }

  out = aprintf(""%s:%s"", user, pwd);
  if(!out)
    return CURLE_OUT_OF_MEMORY;

  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  if(result)
    goto fail;

  if(!authorization) {
    result = CURLE_REMOTE_ACCESS_DENIED;
    goto fail;
  }

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp) {
    result = CURLE_OUT_OF_MEMORY;
    goto fail;
  }

  fail:
  free(out);
  return result;
}

/* pickoneauth() selects the most favourable authentication method from the
",297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_17.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_17.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_17.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_17.cpp,21
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_18.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_18.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_18.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_18.cpp,6
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_18.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_18.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_33.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_33.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[ï©ï¿½] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
","{
  va_list ap;
  size_t len;
  char error[CURL_ERROR_SIZE  2];
  va_start(ap, fmt);

  vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  len = strlen(error);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    strcpy(data->set.errorbuffer, error);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    error[len] = '\n';
    error[ï©ï¿½] = '\0';
    Curl_debug(data, CURLINFO_TEXT, error, len, NULL);
  }

  va_end(ap);
",243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_19.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_19.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_19.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_19.cpp,9
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_20.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_36.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_36.cpp,"  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
","  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 32 random hex chars, 32 bytes  1 zero termination */
  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  if(result)
    return result;

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
",387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_20.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_20.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_20.cpp,54
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_39.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2246,2276,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_21.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_21.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_21.cpp,187
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_40.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2123,2145,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_22.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_22.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_22.cpp,80
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_42.cpp,"#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/*--------------------------------------------------------------------------*/
/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
","#endif
#endif
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);
      break;
  }
}
#undef KWSYSPE_CASE

/* When the child process encounters an error before its program is
   invoked, this is called to report the error to the parent and
   exit.  */
",2243,2273,2246,2276,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_23.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_23.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_23.cpp,187
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_27.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_27.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_43.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_43.cpp,"
    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }
}
","
    case STATUS_NO_MEMORY:
    default:
      cp->ProcessResults[idx].ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);
      break;
  }
}
",2120,2142,2123,2145,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_24.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_24.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_24.cpp,80
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_29.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_29.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_45.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_45.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,143,141,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_25.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_25.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_25.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_25.cpp,13
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_46.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,478,477,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_26.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_26.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_26.cpp,58
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_47.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_47.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2109,2109,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_27.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_27.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_27.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_27.cpp,20
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_31.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_48.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2320,2320,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_28.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_28.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_28.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_28.cpp,15
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_50.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_50.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,299,299,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_29.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_29.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_29.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_29.cpp,21
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_38.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_38.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_56.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_56.cpp,"  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}

/* Look up the bundle with all the connections to the same host this
","  else
    hostname = conn->host.name;

  DEBUGASSERT(len > 32);

  /* put the number first so that the hostname gets cut off if too long */
  snprintf(buf, len, ""%ld%s"", conn->port, hostname);
}

/* Look up the bundle with all the connections to the same host this
",141,136,143,141,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_30.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_30.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_30.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_30.cpp,13
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_39.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_39.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_57.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_57.cpp,"    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
","    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
",476,475,478,477,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_31.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_31.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_31.cpp,58
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_58.cpp,"        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
","        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
",2107,2107,2109,2109,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_32.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_32.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_32.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_32.cpp,20
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_59.cpp,"  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
","  if(instate == FTP_SIZE) {
#ifdef CURL_FTP_HTTPSTYLE_HEAD
    if(-1 != filesize) {
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
",2318,2318,2320,2320,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_33.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_33.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_33.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_33.cpp,15
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_41.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_61.cpp,"    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
","    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
",297,297,299,299,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_34.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_34.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_34.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_34.cpp,21
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_76.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,312,324,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_35.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_35.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_35.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_35.cpp,25
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_77.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,785,1496,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_36.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_36.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_36.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_36.cpp,19
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_53.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_53.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_78.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,945,1655,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_37.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_37.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_37.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_37.cpp,21
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_80.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_80.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,939,939,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_38.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_38.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_38.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_38.cpp,66
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_81.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1042,1042,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_39.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_39.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_39.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_39.cpp,169
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_54.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_82.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1068,1068,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_40.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_40.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_40.cpp,195
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_84.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,804,803,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_41.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_41.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_41.cpp,50
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_85.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,876,875,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_42.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_42.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_42.cpp,122
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_55.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_55.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_86.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_86.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,902,901,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_43.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_43.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_43.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_43.cpp,148
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,789,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_44.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_44.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_44.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_44.cpp,14
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,820,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_45.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_45.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_45.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_45.cpp,45
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,826,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_46.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_46.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_46.cpp,51
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,832,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_47.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_47.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_47.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_47.cpp,57
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,865,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_48.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_48.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_48.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_48.cpp,18
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,883,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_49.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_49.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_49.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_49.cpp,36
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,889,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_50.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_50.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_50.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_50.cpp,42
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_93.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,920,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_51.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_51.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_51.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_51.cpp,12
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_110.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_110.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,939,991,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_52.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_52.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_52.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_52.cpp,53
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_112.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_112.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1129,1184,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_53.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_53.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_53.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_53.cpp,23
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1819,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_54.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_54.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_54.cpp,109
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1824,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_55.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_55.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_55.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_55.cpp,114
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1843,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_56.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_56.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_56.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_56.cpp,133
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_66.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_113.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1848,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_57.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_57.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_57.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_57.cpp,138
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_116.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_116.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,262,260,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_58.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_58.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_58.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_58.cpp,52
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_67.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_67.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_117.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_117.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,286,294,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_59.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_59.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_59.cpp,76
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1536,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_60.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_60.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_60.cpp,121
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_118.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1543,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_61.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_61.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_61.cpp,128
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1700,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_62.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_62.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_62.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_62.cpp,116
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_68.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_119.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1710,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_63.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_63.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_63.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_63.cpp,126
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_69.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_69.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_121.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_121.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,720,742,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_64.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_64.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_64.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_64.cpp,300
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2413,2598,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_65.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_65.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_65.cpp,49
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2427,2628,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_66.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_66.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_66.cpp,63
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2437,2659,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_67.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_67.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_67.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_67.cpp,73
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_129.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2445,2672,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_68.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_68.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_68.cpp,81
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2543,2817,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_69.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_69.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_69.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_69.cpp,8
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_130.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_130.cpp," * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
                  ""Path is absolute"");
return (ARCHIVE_FAILED);
}

"," * is set) if the path is absolute.
 */
static int
cleanup_pathname_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
char *dest, *src;
char separator = '\0';

dest = src = path;
if (*src == '\0') {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Invalid empty "", ""pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(path);
#endif
/* Skip leading '/'. */
if (*src == '/') {
if (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
    ""Path is "", ""absolute"");
return (ARCHIVE_FAILED);
}

",2534,2807,2554,2828,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_70.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_70.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_70.cpp,19
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_70.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_131.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_131.cpp,"} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
","} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (flags
    & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
fsobj_error(a_eno, a_estr,
    ARCHIVE_ERRNO_MISC,
    ""Path contains "", ""'..'"");
return (ARCHIVE_FAILED);
}
}
",2580,2854,2583,2858,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_71.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_71.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_71.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_71.cpp,48
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_140.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_140.cpp,"name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

if (a->tree != NULL) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't change dir"");
return (ARCHIVE_FAILED);
}
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
","name = archive_entry_sourcepath(entry);
if (name == NULL)
name = archive_entry_pathname(entry);
else if (a->tree != NULL && a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Can't change dir to read extended attributes"");
return (ARCHIVE_FAILED);
}
if (name == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Can't open file to read extended attributes: No name"");
return (ARCHIVE_WARN);
}

/* Short-circuit if there's nothing to do. */
have_attrs = copyfile(name, NULL, 0, copyfile_flags | COPYFILE_CHECK);
if (have_attrs == -1) {
",302,321,312,324,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_72.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_72.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_72.cpp,25
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_141.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_141.cpp,"const char *path;
ssize_t list_size;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
ssize_t list_size;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",772,1486,785,1496,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_73.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_73.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_73.cpp,19
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_142.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_142.cpp,"const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = archive_entry_sourcepath(entry);
if (path == NULL)
path = archive_entry_pathname(entry);

if (*fd < 0 && a->tree != NULL) {
if (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)
*fd = a->open_on_current_dir(a->tree, path,
O_RDONLY | O_NONBLOCK);
if (*fd < 0) {
if (a->tree_enter_working_dir(a->tree) != 0) {
archive_set_error(&a->archive, errno,
    ""Couldn't access %s"", path);
return (ARCHIVE_FAILED);
}
}
}

","const char *path;
int namespace = EXTATTR_NAMESPACE_USER;

path = NULL;

if (*fd < 0) {
path = archive_entry_sourcepath(entry);
if (path == NULL || (a->tree != NULL &&
    a->tree_enter_working_dir(a->tree) != 0))
path = archive_entry_pathname(entry);
if (path == NULL) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Couldn't determine file path to read ""
    ""extended attributes"");
return (ARCHIVE_WARN);
}
if (a->tree != NULL && (a->follow_symlinks ||
    archive_entry_filetype(entry) != AE_IFLNK)) {
*fd = a->open_on_current_dir(a->tree,
    path, O_RDONLY | O_NONBLOCK);
}
}

",932,1645,945,1655,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_74.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_74.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_74.cpp,21
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_144.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_144.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",938,938,939,939,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_75.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_75.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_75.cpp,66
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_145.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_145.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1041,1041,1042,1042,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_76.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_76.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_76.cpp,169
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_146.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_146.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",1067,1067,1068,1068,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_77.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_77.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_77.cpp,195
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_148.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_148.cpp,"r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_path_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",803,802,804,803,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_78.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_78.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_78.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_78.cpp,50
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_149.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_149.cpp,"r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_time_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",875,874,876,875,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_79.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_79.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_79.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_79.cpp,122
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_77.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_150.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_150.cpp,"r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Faild : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
","r = archive_match_owner_excluded(a->matching, entry);
if (r < 0) {
archive_set_error(&(a->archive), errno,
    ""Failed : %s"", archive_error_string(a->matching));
return (r);
}
if (r) {
",901,900,902,901,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_80.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_80.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_80.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_80.cpp,148
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,789,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_81.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_81.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_81.cpp,14
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,820,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_82.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_82.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_82.cpp,45
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,826,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_83.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_83.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_83.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_83.cpp,51
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,832,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_84.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_84.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_84.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_84.cpp,57
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,865,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_85.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_85.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_85.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_85.cpp,18
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,883,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_86.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_86.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_86.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_86.cpp,36
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,889,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_87.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_87.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_87.cpp,42
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_157.cpp,"
#else

#if HAVE_LZMADEC_H && HAVE_LIBLZMADEC

/*
 * If we have the older liblzmadec library, then we can handle
 * LZMA streams but not XZ streams.
 */

/*
 * Setup the callbacks.
 */
static int
lzma_bidder_init(struct archive_read_filter *self)
{
static const size_t out_block_size = 64 * 1024;
void *out_block;
struct private_data *state;
ssize_t ret, avail_in;

self->code = ARCHIVE_FILTER_LZMA;
self->name = ""lzma"";

state = (struct private_data *)calloc(sizeof(*state), 1);
out_block = (unsigned char *)malloc(out_block_size);
if (state == NULL || out_block == NULL) {
archive_set_error(&self->archive->archive, ENOMEM,
    ""Can't allocate data for lzma decompression"");
free(out_block);
free(state);
return (ARCHIVE_FATAL);
}

self->data = state;
state->out_block_size = out_block_size;
state->out_block = out_block;
self->read = lzma_filter_read;
self->skip = NULL; /* not supported */
self->close = lzma_filter_close;

/* Prime the lzma library with 18 bytes of input. */
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
if (state->stream.next_in == NULL)
return (ARCHIVE_FATAL);
state->stream.avail_in = avail_in;
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Initialize compression library. */
ret = lzmadec_init(&(state->stream));
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
if (ret == LZMADEC_OK)
return (ARCHIVE_OK);

/* Library setup failed: Clean up. */
archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
    ""Internal error initializing lzma library"");

/* Override the error message if we know what really went wrong. */
switch (ret) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&self->archive->archive, ENOMEM,
    ""Internal error initializing compression library: ""
    ""out of memory"");
break;
}

free(state->out_block);
free(state);
self->data = NULL;
return (ARCHIVE_FATAL);
}

/*
 * Return the next block of decompressed data.
 */
static ssize_t
lzma_filter_read(struct archive_read_filter *self, const void **p)
{
struct private_data *state;
size_t decompressed;
ssize_t avail_in, ret;

state = (struct private_data *)self->data;

/* Empty our output buffer. */
state->stream.next_out = state->out_block;
state->stream.avail_out = state->out_block_size;

/* Try to fill the output buffer. */
while (state->stream.avail_out > 0 && !state->eof) {
state->stream.next_in = (unsigned char *)(uintptr_t)
    __archive_read_filter_ahead(self->upstream, 1, &avail_in);
if (state->stream.next_in == NULL && avail_in < 0) {
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""truncated lzma input"");
return (ARCHIVE_FATAL);
}
state->stream.avail_in = avail_in;

/* Decompress as much as we can in one pass. */
ret = lzmadec_decode(&(state->stream), avail_in == 0);
switch (ret) {
case LZMADEC_STREAM_END: /* Found end of stream. */
state->eof = 1;
/* FALL THROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
__archive_read_filter_consume(self->upstream,
    avail_in - state->stream.avail_in);
break;
case LZMADEC_BUF_ERROR: /* Insufficient input data? */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Insufficient compressed data"");
return (ARCHIVE_FATAL);
default:
/* Return an error. */
archive_set_error(&self->archive->archive,
    ARCHIVE_ERRNO_MISC,
    ""Lzma decompression failed"");
return (ARCHIVE_FATAL);
}
}

decompressed = state->stream.next_out - state->out_block;
state->total_out = decompressed;
if (decompressed == 0)
*p = NULL;
else
*p = state->out_block;
return (decompressed);
}

/*
 * Clean up the decompressor.
 */
static int
lzma_filter_close(struct archive_read_filter *self)
{
struct private_data *state;
int ret;

state = (struct private_data *)self->data;
ret = ARCHIVE_OK;
switch (lzmadec_end(&(state->stream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(self->archive->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up %s compressor"",
    self->archive->archive.compression_name);
ret = ARCHIVE_FATAL;
}

free(state->out_block);
free(state);
return (ret);
}

#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
","
#else

/*
 *
 * If we have no suitable library on this system, we can't actually do
",763,744,920,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_88.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_88.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_88.cpp,12
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_174.cpp,"switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
break;
case 03000000:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Solaris NFSv4 ACLs not supported"");
return (ARCHIVE_WARN);
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
","switch ((int)type & ~0777777) {
case 01000000:
/* POSIX.1e ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
break;
case 03000000:
/* NFSv4 ACL */
acl_type = ARCHIVE_ENTRY_ACL_TYPE_NFS4;
break;
default:
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Malformed Solaris ACL attribute (unsupported type %o)"",
",935,989,939,991,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_89.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_89.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_89.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_89.cpp,53
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_176.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_176.cpp,"if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size?"");
err = ARCHIVE_WARN;
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
","if (tar->entry_bytes_remaining < 0) {
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry has negative size"");
return (ARCHIVE_FATAL);
}
if (tar->entry_bytes_remaining == INT64_MAX) {
/* Note: tar_atol returns INT64_MAX on overflow */
tar->entry_bytes_remaining = 0;
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
    ""Tar entry size overflow"");
return (ARCHIVE_FATAL);
}
tar->realsize = tar->entry_bytes_remaining;
archive_entry_set_size(entry, tar->entry_bytes_remaining);
",1128,1183,1129,1184,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_90.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_90.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_90.cpp,23
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1819,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_91.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_91.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_91.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_91.cpp,109
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1824,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_92.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_92.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_92.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_92.cpp,114
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1843,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_93.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_93.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_93.cpp,133
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_88.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_177.cpp,"case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_ACCESS,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.access"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.access"");
}
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
if (tar->sconv_acl == NULL) {
tar->sconv_acl =
    archive_string_conversion_from_charset(
&(a->archive), ""UTF-8"", 1);
if (tar->sconv_acl == NULL)
return (ARCHIVE_FATAL);
}

r = archive_acl_parse_l(archive_entry_acl(entry),
    value, ARCHIVE_ENTRY_ACL_TYPE_DEFAULT,
    tar->sconv_acl);
if (r != ARCHIVE_OK) {
err = r;
if (err == ARCHIVE_FATAL) {
archive_set_error(&a->archive, ENOMEM,
    ""Can't allocate memory for ""
    ""SCHILY.acl.default"");
return (err);
}
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Parse error: SCHILY.acl.default"");
}
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
","case 'S':
/* We support some keys used by the ""star"" archiver */
if (strcmp(key, ""SCHILY.acl.access"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_ACCESS);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.default"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.acl.ace"") == 0) {
r = pax_attribute_acl(a, tar, entry, value,
    ARCHIVE_ENTRY_ACL_TYPE_NFS4);
if (r == ARCHIVE_FATAL)
return (r);
} else if (strcmp(key, ""SCHILY.devmajor"") == 0) {
archive_entry_set_rdevmajor(entry,
    (dev_t)tar_atol10(value, strlen(value)));
",1803,1944,1848,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_94.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_94.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_94.cpp,138
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_180.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_180.cpp,"&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
} else if ((ver = _warc_rdver(buf, eoh - buf)) > 10000U) {
/* nawww, I wish they promised backward compatibility
 * anyhoo, in their infinite wisdom the 28500 guys might
 * come up with something we can't possibly handle so
 * best end things here */
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version"");
return (ARCHIVE_FATAL);
} else if ((cntlen = _warc_rdlen(buf, eoh - buf)) < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
} else if ((rtime = _warc_rdrtm(buf, eoh - buf)) == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
","&a->archive, ARCHIVE_ERRNO_MISC,
""Bad record header"");
return (ARCHIVE_FATAL);
}
ver = _warc_rdver(buf, eoh - buf);
/* we currently support WARC 0.12 to 1.0 */
if (ver == 0U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid record version"");
return (ARCHIVE_FATAL);
} else if (ver < 1200U || ver > 10000U) {
archive_set_error(
&a->archive, ARCHIVE_ERRNO_MISC,
""Unsupported record version: %u.%u"",
ver / 10000, (ver % 10000) / 100);
return (ARCHIVE_FATAL);
}
cntlen = _warc_rdlen(buf, eoh - buf);
if (cntlen < 0) {
/* nightmare!  the specs say content-length is mandatory
 * so I don't feel overly bad stopping the reader here */
archive_set_error(
&a->archive, EINVAL,
""Bad content length"");
return (ARCHIVE_FATAL);
}
rtime = _warc_rdrtm(buf, eoh - buf);
if (rtime == (time_t)-1) {
/* record time is mandatory as per WARC/1.0,
 * so just barf here, fast and loud */
archive_set_error(
",255,254,262,260,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_95.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_95.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_95.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_95.cpp,52
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_89.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_89.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_181.cpp,"if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, ver % 10000);
/* remember the version */
w->pver = ver;
}
","if (ver != w->pver) {
/* stringify this entry's version */
archive_string_sprintf(&w->sver,
""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);
/* remember the version */
w->pver = ver;
}
",285,293,286,294,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_96.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_96.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_96.cpp,76
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1536,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_97.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_97.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_97.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_97.cpp,121
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_182.cpp,"xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
if (xar->lzstream_valid)
lzmadec_end(&(xar->lzstream));
r = lzmadec_init(&(xar->lzstream));
if (r != LZMADEC_OK) {
switch (r) {
case LZMADEC_HEADER_ERROR:
archive_set_error(&a->archive,
    ARCHIVE_ERRNO_MISC,
    ""Internal error initializing ""
    ""compression library: ""
    ""invalid header"");
break;
case LZMADEC_MEM_ERROR:
archive_set_error(&a->archive,
    ENOMEM,
    ""Internal error initializing ""
    ""compression library: ""
    ""out of memory"");
break;
}
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 1;
xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
","xar->lzstream.total_in = 0;
xar->lzstream.total_out = 0;
break;
#endif
/*
 * Unsupported compression.
",1526,1524,1543,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_98.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_98.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_98.cpp,128
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1700,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_99.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_99.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_99.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_99.cpp,116
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_90.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_183.cpp,"*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#elif defined(HAVE_LZMADEC_H) && defined(HAVE_LIBLZMADEC)
case LZMA:
xar->lzstream.next_in = (unsigned char *)(uintptr_t)b;
xar->lzstream.avail_in = avail_in;
xar->lzstream.next_out = (unsigned char *)outbuff;
xar->lzstream.avail_out = avail_out;
r = lzmadec_decode(&(xar->lzstream), 0);
switch (r) {
case LZMADEC_STREAM_END: /* Found end of stream. */
switch (lzmadec_end(&(xar->lzstream))) {
case LZMADEC_OK:
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""Failed to clean up lzmadec decompressor"");
return (ARCHIVE_FATAL);
}
xar->lzstream_valid = 0;
/* FALLTHROUGH */
case LZMADEC_OK: /* Decompressor made some progress. */
break;
default:
archive_set_error(&(a->archive),
    ARCHIVE_ERRNO_MISC,
    ""lzmadec decompression failed(%d)"",
    r);
return (ARCHIVE_FATAL);
}
*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
#if !defined(HAVE_LZMADEC_H) || !defined(HAVE_LIBLZMADEC)
case LZMA:
#endif
case XZ:
#endif
case NONE:
","*used = avail_in - xar->lzstream.avail_in;
*outbytes = avail_out - xar->lzstream.avail_out;
break;
#endif
#if !defined(HAVE_BZLIB_H) || !defined(BZ_CONFIG_ERROR)
case BZIP2:
#endif
#if !defined(HAVE_LZMA_H) || !defined(HAVE_LIBLZMA)
case LZMA:
case XZ:
#endif
case NONE:
",1685,1653,1710,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_100.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_100.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_100.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_100.cpp,126
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_91.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_91.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_185.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_185.cpp,"}
offset = datasize;
}
#ifdef DEBUG
if (offset != extra_length)
{
fprintf(stderr,
    ""Extra data field contents do not match reported size!\n"");
}
#endif
}

/*
","}
offset = datasize;
}
if (offset != extra_length) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
    ""Malformed extra data: Consumed %d bytes of %d bytes"",
    (int)offset, (int)extra_length);
return ARCHIVE_FAILED;
}
return ARCHIVE_OK;
}

/*
",715,739,720,742,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_101.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_101.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_101.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_101.cpp,300
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2413,2598,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_102.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_102.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_102.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_102.cpp,49
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_92.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_92.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_193.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_193.cpp,"return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)a; /* UNUSED */
return (ARCHIVE_OK);
#else
char *pn;
char c;
int r;
struct stat st;

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 */
/* Whatever we checked last time doesn't need to be re-checked. */
pn = a->name;
if (archive_strlen(&(a->path_safe)) > 0) {
char *p = a->path_safe.s;
while ((*pn != '\0') && (*p == *pn))
ï¿½, ïªï¿½;
}
/* Skip the root directory if the path is absolute. */
if(pn == a->name && pn[0] == '/')
ïªï¿½;
c = pn[0];
/* Keep going until we've checked the entire name. */
while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
/* Skip the next path element. */
while (*pn != '\0' && *pn != '/')
ïªï¿½;
c = pn[0];
pn[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(a->name, &st);
if (r != 0) {
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT)
break;
} else if (S_ISLNK(st.st_mode)) {
if (c == '\0') {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(a->name)) {
archive_set_error(&a->archive, errno,
    ""Could not remove symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
if (!S_ISLNK(a->mode)) {
archive_set_error(&a->archive, 0,
    ""Removing symlink %s"",
    a->name);
}
/* Symlink gone.  No more problem! */
pn[0] = c;
return (0);
} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(a->name) != 0) {
archive_set_error(&a->archive, 0,
    ""Cannot remove intervening symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
a->pst = NULL;
} else {
archive_set_error(&a->archive, 0,
    ""Cannot extract through symlink %s"",
    a->name);
pn[0] = c;
return (ARCHIVE_FAILED);
}
}
pn[0] = c;
if (pn[0] != '\0')
pnï¿½; /* Advance to the next segment. */
}
pn[0] = c;
/* We've checked and/or cleaned the whole path, so remember it. */
archive_strcpy(&a->path_safe, a->name);
return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
","return (a->current_fixup);
}

/* Error helper for new *_fsobj functions */
static void
fsobj_error(int *a_eno, struct archive_string *a_estr,
    int err, const char *errstr, const char *path)
{
if (a_eno)
*a_eno = err;
if (a_estr)
archive_string_sprintf(a_estr, errstr, path);
}

/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */

/*
 * Checks the given path to see if any elements along it are symlinks.  Returns
 * ARCHIVE_OK if there are none, otherwise puts an error in errmsg.
 */
static int
check_symlinks_fsobj(char *path, int *a_eno, struct archive_string *a_estr,
    int flags)
{
#if !defined(HAVE_LSTAT)
/* Platform doesn't have lstat, so we can't look for symlinks. */
(void)path; /* UNUSED */
(void)error_number; /* UNUSED */
(void)error_string; /* UNUSED */
(void)flags; /* UNUSED */
return (ARCHIVE_OK);
#else
int res = ARCHIVE_OK;
char *tail;
char *head;
int last;
char c;
int r;
struct stat st;
int restore_pwd;

/* Nothing to do here if name is empty */
if(path[0] == '\0')
    return (ARCHIVE_OK);

/*
 * Guard against symlink tricks.  Reject any archive entry whose
 * destination would be altered by a symlink.
 *
 * Walk the filename in chunks separated by '/'.  For each segment:
 *  - if it doesn't exist, continue
 *  - if it's symlink, abort or remove it
 *  - if it's a directory and it's not the last chunk, cd into it
 * As we go:
 *  head points to the current (relative) path
 *  tail points to the temporary \0 terminating the segment we're
 *      currently examining
 *  c holds what used to be in *tail
 *  last is 1 if this is the last tail
 */
restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
__archive_ensure_cloexec_flag(restore_pwd);
if (restore_pwd < 0)
return (ARCHIVE_FATAL);
head = path;
tail = path;
last = 0;
/* TODO: reintroduce a safe cache here? */
/* Skip the root directory if the path is absolute. */
if(tail == path && tail[0] == '/')
ï«ï¿½;
/* Keep going until we've checked the entire name.
 * head, tail, path all alias the same string, which is
 * temporarily zeroed at tail, so be careful restoring the
 * stashed (c=tail[0]) for error messages.
 * Exiting the loop with break is okay; continue is not.
 */
while (!last) {
/*
 * Skip the separator we just consumed, plus any adjacent ones
 */
while (*tail == '/')
    ï«ï¿½;
/* Skip the next path element. */
while (*tail != '\0' && *tail != '/')
ï«ï¿½;
/* is this the last path component? */
last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
/* temporarily truncate the string here */
c = tail[0];
tail[0] = '\0';
/* Check that we haven't hit a symlink. */
r = lstat(head, &st);
if (r != 0) {
tail[0] = c;
/* We've hit a dir that doesn't exist; stop now. */
if (errno == ENOENT) {
break;
} else {
/*
 * Treat any other error as fatal - best to be
 * paranoid here.
 * Note: This effectively disables deep
 * directory support when security checks are
 * enabled. Otherwise, very long pathnames that
 * trigger an error here could evade the
 * sandbox.
 * TODO: We could do better, but it would
 * probably require merging the symlink checks
 * with the deep-directory editing.
 */
fsobj_error(a_eno, a_estr, errno,
    ""Could not stat %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (!last) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/* Our view is now from inside this dir: */
head = tail  1;
}
} else if (S_ISLNK(st.st_mode)) {
if (last) {
/*
 * Last element is symlink; remove it
 * so we can overwrite it with the
 * item being extracted.
 */
if (unlink(head)) {
tail[0] = c;
fsobj_error(a_eno, a_estr, errno,
    ""Could not remove symlink %s"",
    path);
res = ARCHIVE_FAILED;
break;
}
/*
 * Even if we did remove it, a warning
 * is in order.  The warning is silly,
 * though, if we're just replacing one
 * symlink with another symlink.
 */
tail[0] = c;
/*
 * FIXME:  not sure how important this is to
 * restore
 */
/*
if (!S_ISLNK(path)) {
fsobj_error(a_eno, a_estr, 0,
    ""Removing symlink %s"", path);
}
*/
/* Symlink gone.  No more problem! */
res = ARCHIVE_OK;
break;
} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
/* User asked us to remove problems. */
if (unlink(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot remove intervening ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
tail[0] = c;
} else if ((flags &
    ARCHIVE_EXTRACT_SECURE_SYMLINKS) == 0) {
/*
 * We are not the last element and we want to
 * follow symlinks if they are a directory.
 * 
 * This is needed to extract hardlinks over
 * symlinks.
 */
r = stat(head, &st);
if (r != 0) {
tail[0] = c;
if (errno == ENOENT) {
break;
} else {
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not stat %s"", path);
res = (ARCHIVE_FAILED);
break;
}
} else if (S_ISDIR(st.st_mode)) {
if (chdir(head) != 0) {
tail[0] = c;
fsobj_error(a_eno, a_estr,
    errno,
    ""Could not chdir %s"", path);
res = (ARCHIVE_FATAL);
break;
}
/*
 * Our view is now from inside
 * this dir:
 */
head = tail  1;
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through ""
    ""symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
} else {
tail[0] = c;
fsobj_error(a_eno, a_estr, 0,
    ""Cannot extract through symlink %s"", path);
res = ARCHIVE_FAILED;
break;
}
}
/* be sure to always maintain this */
tail[0] = c;
if (tail[0] != '\0')
tailï¿½; /* Advance to the next segment. */
}
/* Catches loop exits via break */
tail[0] = c;
#ifdef HAVE_FCHDIR
/* If we changed directory above, restore it here. */
if (restore_pwd >= 0) {
r = fchdir(restore_pwd);
if (r != 0) {
fsobj_error(a_eno, a_estr, errno,
    ""chdir() failure"", """");
}
close(restore_pwd);
restore_pwd = -1;
if (r != 0) {
res = (ARCHIVE_FATAL);
}
}
#endif
/* TODO: reintroduce a safe cache here? */
return res;
#endif
}

/*
 * Check a->name for symlinks, returning ARCHIVE_OK if its clean, otherwise
 * calls archive_set_error and returns ARCHIVE_{FATAL,FAILED}
 */
static int
check_symlinks(struct archive_write_disk *a)
{
struct archive_string error_string;
int error_number;
int rc;
archive_string_init(&error_string);
rc = check_symlinks_fsobj(a->name, &error_number, &error_string,
    a->flags);
if (rc != ARCHIVE_OK) {
archive_set_error(&a->archive, error_number, ""%s"",
    error_string.s);
}
archive_string_free(&error_string);
a->pst = NULL;/* to be safe */
return rc;
}


#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
",2351,2457,2427,2628,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_103.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_103.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_103.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_103.cpp,63
