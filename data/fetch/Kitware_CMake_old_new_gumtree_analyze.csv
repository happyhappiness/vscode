sha,message,issue,file_name,old_file,new_file,patch_file,old_hunk_file,new_hunk_file,old_hunk_loc,new_hunk_loc,old_loc,new_loc,old_log,new_log,action_type,old_log_file,new_log_file,old_block,old_block_file,old_block_feature,old_function_file,old_fucntion_loc
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_20.cpp,4044,4083,4090,4125,"archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");","archive_strcat(&errlist, name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_0.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_0.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_0.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_0.cpp,39
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_20.cpp,4044,4083,4097,4168,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended ""
			    ""attributes on this file system."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1.cpp,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1.cpp,46
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_20.cpp,4044,4083,4102,4154,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");","archive_strappend_char(&errlist, ' ');",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_2.cpp,"{
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_2.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_2.cpp,51
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_20.cpp,4044,4083,4108,4164,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended attributes: %s"",
			    errlist.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_3.cpp,"{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL &&
				strncmp(name, ""xfsroot."", 8) != 0 &&
				strncmp(name, ""system."", 7) != 0) {
			int e;
#if HAVE_FSETXATTR
			if (a->fd >= 0)
				e = fsetxattr(a->fd, name, value, size, 0);
			else
#elif HAVE_FSETEA
			if (a->fd >= 0)
				e = fsetea(a->fd, name, value, size, 0);
			else
#endif
			{
#if HAVE_LSETXATTR
				e = lsetxattr(archive_entry_pathname(entry),
				    name, value, size, 0);
#elif HAVE_LSETEA
				e = lsetea(archive_entry_pathname(entry),
				    name, value, size, 0);
#endif
			}
			if (e == -1) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_3.cpp,"[8, 1, 0, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 8, 8, 0, 0, 4, 20, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 7, 6, 3, 0, 13, 0, 0, 11, 1, 42, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_3.cpp,57
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_21.cpp,4134,4203,4137,4207,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);","archive_strappend_char(&errlist, ' ');",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_4.cpp,"{
				/* Warn about other extended attributes. */
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);
				ret = ARCHIVE_WARN;
				continue;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_4.cpp,"[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_4.cpp,23
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_21.cpp,4134,4203,4161,4240,"archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended ""
			    ""attributes on this file system."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_5.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_5.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_5.cpp,47
6df1bda1c57193b289866389a994ea79a2f5e1d8,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-07-09 (98a69539)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_2.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_2.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_21.cpp,4134,4203,4168,4236,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended attributes: %s"",
			    errlist.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_6.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_6.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_6.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_6.cpp,54
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_22.cpp,328,334,334,-1,"archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_7.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_7.cpp,"{
		archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");
			return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_7.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_7.cpp,18
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_22.cpp,328,334,339,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_8.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_8.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't open file to read extended attributes: No name"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_8.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_8.cpp,23
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,476,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ACLs"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_9.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ACLs"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_9.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_9.cpp,26
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,549,-1,"archive_set_error(&a->archive, errno,
			    ""Couldn't translate ""
#if !HAVE_SUN_ACL
			    ""NFSv4 ""
#endif
			    ""ACLs"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_10.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_10.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Couldn't translate ""
#if !HAVE_SUN_ACL
			    ""NFSv4 ""
#endif
			    ""ACLs"");
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_10.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_10.cpp,99
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,605,-1,"archive_set_error(&a->archive, errno,
			    ""Couldn't translate access ACLs"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_11.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_11.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Couldn't translate access ACLs"");
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_11.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_11.cpp,155
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,624,-1,"archive_set_error(&a->archive, errno,
				    ""Couldn't translate default ACLs"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_12.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_12.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't translate default ACLs"");
				return (r);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_12.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_12.cpp,174
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1188,-1,"archive_set_error(&a->archive, errno,
		    ""Failed to read ACL brand"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_13.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_13.cpp,"{
		archive_set_error(&a->archive, errno,
		    ""Failed to read ACL brand"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_13.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_13.cpp,26
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1199,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for POSIX.1e ACL"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_14.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_14.cpp,"{
		case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
		case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for POSIX.1e ACL"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_14.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 2, 1, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_14.cpp,37
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1206,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for NFSv4 ACL"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_15.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_15.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for NFSv4 ACL"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_15.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_15.cpp,44
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1212,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unknown ACL brand"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_16.cpp,"{
	case ACL_BRAND_POSIX:
		switch (default_entry_acl_type) {
		case ARCHIVE_ENTRY_ACL_TYPE_ACCESS:
		case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for POSIX.1e ACL"");
			return (ARCHIVE_WARN);
		}
		break;
	case ACL_BRAND_NFS4:
		if (default_entry_acl_type & ~ARCHIVE_ENTRY_ACL_TYPE_NFS4) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Invalid ACL entry type for NFSv4 ACL"");
			return (ARCHIVE_WARN);
		}
		break;
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unknown ACL brand"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_16.cpp,"[1, 0, 0, 0, 3, 0, 3, 1, 4, 2, 3, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 0, 3, 0, 0, 3, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_16.cpp,50
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1220,-1,"archive_set_error(&a->archive, errno,
		    ""Failed to get first ACL entry"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_17.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_17.cpp,"{
		archive_set_error(&a->archive, errno,
		    ""Failed to get first ACL entry"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_17.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_17.cpp,58
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1236,-1,"archive_set_error(&a->archive, errno,
			    ""Failed to get ACL tag type"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_18.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_18.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Failed to get ACL tag type"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_18.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_18.cpp,74
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1316,-1,"archive_set_error(&a->archive, errno, ""Failed ""
				    ""to get ACL type from a NFSv4 ACL entry"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_19.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_19.cpp,"{
				archive_set_error(&a->archive, errno, ""Failed ""
				    ""to get ACL type from a NFSv4 ACL entry"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_19.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_19.cpp,154
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1334,-1,"archive_set_error(&a->archive, errno,
				    ""Invalid NFSv4 ACL entry type"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_20.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_20.cpp,"{
			case ACL_ENTRY_TYPE_ALLOW:
				entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
				break;
			case ACL_ENTRY_TYPE_DENY:
				entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
				break;
			case ACL_ENTRY_TYPE_AUDIT:
				entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
				break;
			case ACL_ENTRY_TYPE_ALARM:
				entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALARM;
				break;
			default:
				archive_set_error(&a->archive, errno,
				    ""Invalid NFSv4 ACL entry type"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_20.cpp,"[0, 0, 0, 0, 4, 0, 1, 0, 4, 1, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 5, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_20.cpp,172
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1347,-1,"archive_set_error(&a->archive, errno,
				    ""Failed to get flagset from a NFSv4 ACL entry"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_21.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Failed to get flagset from a NFSv4 ACL entry"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_21.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_21.cpp,185
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1355,-1,"archive_set_error(&a->archive, errno,
					    ""Failed to check flag in a NFSv4 ""
					    ""ACL flagset"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_22.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Failed to check flag in a NFSv4 ""
					    ""ACL flagset"");
					return (ARCHIVE_WARN);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_22.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_22.cpp,193
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1366,-1,"archive_set_error(&a->archive, errno,
			    ""Failed to get ACL permission set"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_23.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Failed to get ACL permission set"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_23.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_23.cpp,204
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1377,-1,"archive_set_error(&a->archive, errno,
				    ""Failed to check permission in an ACL permission set"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_24.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Failed to check permission in an ACL permission set"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_24.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_24.cpp,215
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_23.cpp,426,423,1391,-1,"archive_set_error(&a->archive, errno,
			    ""Failed to get next ACL entry"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_25.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_25.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Failed to get next ACL entry"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_25.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_25.cpp,229
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_26.cpp,1499,532,1506,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_26.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_26.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_26.cpp,16
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_28.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_28.cpp,1658,710,1665,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_27.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_27.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_27.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_27.cpp,18
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_3.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_3.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_29.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_29.cpp,1880,920,1898,-1,"archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_28.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_28.cpp,"{
			archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_28.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_28.cpp,25
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_4.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_4.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_4.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_31.cpp,1535,1533,1542,1540,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symbolic mode \""%s\"" unsupported"", val);","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symbolic or non-octal mode \""%s\"" unsupported"", val);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_29.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_29.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symbolic mode \""%s\"" unsupported"", val);
				return ARCHIVE_WARN;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_29.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_29.cpp,97
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_32.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_32.cpp,2467,2506,2469,2508,"archive_string_sprintf(a_estr, errstr, path);","archive_string_sprintf(a_estr, ""%s%s"", errstr, path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_30.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_30.cpp,"archive_string_sprintf(a_estr, errstr, path)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_30.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_30.cpp,7
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_34.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_34.cpp,2582,2621,2583,2622,"fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_31.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_31.cpp,"{
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);
					res = (ARCHIVE_FATAL);
					break;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_31.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_31.cpp,100
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_35.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_35.cpp,2599,2638,2600,2639,"fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink "",
					    path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_32.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_32.cpp,"{
					tail[0] = c;
					fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);
					res = ARCHIVE_FAILED;
					break;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_32.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_32.cpp,117
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_37.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_37.cpp,2630,2669,2630,2669,"fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_33.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_33.cpp,"{
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_33.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_33.cpp,147
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_38.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_38.cpp,2652,2691,2652,2691,"fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_34.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_34.cpp,"{
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);
						res = (ARCHIVE_FAILED);
						break;
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_34.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_34.cpp,169
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_39.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_39.cpp,2661,2700,2661,2700,"fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_35.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_35.cpp,"{
						tail[0] = c;
						fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);
						res = (ARCHIVE_FATAL);
						break;
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_35.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_35.cpp,178
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_40.cpp,2674,2713,2674,2713,"fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_36.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_36.cpp,"{
					tail[0] = c;
					fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);
					res = ARCHIVE_FAILED;
					break;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_36.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_36.cpp,191
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_40.cpp,2674,2713,2682,2721,"fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);","fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink "", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_37.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_37.cpp,"{
				tail[0] = c;
				fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);
				res = ARCHIVE_FAILED;
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_37.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_37.cpp,199
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_41.cpp,4044,4083,4090,4125,"archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");","archive_strcat(&errlist, name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_38.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_38.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_38.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_38.cpp,39
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_41.cpp,4044,4083,4097,4168,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended ""
			    ""attributes on this file system."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_39.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_39.cpp,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_39.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_39.cpp,46
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_41.cpp,4044,4083,4102,4154,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");","archive_strappend_char(&errlist, ' ');",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_40.cpp,"{
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_40.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_40.cpp,51
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_41.cpp,4044,4083,4108,4164,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended attributes: %s"",
			    errlist.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_41.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_41.cpp,"{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL &&
				strncmp(name, ""xfsroot."", 8) != 0 &&
				strncmp(name, ""system."", 7) != 0) {
			int e;
#if HAVE_FSETXATTR
			if (a->fd >= 0)
				e = fsetxattr(a->fd, name, value, size, 0);
			else
#elif HAVE_FSETEA
			if (a->fd >= 0)
				e = fsetea(a->fd, name, value, size, 0);
			else
#endif
			{
#if HAVE_LSETXATTR
				e = lsetxattr(archive_entry_pathname(entry),
				    name, value, size, 0);
#elif HAVE_LSETEA
				e = lsetea(archive_entry_pathname(entry),
				    name, value, size, 0);
#endif
			}
			if (e == -1) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_41.cpp,"[8, 1, 0, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 8, 8, 0, 0, 4, 20, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 7, 6, 3, 0, 13, 0, 0, 11, 1, 42, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_41.cpp,57
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_42.cpp,4134,4203,4137,4207,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);","archive_strappend_char(&errlist, ' ');",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_42.cpp,"{
				/* Warn about other extended attributes. */
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);
				ret = ARCHIVE_WARN;
				continue;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_42.cpp,"[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_42.cpp,23
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_42.cpp,4134,4203,4161,4240,"archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended ""
			    ""attributes on this file system."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_43.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_43.cpp,"{
						warning_done = 1;
						archive_set_error(&a->archive,
						    errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_43.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_43.cpp,47
11f3dcb04887fccf38a8eda19d498bf7a5060486,"LibArchive 2017-07-09 (98a69539)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 98a695399e8e7420635a5448aecde8b0a82fb83a (v3.3.2).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_5.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_5.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_42.cpp,4134,4203,4168,4236,"archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Cannot restore extended attributes: %s"",
			    errlist.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_44.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_44.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_44.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_44.cpp,54
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_7.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_7.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_7.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_44.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_44.cpp,475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_45.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_45.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_45.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_45.cpp,58
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_8.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_46.cpp,2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_46.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_46.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_46.cpp,20
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_8.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_8.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_8.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_48.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_48.cpp,2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_47.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_47.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_47.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_47.cpp,15
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_9.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_9.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_9.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_49.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_49.cpp,297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_48.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_48.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_48.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_48.cpp,21
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_10.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_51.cpp,243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_49.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_49.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_49.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_49.cpp,6
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_10.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_10.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_10.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_51.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_51.cpp,243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_50.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_50.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_50.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_50.cpp,9
df1c187f2fdfa48bd36d770bac23f6503fd9b071,Merge branch 'update-curl' into release-3.9,[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_12.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_12.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_12.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_54.cpp,387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_51.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_51.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_51.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_51.cpp,54
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_14.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_14.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_14.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_56.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_56.cpp,475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_52.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_52.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_52.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_52.cpp,58
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_15.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_58.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_58.cpp,2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_53.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_53.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_53.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_53.cpp,20
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_15.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_15.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_15.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_60.cpp,2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_54.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_54.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_54.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_54.cpp,15
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_16.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_16.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_16.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_61.cpp,297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_55.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_55.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_55.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_55.cpp,21
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_17.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_63.cpp,243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_56.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_56.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_56.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_56.cpp,6
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_17.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_17.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_17.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_63.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_63.cpp,243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_57.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_57.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_57.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_57.cpp,9
a3ef36f153f51c33ea2154cff17bbf9abb7ee073,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-06-14 (54b636f1)

Resolve a logical conflict in `Utilities/cmcurl/CMakeLists.txt`
by disabling CA bundle/path detection for build within CMake.
CMake already handles locating a CA bundle/path at runtime.",[],Utilities/cmcurl/lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_19.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_19.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_19.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_66.cpp,387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_58.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_58.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_58.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_58.cpp,54
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_21.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_21.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_21.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_68.cpp,475,473,477,476,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(header, sizeof(header),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_59.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_59.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 86, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_59.cpp,58
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_70.cpp,2101,2100,2109,2108,"snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(timebuf, sizeof(timebuf),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_60.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_60.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_60.cpp,20
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_22.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_22.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_22.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_72.cpp,2318,2318,2320,2321,"snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(clbuf, sizeof(clbuf),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_61.cpp,"{
      snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_61.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_61.cpp,15
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_23.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_23.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_23.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_73.cpp,297,298,299,300,"f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);","= aprintf(""%s:%s"", user, pwd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_62.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_62.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_62.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 90, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_62.cpp,21
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_75.cpp,243,243,247,248,"vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);","vsnprintf(error, CURL_ERROR_SIZE, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_63.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_63.cpp,"{
  va_list ap;
  size_t len;
  va_start(ap, fmt);

  vsnprintf(data->state.buffer, BUFSIZE, fmt, ap);

  if(data->set.errorbuffer && !data->state.errorbuf) {
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }
  if(data->set.verbose) {
    len = strlen(data->state.buffer);
    if(len < BUFSIZE - 1) {
      data->state.buffer[len] = '\n';
      data->state.buffer[++len] = '\0';
    }
    Curl_debug(data, CURLINFO_TEXT, data->state.buffer, len, NULL);
  }

  va_end(ap);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_63.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 71, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 3, 0, 0, 6, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_63.cpp,6
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_24.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_24.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_24.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_75.cpp,243,243,250,252,"snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);","strcpy(data->set.errorbuffer, error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_64.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_64.cpp,"{
    snprintf(data->set.errorbuffer, CURL_ERROR_SIZE, ""%s"", data->state.buffer);
    data->state.errorbuf = TRUE; /* wrote error string */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_64.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_64.cpp,9
06d6d6c4aee149cd6560b919ef6935ef0867d921,"curl 2017-06-14 (54b636f1)

Code extracted from:

    https://github.com/curl/curl.git

at commit 54b636f14546d3fde9f9c67c3b32701d78563161 (curl-7_54_1).",[],lib/vauth/digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_26.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_26.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_26.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_78.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_78.cpp,387,386,395,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_65.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challenge message */
  result = auth_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = auth_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  result = Curl_rand(data, &entropy[0], 4);
  if(result)
    return result;

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_auth_build_spn(service, realm, NULL);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_65.cpp,"[11, 0, 3, 0, 0, 0, 12, 0, 0, 0, 15, 0, 0, 0, 24, 349, 0, 0, 19, 19, 0, 0, 9, 61, 0, 0, 0, 0, 3, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 118, 0, 272, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 24, 0, 14, 11, 0, 0, 74, 0, 0, 46, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_65.cpp,54
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_29.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_29.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_29.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_81.cpp,2243,2273,2246,2276,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_66.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_66.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_66.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_66.cpp,187
16ebd9f6152fedd1804f13c91ed14e8963e53d3f,"Merge branch 'upstream-KWSys' into update-kwsys

* upstream-KWSys:
  KWSys 2017-05-16 (fe1f22ce)",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_30.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_30.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_30.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_82.cpp,2120,2142,2123,2145,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_67.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_67.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_67.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_67.cpp,80
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_32.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_32.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_32.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_84.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_84.cpp,2243,2273,2246,2276,"sprintf(cp->ExitExceptionString, ""Signal %d"", sig);","sprintf(cp->ProcessResults[idx].ExitExceptionString, ""Signal %d"", sig);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_68.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_68.cpp,"{
#ifdef SIGSEGV
    case SIGSEGV:
      KWSYSPE_CASE(Fault, ""Segmentation fault"");
      break;
#endif
#ifdef SIGBUS
#if !defined(SIGSEGV) || SIGBUS != SIGSEGV
    case SIGBUS:
      KWSYSPE_CASE(Fault, ""Bus error"");
      break;
#endif
#endif
#ifdef SIGFPE
    case SIGFPE:
      KWSYSPE_CASE(Numerical, ""Floating-point exception"");
      break;
#endif
#ifdef SIGILL
    case SIGILL:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
#endif
#ifdef SIGINT
    case SIGINT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;
#endif
#ifdef SIGABRT
    case SIGABRT:
      KWSYSPE_CASE(Other, ""Child aborted"");
      break;
#endif
#ifdef SIGKILL
    case SIGKILL:
      KWSYSPE_CASE(Other, ""Child killed"");
      break;
#endif
#ifdef SIGTERM
    case SIGTERM:
      KWSYSPE_CASE(Other, ""Child terminated"");
      break;
#endif
#ifdef SIGHUP
    case SIGHUP:
      KWSYSPE_CASE(Other, ""SIGHUP"");
      break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
      KWSYSPE_CASE(Other, ""SIGQUIT"");
      break;
#endif
#ifdef SIGTRAP
    case SIGTRAP:
      KWSYSPE_CASE(Other, ""SIGTRAP"");
      break;
#endif
#ifdef SIGIOT
#if !defined(SIGABRT) || SIGIOT != SIGABRT
    case SIGIOT:
      KWSYSPE_CASE(Other, ""SIGIOT"");
      break;
#endif
#endif
#ifdef SIGUSR1
    case SIGUSR1:
      KWSYSPE_CASE(Other, ""SIGUSR1"");
      break;
#endif
#ifdef SIGUSR2
    case SIGUSR2:
      KWSYSPE_CASE(Other, ""SIGUSR2"");
      break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
      KWSYSPE_CASE(Other, ""SIGPIPE"");
      break;
#endif
#ifdef SIGALRM
    case SIGALRM:
      KWSYSPE_CASE(Other, ""SIGALRM"");
      break;
#endif
#ifdef SIGSTKFLT
    case SIGSTKFLT:
      KWSYSPE_CASE(Other, ""SIGSTKFLT"");
      break;
#endif
#ifdef SIGCHLD
    case SIGCHLD:
      KWSYSPE_CASE(Other, ""SIGCHLD"");
      break;
#elif defined(SIGCLD)
    case SIGCLD:
      KWSYSPE_CASE(Other, ""SIGCLD"");
      break;
#endif
#ifdef SIGCONT
    case SIGCONT:
      KWSYSPE_CASE(Other, ""SIGCONT"");
      break;
#endif
#ifdef SIGSTOP
    case SIGSTOP:
      KWSYSPE_CASE(Other, ""SIGSTOP"");
      break;
#endif
#ifdef SIGTSTP
    case SIGTSTP:
      KWSYSPE_CASE(Other, ""SIGTSTP"");
      break;
#endif
#ifdef SIGTTIN
    case SIGTTIN:
      KWSYSPE_CASE(Other, ""SIGTTIN"");
      break;
#endif
#ifdef SIGTTOU
    case SIGTTOU:
      KWSYSPE_CASE(Other, ""SIGTTOU"");
      break;
#endif
#ifdef SIGURG
    case SIGURG:
      KWSYSPE_CASE(Other, ""SIGURG"");
      break;
#endif
#ifdef SIGXCPU
    case SIGXCPU:
      KWSYSPE_CASE(Other, ""SIGXCPU"");
      break;
#endif
#ifdef SIGXFSZ
    case SIGXFSZ:
      KWSYSPE_CASE(Other, ""SIGXFSZ"");
      break;
#endif
#ifdef SIGVTALRM
    case SIGVTALRM:
      KWSYSPE_CASE(Other, ""SIGVTALRM"");
      break;
#endif
#ifdef SIGPROF
    case SIGPROF:
      KWSYSPE_CASE(Other, ""SIGPROF"");
      break;
#endif
#ifdef SIGWINCH
    case SIGWINCH:
      KWSYSPE_CASE(Other, ""SIGWINCH"");
      break;
#endif
#ifdef SIGPOLL
    case SIGPOLL:
      KWSYSPE_CASE(Other, ""SIGPOLL"");
      break;
#endif
#ifdef SIGIO
#if !defined(SIGPOLL) || SIGIO != SIGPOLL
    case SIGIO:
      KWSYSPE_CASE(Other, ""SIGIO"");
      break;
#endif
#endif
#ifdef SIGPWR
    case SIGPWR:
      KWSYSPE_CASE(Other, ""SIGPWR"");
      break;
#endif
#ifdef SIGSYS
    case SIGSYS:
      KWSYSPE_CASE(Other, ""SIGSYS"");
      break;
#endif
#ifdef SIGUNUSED
#if !defined(SIGSYS) || SIGUNUSED != SIGSYS
    case SIGUNUSED:
      KWSYSPE_CASE(Other, ""SIGUNUSED"");
      break;
#endif
#endif
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Signal %d"", sig);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_68.cpp,"[4, 0, 0, 0, 36, 0, 0, 0, 35, 1, 1, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 0, 0, 37, 0, 78, 77, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_68.cpp,187
7be70ca6cc888df532d2f1560e74d13642730ee5,"KWSys 2017-05-16 (fe1f22ce)

Code extracted from:

    https://gitlab.kitware.com/utils/kwsys.git

at commit fe1f22ceefdae18df33e5bab8483fec7a82d4cee (master).

Upstream Shortlog
-----------------

Adam Weisi (3):
      8a799e36 Process: Improve definition ordering in header file
      7d56ef24 Process: Save results from all children internally
      b7eba998 Process: Add APIs to get results of individual processes

Ben Boeckel (2):
      cea71543 style: remove separator comments
      874dc559 style: help clang-format near macros",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_33.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_33.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_33.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_85.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_85.cpp,2120,2142,2123,2145,"_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);","_snprintf(cp->ProcessResults[idx].ExitExceptionString,
                KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_69.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_69.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt"");
      break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)"");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero"");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)"");
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation"");
      break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow"");
      break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed"");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow"");
      break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)"");
      break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)"");
      break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero"");
      break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow"");
      break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment"");
      break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation"");
      break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error"");
      break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde"");
      break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception"");
      break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition"");
      break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded"");
      break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow"");
      break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction"");
      break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction"");
      break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      _snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE,
                ""Exit code 0x%x\n"", code);
      break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_69.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 48, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_69.cpp,80
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_35.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_35.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_35.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_87.cpp,141,136,143,141,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_70.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_70.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_70.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_70.cpp,13
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_36.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_36.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_36.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_88.cpp,476,475,478,477,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_71.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_71.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_71.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_71.cpp,58
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_37.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_89.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_89.cpp,2107,2107,2109,2109,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_72.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_72.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_72.cpp,20
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_37.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_37.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_37.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_90.cpp,2318,2318,2320,2320,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_73.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_73.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_73.cpp,15
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_38.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_38.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_38.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_92.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_92.cpp,297,297,299,299,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_74.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_74.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_74.cpp,21
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/url.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_40.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_40.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_40.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_94.cpp,641,644,644,648,,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_75.cpp,"f(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }
  else {
    result = Curl_init_userdefined(&data->set);

    data->state.headersize=HEADERSIZE;

    Curl_convert_init(data);

    Curl_initinfo(data);

    /* most recent connection is not yet defined */
    data->state.lastconnect = NULL;

    data->progress.flags |= PGRS_HIDE;
    data->state.current_speed = -1; /* init to negative == impossible */

    data->wildcard.state = CURLWC_INIT;
    data->wildcard.filelist = NULL;
    data->set.fnmatch = ZERO_NULL;
    data->set.maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */

    Curl_http2_init_state(&data->state);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_75.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 14, 0, 8, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_75.cpp,25
299975908ada992800791fac7f3739050e0ae2a9,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2017-04-19 (d957e218)

Resolve conflicts in `CMakeLists.txt` in favor of the upstream version.
We will re-apply our logic as needed in following commits.",[],Utilities/cmcurl/lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_42.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_42.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_42.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_96.cpp,720,741,723,744,,"snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_76.cpp,"{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
#else
  return snprintf(buffer, size, ""CyaSSL/%s"", ""<1.8.8"");
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_76.cpp,"[0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 13, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_76.cpp,3
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_44.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_44.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_44.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_98.cpp,141,136,143,141,"aprintf(""%s:%d"", hostname, conn->port);","snprintf(buf, len, ""%ld%s"", conn->port, hostname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_77.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_77.cpp,"{
  const char *hostname;

  if(conn->bits.socksproxy)
    hostname = conn->socks_proxy.host.name;
  else if(conn->bits.httpproxy)
    hostname = conn->http_proxy.host.name;
  else if(conn->bits.conn_to_host)
    hostname = conn->conn_to_host.name;
  else
    hostname = conn->host.name;

  return aprintf(""%s:%d"", hostname, conn->port);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_77.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 41, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 1, 0, 1, 0, 0, 4, 2, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_77.cpp,13
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_45.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_45.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_45.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_99.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_99.cpp,476,475,478,477,"snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_78.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_78.cpp,"{
    time_t filetime;
    struct tm buffer;
    const struct tm *tm = &buffer;
    snprintf(buf, sizeof(data->state.buffer),
             ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", expected_size);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(result)
      return result;

    result = Curl_client_write(conn, CLIENTWRITE_BOTH,
                               (char *)""Accept-ranges: bytes\r\n"", 0);
    if(result)
      return result;

    filetime = (time_t)statbuf.st_mtime;
    result = Curl_gmtime(filetime, &buffer);
    if(result)
      return result;

    /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
    snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
    result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    if(!result)
      /* set the file size to make it available post transfer */
      Curl_pgrsSetDownloadSize(data, expected_size);
    return result;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_78.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 1, 85, 0, 0, 3, 3, 0, 0, 1, 11, 0, 0, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 1, 53, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 1, 0, 8, 0, 0, 8, 0, 31, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_78.cpp,58
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_100.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_100.cpp,2107,2107,2109,2109,"snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);","snprintf(buf, CURL_BUFSIZE(conn->data->set.buffer_size),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_79.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_79.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        /* using the good old yacc/bison yuck */
        snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        data->info.filetime = (long)curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_79.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 16, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_79.cpp,20
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_46.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_46.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_46.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_101.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_101.cpp,2318,2318,2320,2320,"snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);","snprintf(buf, CURL_BUFSIZE(data->set.buffer_size),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_80.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_80.cpp,"{
      snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" CURL_FORMAT_CURL_OFF_T ""\r\n"", filesize);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_80.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 13, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_80.cpp,15
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_47.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_47.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_47.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_103.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_103.cpp,297,297,299,299,"f(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);","f(data->state.buffer, CURL_BUFSIZE(data->set.buffer_size),
           ""%s:%s"", user, pwd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_81.cpp,"{
  size_t size = 0;
  char *authorization = NULL;
  struct Curl_easy *data = conn->data;
  char **userp;
  const char *user;
  const char *pwd;
  CURLcode result;

  if(proxy) {
    userp = &conn->allocptr.proxyuserpwd;
    user = conn->http_proxy.user;
    pwd = conn->http_proxy.passwd;
  }
  else {
    userp = &conn->allocptr.userpwd;
    user = conn->user;
    pwd = conn->passwd;
  }

  snprintf(data->state.buffer, sizeof(data->state.buffer), ""%s:%s"", user, pwd);

  result = Curl_base64_encode(data,
                              data->state.buffer, strlen(data->state.buffer),
                              &authorization, &size);
  if(result)
    return result;

  if(!authorization)
    return CURLE_REMOTE_ACCESS_DENIED;

  free(*userp);
  *userp = aprintf(""%sAuthorization: Basic %s\r\n"",
                   proxy ? ""Proxy-"" : """",
                   authorization);
  free(authorization);
  if(!*userp)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_81.cpp,"[4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 0, 0, 0, 2, 89, 0, 0, 7, 7, 0, 0, 3, 5, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 42, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 5, 5, 2, 0, 7, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_81.cpp,21
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/url.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_49.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_49.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_49.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_105.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_105.cpp,641,644,644,648,,"DEBUGF(fprintf(stderr, ""Error: malloc of buffer failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_82.cpp,"f(!data->state.headerbuff) {
    DEBUGF(fprintf(stderr, ""Error: malloc of headerbuff failed\n""));
    result = CURLE_OUT_OF_MEMORY;
  }
  else {
    result = Curl_init_userdefined(&data->set);

    data->state.headersize=HEADERSIZE;

    Curl_convert_init(data);

    Curl_initinfo(data);

    /* most recent connection is not yet defined */
    data->state.lastconnect = NULL;

    data->progress.flags |= PGRS_HIDE;
    data->state.current_speed = -1; /* init to negative == impossible */

    data->wildcard.state = CURLWC_INIT;
    data->wildcard.filelist = NULL;
    data->set.fnmatch = ZERO_NULL;
    data->set.maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */

    Curl_http2_init_state(&data->state);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_82.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 58, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 0, 0, 14, 0, 8, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_82.cpp,25
fd7d521c9d70655618db8232d45e5aaf81700f91,"curl 2017-04-19 (d957e218)

Code extracted from:

    https://github.com/curl/curl.git

at commit d957e2189fdc73cef0ff3d1fb58043d354754449 (curl-7_54_0).",[],lib/vtls/cyassl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_51.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_51.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_51.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_107.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_107.cpp,720,741,723,744,,"snprintf(buffer, size, ""wolfSSL/%s"", wolfSSL_lib_version());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_83.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_83.cpp,"{
#ifdef WOLFSSL_VERSION
  return snprintf(buffer, size, ""wolfSSL/%s"", WOLFSSL_VERSION);
#elif defined(CYASSL_VERSION)
  return snprintf(buffer, size, ""CyaSSL/%s"", CYASSL_VERSION);
#else
  return snprintf(buffer, size, ""CyaSSL/%s"", ""<1.8.8"");
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_83.cpp,"[0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 13, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_83.cpp,3
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_118.cpp,302,321,312,324,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_84.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_84.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_84.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_84.cpp,25
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_119.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_119.cpp,772,1486,785,1496,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_85.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_85.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_85.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_85.cpp,19
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_59.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_59.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_120.cpp,932,1645,945,1655,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_86.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_86.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_86.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_86.cpp,21
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_122.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_122.cpp,938,938,939,939,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_87.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_87.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_87.cpp,66
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_123.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_123.cpp,1041,1041,1042,1042,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_88.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_88.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_88.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_88.cpp,169
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_60.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_60.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_124.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_124.cpp,1067,1067,1068,1068,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_89.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_89.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_89.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_89.cpp,195
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_126.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_126.cpp,803,802,804,803,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_90.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_90.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_90.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_90.cpp,50
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_127.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_127.cpp,875,874,876,875,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_91.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_91.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_91.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_91.cpp,122
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_61.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_61.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_128.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_128.cpp,901,900,902,901,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_92.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_92.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_92.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_92.cpp,148
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,789,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_93.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_93.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_93.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_93.cpp,14
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,820,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_94.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_94.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_94.cpp,45
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,826,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_95.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_95.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_95.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_95.cpp,51
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,832,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_96.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_96.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_96.cpp,57
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,865,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_97.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_97.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_97.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_97.cpp,18
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,883,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_98.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_98.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_98.cpp,36
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,889,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_99.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_99.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_99.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_99.cpp,42
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_65.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_65.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_135.cpp,763,744,920,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_100.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_100.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_100.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_100.cpp,12
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_152.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_152.cpp,935,989,939,991,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_101.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_101.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_101.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_101.cpp,53
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_154.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_154.cpp,1128,1183,1129,1184,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_102.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_102.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_102.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_102.cpp,23
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_154.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_154.cpp,1128,1183,1133,1191,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_103.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_103.cpp,"{
	const struct archive_entry_header_ustar	*header;
	char	tartype;
	int     err = ARCHIVE_OK;

	header = (const struct archive_entry_header_ustar *)h;
	if (header->linkname[0])
		archive_strncpy(&(tar->entry_linkpath),
		    header->linkname, sizeof(header->linkname));
	else
		archive_string_empty(&(tar->entry_linkpath));

	/* Parse out the numeric fields (all are octal) */
	archive_entry_set_mode(entry,
		(mode_t)tar_atol(header->mode, sizeof(header->mode)));
	archive_entry_set_uid(entry, tar_atol(header->uid, sizeof(header->uid)));
	archive_entry_set_gid(entry, tar_atol(header->gid, sizeof(header->gid)));
	tar->entry_bytes_remaining = tar_atol(header->size, sizeof(header->size));
	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
	archive_entry_set_mtime(entry, tar_atol(header->mtime, sizeof(header->mtime)), 0);

	/* Handle the tar type flag appropriately. */
	tartype = header->typeflag[0];

	switch (tartype) {
	case '1': /* Hard link */
		if (archive_entry_copy_hardlink_l(entry, tar->entry_linkpath.s,
		    archive_strlen(&(tar->entry_linkpath)), tar->sconv) != 0) {
			err = set_conversion_failed_error(a, tar->sconv,
			    ""Linkname"");
			if (err == ARCHIVE_FATAL)
				return (err);
		}
		/*
		 * The following may seem odd, but: Technically, tar
		 * does not store the file type for a ""hard link""
		 * entry, only the fact that it is a hard link.  So, I
		 * leave the type zero normally.  But, pax interchange
		 * format allows hard links to have data, which
		 * implies that the underlying entry is a regular
		 * file.
		 */
		if (archive_entry_size(entry) > 0)
			archive_entry_set_filetype(entry, AE_IFREG);

		/*
		 * A tricky point: Traditionally, tar readers have
		 * ignored the size field when reading hardlink
		 * entries, and some writers put non-zero sizes even
		 * though the body is empty.  POSIX blessed this
		 * convention in the 1988 standard, but broke with
		 * this tradition in 2001 by permitting hardlink
		 * entries to store valid bodies in pax interchange
		 * format, but not in ustar format.  Since there is no
		 * hard and fast way to distinguish pax interchange
		 * from earlier archives (the 'x' and 'g' entries are
		 * optional, after all), we need a heuristic.
		 */
		if (archive_entry_size(entry) == 0) {
			/* If the size is already zero, we're done. */
		}  else if (a->archive.archive_format
		    == ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE) {
			/* Definitely pax extended; must obey hardlink size. */
		} else if (a->archive.archive_format == ARCHIVE_FORMAT_TAR
		    || a->archive.archive_format == ARCHIVE_FORMAT_TAR_GNUTAR)
		{
			/* Old-style or GNU tar: we must ignore the size. */
			archive_entry_set_size(entry, 0);
			tar->entry_bytes_remaining = 0;
		} else if (archive_read_format_tar_bid(a, 50) > 50) {
			/*
			 * We don't know if it's pax: If the bid
			 * function sees a valid ustar header
			 * immediately following, then let's ignore
			 * the hardlink size.
			 */
			archive_entry_set_size(entry, 0);
			tar->entry_bytes_remaining = 0;
		}
		/*
		 * TODO: There are still two cases I'd like to handle:
		 *   = a ustar non-pax archive with a hardlink entry at
		 *     end-of-archive.  (Look for block of nulls following?)
		 *   = a pax archive that has not seen any pax headers
		 *     and has an entry which is a hardlink entry storing
		 *     a body containing an uncompressed tar archive.
		 * The first is worth addressing; I don't see any reliable
		 * way to deal with the second possibility.
		 */
		break;
	case '2': /* Symlink */
		archive_entry_set_filetype(entry, AE_IFLNK);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		if (archive_entry_copy_symlink_l(entry, tar->entry_linkpath.s,
		    archive_strlen(&(tar->entry_linkpath)), tar->sconv) != 0) {
			err = set_conversion_failed_error(a, tar->sconv,
			    ""Linkname"");
			if (err == ARCHIVE_FATAL)
				return (err);
		}
		break;
	case '3': /* Character device */
		archive_entry_set_filetype(entry, AE_IFCHR);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '4': /* Block device */
		archive_entry_set_filetype(entry, AE_IFBLK);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '5': /* Dir */
		archive_entry_set_filetype(entry, AE_IFDIR);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '6': /* FIFO device */
		archive_entry_set_filetype(entry, AE_IFIFO);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case 'D': /* GNU incremental directory type */
		/*
		 * No special handling is actually required here.
		 * It might be nice someday to preprocess the file list and
		 * provide it to the client, though.
		 */
		archive_entry_set_filetype(entry, AE_IFDIR);
		break;
	case 'M': /* GNU ""Multi-volume"" (remainder of file from last archive)*/
		/*
		 * As far as I can tell, this is just like a regular file
		 * entry, except that the contents should be _appended_ to
		 * the indicated file at the indicated offset.  This may
		 * require some API work to fully support.
		 */
		break;
	case 'N': /* Old GNU ""long filename"" entry. */
		/* The body of this entry is a script for renaming
		 * previously-extracted entries.  Ugh.  It will never
		 * be supported by libarchive. */
		archive_entry_set_filetype(entry, AE_IFREG);
		break;
	case 'S': /* GNU sparse files */
		/*
		 * Sparse files are really just regular files with
		 * sparse information in the extended area.
		 */
		/* FALLTHROUGH */
	default: /* Regular file  and non-standard types */
		/*
		 * Per POSIX: non-recognized types should always be
		 * treated as regular files.
		 */
		archive_entry_set_filetype(entry, AE_IFREG);
		break;
	}
	return (err);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_103.cpp,"[11, 0, 0, 0, 10, 0, 3, 1, 10, 1, 14, 0, 0, 0, 2, 233, 0, 0, 3, 3, 0, 0, 1, 38, 0, 0, 0, 0, 1, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 153, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 12, 11, 1, 0, 44, 0, 0, 39, 3, 86, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_103.cpp,27
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_155.cpp,1803,1944,1819,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_104.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_104.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_104.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_104.cpp,109
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_155.cpp,1803,1944,1824,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_105.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_105.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_105.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_105.cpp,114
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_155.cpp,1803,1944,1843,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_106.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_106.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_106.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_106.cpp,133
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_72.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_72.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_155.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_155.cpp,1803,1944,1848,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_107.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_107.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_107.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_107.cpp,138
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_158.cpp,255,254,262,260,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_108.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_108.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_108.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_108.cpp,52
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_158.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_158.cpp,255,254,274,265,,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_109.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_109.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_109.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_109.cpp,0
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_73.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_73.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_159.cpp,285,293,286,294,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_110.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_110.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_110.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_110.cpp,76
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_160.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_160.cpp,1526,1524,1536,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_111.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_111.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_111.cpp,121
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_160.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_160.cpp,1526,1524,1543,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_112.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_112.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_112.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_112.cpp,128
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_161.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_161.cpp,1685,1653,1700,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_113.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_113.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_113.cpp,116
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_74.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_74.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_161.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_161.cpp,1685,1653,1710,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_114.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_114.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_114.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_114.cpp,126
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_162.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_162.cpp,418,418,417,430,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_115.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_115.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_115.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_115.cpp,0
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_75.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_75.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_163.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_163.cpp,715,739,720,742,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_116.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_116.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_116.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_116.cpp,300
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2413,2598,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_117.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_117.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_117.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_117.cpp,49
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2427,2628,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_118.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_118.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_118.cpp,63
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2437,2659,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_119.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_119.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_119.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_119.cpp,73
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2445,2672,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_120.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_120.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_120.cpp,81
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2353,2467,,"archive_string_sprintf(a_estr, errstr, path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_121.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_121.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_121.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_121.cpp,0
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2393,2572,,"fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_122.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_122.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_122.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_122.cpp,29
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2393,2581,,"fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_123.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_123.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_123.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_123.cpp,29
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2393,2650,,"fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_124.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_124.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_124.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_124.cpp,29
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2393,2680,,"fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_125.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_125.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_125.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_125.cpp,29
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2460,2698,,"fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_126.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_126.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_126.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_126.cpp,0
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_171.cpp,2351,2457,2463,2727,,"archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_127.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_127.cpp,"/*-
 * Copyright (c) 2003-2010 Tim Kientzle
 * Copyright (c) 2012 Michihiro NAKAJIMA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include ""archive_platform.h""
__FBSDID(""$FreeBSD$"");

#if !defined(_WIN32) || defined(__CYGWIN__)

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_ACL_H
#include <sys/acl.h>
#endif
#ifdef HAVE_SYS_EXTATTR_H
#include <sys/extattr.h>
#endif
#if defined(HAVE_SYS_XATTR_H)
#include <sys/xattr.h>
#elif defined(HAVE_ATTR_XATTR_H)
#include <attr/xattr.h>
#endif
#ifdef HAVE_SYS_EA_H
#include <sys/ea.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_UTIME_H
#include <sys/utime.h>
#endif
#ifdef HAVE_COPYFILE_H
#include <copyfile.h>
#endif
#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_GRP_H
#include <grp.h>
#endif
#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_LINUX_FS_H
#include <linux/fs.h>	/* for Linux file flags */
#endif
/*
 * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.
 * As the include guards don't agree, the order of include is important.
 */
#ifdef HAVE_LINUX_EXT2_FS_H
#include <linux/ext2_fs.h>	/* for Linux file flags */
#endif
#if defined(HAVE_EXT2FS_EXT2_FS_H) && !defined(__CYGWIN__)
#include <ext2fs/ext2_fs.h>	/* Linux file flags, broken on Cygwin */
#endif
#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#ifdef HAVE_PWD_H
#include <pwd.h>
#endif
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_UTIME_H
#include <utime.h>
#endif
#ifdef F_GETTIMES /* Tru64 specific */
#include <sys/fcntl1.h>
#endif

#if __APPLE__
#include <TargetConditionals.h>
#if TARGET_OS_MAC && !TARGET_OS_EMBEDDED && HAVE_QUARANTINE_H
#include <quarantine.h>
#define HAVE_QUARANTINE 1
#endif
#endif

#ifdef HAVE_ZLIB_H
#include <cm_zlib.h>
#endif

/* TODO: Support Mac OS 'quarantine' feature.  This is really just a
 * standard tag to mark files that have been downloaded as ""tainted"".
 * On Mac OS, we should mark the extracted files as tainted if the
 * archive being read was tainted.  Windows has a similar feature; we
 * should investigate ways to support this generically. */

#include ""archive.h""
#include ""archive_acl_private.h""
#include ""archive_string.h""
#include ""archive_endian.h""
#include ""archive_entry.h""
#include ""archive_private.h""
#include ""archive_write_disk_private.h""

#ifndef O_BINARY
#define O_BINARY 0
#endif
#ifndef O_CLOEXEC
#define O_CLOEXEC	0
#endif

struct fixup_entry {
	struct fixup_entry	*next;
	struct archive_acl	 acl;
	mode_t			 mode;
	int64_t			 atime;
	int64_t                  birthtime;
	int64_t			 mtime;
	int64_t			 ctime;
	unsigned long		 atime_nanos;
	unsigned long            birthtime_nanos;
	unsigned long		 mtime_nanos;
	unsigned long		 ctime_nanos;
	unsigned long		 fflags_set;
	size_t			 mac_metadata_size;
	void			*mac_metadata;
	int			 fixup; /* bitmask of what needs fixing */
	char			*name;
};

/*
 * We use a bitmask to track which operations remain to be done for
 * this file.  In particular, this helps us avoid unnecessary
 * operations when it's possible to take care of one step as a
 * side-effect of another.  For example, mkdir() can specify the mode
 * for the newly-created object but symlink() cannot.  This means we
 * can skip chmod() if mkdir() succeeded, but we must explicitly
 * chmod() if we're trying to create a directory that already exists
 * (mkdir() failed) or if we're restoring a symlink.  Similarly, we
 * need to verify UID/GID before trying to restore SUID/SGID bits;
 * that verification can occur explicitly through a stat() call or
 * implicitly because of a successful chown() call.
 */
#define	TODO_MODE_FORCE		0x40000000
#define	TODO_MODE_BASE		0x20000000
#define	TODO_SUID		0x10000000
#define	TODO_SUID_CHECK		0x08000000
#define	TODO_SGID		0x04000000
#define	TODO_SGID_CHECK		0x02000000
#define	TODO_APPLEDOUBLE	0x01000000
#define	TODO_MODE		(TODO_MODE_BASE|TODO_SUID|TODO_SGID)
#define	TODO_TIMES		ARCHIVE_EXTRACT_TIME
#define	TODO_OWNER		ARCHIVE_EXTRACT_OWNER
#define	TODO_FFLAGS		ARCHIVE_EXTRACT_FFLAGS
#define	TODO_ACLS		ARCHIVE_EXTRACT_ACL
#define	TODO_XATTR		ARCHIVE_EXTRACT_XATTR
#define	TODO_MAC_METADATA	ARCHIVE_EXTRACT_MAC_METADATA
#define	TODO_HFS_COMPRESSION	ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED

struct archive_write_disk {
	struct archive	archive;

	mode_t			 user_umask;
	struct fixup_entry	*fixup_list;
	struct fixup_entry	*current_fixup;
	int64_t			 user_uid;
	int			 skip_file_set;
	int64_t			 skip_file_dev;
	int64_t			 skip_file_ino;
	time_t			 start_time;

	int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid);
	void  (*cleanup_gid)(void *private);
	void			*lookup_gid_data;
	int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid);
	void  (*cleanup_uid)(void *private);
	void			*lookup_uid_data;

	/*
	 * Full path of last file to satisfy symlink checks.
	 */
	struct archive_string	path_safe;

	/*
	 * Cached stat data from disk for the current entry.
	 * If this is valid, pst points to st.  Otherwise,
	 * pst is null.
	 */
	struct stat		 st;
	struct stat		*pst;

	/* Information about the object being restored right now. */
	struct archive_entry	*entry; /* Entry being extracted. */
	char			*name; /* Name of entry, possibly edited. */
	struct archive_string	 _name_data; /* backing store for 'name' */
	/* Tasks remaining for this object. */
	int			 todo;
	/* Tasks deferred until end-of-archive. */
	int			 deferred;
	/* Options requested by the client. */
	int			 flags;
	/* Handle for the file we're restoring. */
	int			 fd;
	/* Current offset for writing data to the file. */
	int64_t			 offset;
	/* Last offset actually written to disk. */
	int64_t			 fd_offset;
	/* Total bytes actually written to files. */
	int64_t			 total_bytes_written;
	/* Maximum size of file, -1 if unknown. */
	int64_t			 filesize;
	/* Dir we were in before this restore; only for deep paths. */
	int			 restore_pwd;
	/* Mode we should use for this entry; affected by _PERM and umask. */
	mode_t			 mode;
	/* UID/GID to use in restoring this entry. */
	int64_t			 uid;
	int64_t			 gid;
	/*
	 * HFS+ Compression.
	 */
	/* Xattr ""com.apple.decmpfs"". */
	uint32_t		 decmpfs_attr_size;
	unsigned char		*decmpfs_header_p;
	/* ResourceFork set options used for fsetxattr. */
	int			 rsrc_xattr_options;
	/* Xattr ""com.apple.ResourceFork"". */
	unsigned char		*resource_fork;
	size_t			 resource_fork_allocated_size;
	unsigned int		 decmpfs_block_count;
	uint32_t		*decmpfs_block_info;
	/* Buffer for compressed data. */
	unsigned char		*compressed_buffer;
	size_t			 compressed_buffer_size;
	size_t			 compressed_buffer_remaining;
	/* The offset of the ResourceFork where compressed data will
	 * be placed. */
	uint32_t		 compressed_rsrc_position;
	uint32_t		 compressed_rsrc_position_v;
	/* Buffer for uncompressed data. */
	char			*uncompressed_buffer;
	size_t			 block_remaining_bytes;
	size_t			 file_remaining_bytes;
#ifdef HAVE_ZLIB_H
	z_stream		 stream;
	int			 stream_valid;
	int			 decmpfs_compression_level;
#endif
};

/*
 * Default mode for dirs created automatically (will be modified by umask).
 * Note that POSIX specifies 0777 for implicitly-created dirs, ""modified
 * by the process' file creation mask.""
 */
#define	DEFAULT_DIR_MODE 0777
/*
 * Dir modes are restored in two steps:  During the extraction, the permissions
 * in the archive are modified to match the following limits.  During
 * the post-extract fixup pass, the permissions from the archive are
 * applied.
 */
#define	MINIMUM_DIR_MODE 0700
#define	MAXIMUM_DIR_MODE 0775

/*
 * Maxinum uncompressed size of a decmpfs block.
 */
#define MAX_DECMPFS_BLOCK_SIZE	(64 * 1024)
/*
 * HFS+ compression type.
 */
#define CMP_XATTR		3/* Compressed data in xattr. */
#define CMP_RESOURCE_FORK	4/* Compressed data in resource fork. */
/*
 * HFS+ compression resource fork.
 */
#define RSRC_H_SIZE	260	/* Base size of Resource fork header. */
#define RSRC_F_SIZE	50	/* Size of Resource fork footer. */
/* Size to write compressed data to resource fork. */
#define COMPRESSED_W_SIZE	(64 * 1024)
/* decmpfs difinitions. */
#define MAX_DECMPFS_XATTR_SIZE		3802
#ifndef DECMPFS_XATTR_NAME
#define DECMPFS_XATTR_NAME		""com.apple.decmpfs""
#endif
#define DECMPFS_MAGIC			0x636d7066
#define DECMPFS_COMPRESSION_MAGIC	0
#define DECMPFS_COMPRESSION_TYPE	4
#define DECMPFS_UNCOMPRESSED_SIZE	8
#define DECMPFS_HEADER_SIZE		16

#define HFS_BLOCKS(s)	((s) >> 12)

static int	check_symlinks(struct archive_write_disk *);
static int	create_filesystem_object(struct archive_write_disk *);
static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
static void	edit_deep_directories(struct archive_write_disk *ad);
#endif
static int	cleanup_pathname(struct archive_write_disk *);
static int	create_dir(struct archive_write_disk *, char *);
static int	create_parent_dir(struct archive_write_disk *, char *);
static ssize_t	hfs_write_data_block(struct archive_write_disk *,
		    const char *, size_t);
static int	fixup_appledouble(struct archive_write_disk *, const char *);
static int	older(struct stat *, struct archive_entry *);
static int	restore_entry(struct archive_write_disk *);
static int	set_mac_metadata(struct archive_write_disk *, const char *,
				 const void *, size_t);
static int	set_xattrs(struct archive_write_disk *);
static int	clear_nochange_fflags(struct archive_write_disk *);
static int	set_fflags(struct archive_write_disk *);
static int	set_fflags_platform(struct archive_write_disk *, int fd,
		    const char *name, mode_t mode,
		    unsigned long fflags_set, unsigned long fflags_clear);
static int	set_ownership(struct archive_write_disk *);
static int	set_mode(struct archive_write_disk *, int mode);
static int	set_time(int, int, const char *, time_t, long, time_t, long);
static int	set_times(struct archive_write_disk *, int, int, const char *,
		    time_t, long, time_t, long, time_t, long, time_t, long);
static int	set_times_from_entry(struct archive_write_disk *);
static struct fixup_entry *sort_dir_list(struct fixup_entry *p);
static ssize_t	write_data_block(struct archive_write_disk *,
		    const char *, size_t);

static struct archive_vtable *archive_write_disk_vtable(void);

static int	_archive_write_disk_close(struct archive *);
static int	_archive_write_disk_free(struct archive *);
static int	_archive_write_disk_header(struct archive *, struct archive_entry *);
static int64_t	_archive_write_disk_filter_bytes(struct archive *, int);
static int	_archive_write_disk_finish_entry(struct archive *);
static ssize_t	_archive_write_disk_data(struct archive *, const void *, size_t);
static ssize_t	_archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);

static int
lazy_stat(struct archive_write_disk *a)
{
	if (a->pst != NULL) {
		/* Already have stat() data available. */
		return (ARCHIVE_OK);
	}
#ifdef HAVE_FSTAT
	if (a->fd >= 0 && fstat(a->fd, &a->st) == 0) {
		a->pst = &a->st;
		return (ARCHIVE_OK);
	}
#endif
	/*
	 * XXX At this point, symlinks should not be hit, otherwise
	 * XXX a race occurred.  Do we want to check explicitly for that?
	 */
	if (lstat(a->name, &a->st) == 0) {
		a->pst = &a->st;
		return (ARCHIVE_OK);
	}
	archive_set_error(&a->archive, errno, ""Couldn't stat file"");
	return (ARCHIVE_WARN);
}

static struct archive_vtable *
archive_write_disk_vtable(void)
{
	static struct archive_vtable av;
	static int inited = 0;

	if (!inited) {
		av.archive_close = _archive_write_disk_close;
		av.archive_filter_bytes = _archive_write_disk_filter_bytes;
		av.archive_free = _archive_write_disk_free;
		av.archive_write_header = _archive_write_disk_header;
		av.archive_write_finish_entry
		    = _archive_write_disk_finish_entry;
		av.archive_write_data = _archive_write_disk_data;
		av.archive_write_data_block = _archive_write_disk_data_block;
		inited = 1;
	}
	return (&av);
}

static int64_t
_archive_write_disk_filter_bytes(struct archive *_a, int n)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	(void)n; /* UNUSED */
	if (n == -1 || n == 0)
		return (a->total_bytes_written);
	return (-1);
}


int
archive_write_disk_set_options(struct archive *_a, int flags)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;

	a->flags = flags;
	return (ARCHIVE_OK);
}


/*
 * Extract this entry to disk.
 *
 * TODO: Validate hardlinks.  According to the standards, we're
 * supposed to check each extracted hardlink and squawk if it refers
 * to a file that we didn't restore.  I'm not entirely convinced this
 * is a good idea, but more importantly: Is there any way to validate
 * hardlinks without keeping a complete list of filenames from the
 * entire archive?? Ugh.
 *
 */
static int
_archive_write_disk_header(struct archive *_a, struct archive_entry *entry)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	struct fixup_entry *fe;
	int ret, r;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_disk_header"");
	archive_clear_error(&a->archive);
	if (a->archive.state & ARCHIVE_STATE_DATA) {
		r = _archive_write_disk_finish_entry(&a->archive);
		if (r == ARCHIVE_FATAL)
			return (r);
	}

	/* Set up for this particular entry. */
	a->pst = NULL;
	a->current_fixup = NULL;
	a->deferred = 0;
	if (a->entry) {
		archive_entry_free(a->entry);
		a->entry = NULL;
	}
	a->entry = archive_entry_clone(entry);
	a->fd = -1;
	a->fd_offset = 0;
	a->offset = 0;
	a->restore_pwd = -1;
	a->uid = a->user_uid;
	a->mode = archive_entry_mode(a->entry);
	if (archive_entry_size_is_set(a->entry))
		a->filesize = archive_entry_size(a->entry);
	else
		a->filesize = -1;
	archive_strcpy(&(a->_name_data), archive_entry_pathname(a->entry));
	a->name = a->_name_data.s;
	archive_clear_error(&a->archive);

	/*
	 * Clean up the requested path.  This is necessary for correct
	 * dir restores; the dir restore logic otherwise gets messed
	 * up by nonsense like ""dir/."".
	 */
	ret = cleanup_pathname(a);
	if (ret != ARCHIVE_OK)
		return (ret);

	/*
	 * Query the umask so we get predictable mode settings.
	 * This gets done on every call to _write_header in case the
	 * user edits their umask during the extraction for some
	 * reason.
	 */
	umask(a->user_umask = umask(0));

	/* Figure out what we need to do for this entry. */
	a->todo = TODO_MODE_BASE;
	if (a->flags & ARCHIVE_EXTRACT_PERM) {
		a->todo |= TODO_MODE_FORCE; /* Be pushy about permissions. */
		/*
		 * SGID requires an extra ""check"" step because we
		 * cannot easily predict the GID that the system will
		 * assign.  (Different systems assign GIDs to files
		 * based on a variety of criteria, including process
		 * credentials and the gid of the enclosing
		 * directory.)  We can only restore the SGID bit if
		 * the file has the right GID, and we only know the
		 * GID if we either set it (see set_ownership) or if
		 * we've actually called stat() on the file after it
		 * was restored.  Since there are several places at
		 * which we might verify the GID, we need a TODO bit
		 * to keep track.
		 */
		if (a->mode & S_ISGID)
			a->todo |= TODO_SGID | TODO_SGID_CHECK;
		/*
		 * Verifying the SUID is simpler, but can still be
		 * done in multiple ways, hence the separate ""check"" bit.
		 */
		if (a->mode & S_ISUID)
			a->todo |= TODO_SUID | TODO_SUID_CHECK;
	} else {
		/*
		 * User didn't request full permissions, so don't
		 * restore SUID, SGID bits and obey umask.
		 */
		a->mode &= ~S_ISUID;
		a->mode &= ~S_ISGID;
		a->mode &= ~S_ISVTX;
		a->mode &= ~a->user_umask;
	}
	if (a->flags & ARCHIVE_EXTRACT_OWNER)
		a->todo |= TODO_OWNER;
	if (a->flags & ARCHIVE_EXTRACT_TIME)
		a->todo |= TODO_TIMES;
	if (a->flags & ARCHIVE_EXTRACT_ACL) {
		if (archive_entry_filetype(a->entry) == AE_IFDIR)
			a->deferred |= TODO_ACLS;
		else
			a->todo |= TODO_ACLS;
	}
	if (a->flags & ARCHIVE_EXTRACT_MAC_METADATA) {
		if (archive_entry_filetype(a->entry) == AE_IFDIR)
			a->deferred |= TODO_MAC_METADATA;
		else
			a->todo |= TODO_MAC_METADATA;
	}
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	if ((a->flags & ARCHIVE_EXTRACT_NO_HFS_COMPRESSION) == 0) {
		unsigned long set, clear;
		archive_entry_fflags(a->entry, &set, &clear);
		if ((set & ~clear) & UF_COMPRESSED) {
			a->todo |= TODO_HFS_COMPRESSION;
			a->decmpfs_block_count = (unsigned)-1;
		}
	}
	if ((a->flags & ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED) != 0 &&
	    (a->mode & AE_IFMT) == AE_IFREG && a->filesize > 0) {
		a->todo |= TODO_HFS_COMPRESSION;
		a->decmpfs_block_count = (unsigned)-1;
	}
	{
		const char *p;

		/* Check if the current file name is a type of the
		 * resource fork file. */
		p = strrchr(a->name, '/');
		if (p == NULL)
			p = a->name;
		else
			p++;
		if (p[0] == '.' && p[1] == '_') {
			/* Do not compress ""._XXX"" files. */
			a->todo &= ~TODO_HFS_COMPRESSION;
			if (a->filesize > 0)
				a->todo |= TODO_APPLEDOUBLE;
		}
	}
#endif

	if (a->flags & ARCHIVE_EXTRACT_XATTR)
		a->todo |= TODO_XATTR;
	if (a->flags & ARCHIVE_EXTRACT_FFLAGS)
		a->todo |= TODO_FFLAGS;
	if (a->flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS) {
		ret = check_symlinks(a);
		if (ret != ARCHIVE_OK)
			return (ret);
	}
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
	/* If path exceeds PATH_MAX, shorten the path. */
	edit_deep_directories(a);
#endif

	ret = restore_entry(a);

#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	/*
	 * Check if the filesystem the file is restoring on supports
	 * HFS+ Compression. If not, cancel HFS+ Compression.
	 */
	if (a->todo | TODO_HFS_COMPRESSION) {
		/*
		 * NOTE: UF_COMPRESSED is ignored even if the filesystem
		 * supports HFS+ Compression because the file should
		 * have at least an extended attriute ""com.apple.decmpfs""
		 * before the flag is set to indicate that the file have
		 * been compressed. If hte filesystem does not support
		 * HFS+ Compression the system call will fail.
		 */
		if (a->fd < 0 || fchflags(a->fd, UF_COMPRESSED) != 0)
			a->todo &= ~TODO_HFS_COMPRESSION;
	}
#endif

	/*
	 * TODO: There are rumours that some extended attributes must
	 * be restored before file data is written.  If this is true,
	 * then we either need to write all extended attributes both
	 * before and after restoring the data, or find some rule for
	 * determining which must go first and which last.  Due to the
	 * many ways people are using xattrs, this may prove to be an
	 * intractable problem.
	 */

#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
		a->restore_pwd = -1;
	}
#endif

	/*
	 * Fixup uses the unedited pathname from archive_entry_pathname(),
	 * because it is relative to the base dir and the edited path
	 * might be relative to some intermediate dir as a result of the
	 * deep restore logic.
	 */
	if (a->deferred & TODO_MODE) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_MODE_BASE;
		fe->mode = a->mode;
	}

	if ((a->deferred & TODO_TIMES)
		&& (archive_entry_mtime_is_set(entry)
		    || archive_entry_atime_is_set(entry))) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->mode = a->mode;
		fe->fixup |= TODO_TIMES;
		if (archive_entry_atime_is_set(entry)) {
			fe->atime = archive_entry_atime(entry);
			fe->atime_nanos = archive_entry_atime_nsec(entry);
		} else {
			/* If atime is unset, use start time. */
			fe->atime = a->start_time;
			fe->atime_nanos = 0;
		}
		if (archive_entry_mtime_is_set(entry)) {
			fe->mtime = archive_entry_mtime(entry);
			fe->mtime_nanos = archive_entry_mtime_nsec(entry);
		} else {
			/* If mtime is unset, use start time. */
			fe->mtime = a->start_time;
			fe->mtime_nanos = 0;
		}
		if (archive_entry_birthtime_is_set(entry)) {
			fe->birthtime = archive_entry_birthtime(entry);
			fe->birthtime_nanos = archive_entry_birthtime_nsec(entry);
		} else {
			/* If birthtime is unset, use mtime. */
			fe->birthtime = fe->mtime;
			fe->birthtime_nanos = fe->mtime_nanos;
		}
	}

	if (a->deferred & TODO_ACLS) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_ACLS;
		archive_acl_copy(&fe->acl, archive_entry_acl(entry));
	}

	if (a->deferred & TODO_MAC_METADATA) {
		const void *metadata;
		size_t metadata_size;
		metadata = archive_entry_mac_metadata(a->entry, &metadata_size);
		if (metadata != NULL && metadata_size > 0) {
			fe = current_fixup(a, archive_entry_pathname(entry));
			if (fe == NULL)
				return (ARCHIVE_FATAL);
			fe->mac_metadata = malloc(metadata_size);
			if (fe->mac_metadata != NULL) {
				memcpy(fe->mac_metadata, metadata, metadata_size);
				fe->mac_metadata_size = metadata_size;
				fe->fixup |= TODO_MAC_METADATA;
			}
		}
	}

	if (a->deferred & TODO_FFLAGS) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_FFLAGS;
		/* TODO: Complete this.. defer fflags from below. */
	}

	/* We've created the object and are ready to pour data into it. */
	if (ret >= ARCHIVE_WARN)
		a->archive.state = ARCHIVE_STATE_DATA;
	/*
	 * If it's not open, tell our client not to try writing.
	 * In particular, dirs, links, etc, don't get written to.
	 */
	if (a->fd < 0) {
		archive_entry_set_size(entry, 0);
		a->filesize = 0;
	}

	return (ret);
}

int
archive_write_disk_set_skip_file(struct archive *_a, int64_t d, int64_t i)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_skip_file"");
	a->skip_file_set = 1;
	a->skip_file_dev = d;
	a->skip_file_ino = i;
	return (ARCHIVE_OK);
}

static ssize_t
write_data_block(struct archive_write_disk *a, const char *buff, size_t size)
{
	uint64_t start_size = size;
	ssize_t bytes_written = 0;
	ssize_t block_size = 0, bytes_to_write;

	if (size == 0)
		return (ARCHIVE_OK);

	if (a->filesize == 0 || a->fd < 0) {
		archive_set_error(&a->archive, 0,
		    ""Attempt to write to an empty file"");
		return (ARCHIVE_WARN);
	}

	if (a->flags & ARCHIVE_EXTRACT_SPARSE) {
#if HAVE_STRUCT_STAT_ST_BLKSIZE
		int r;
		if ((r = lazy_stat(a)) != ARCHIVE_OK)
			return (r);
		block_size = a->pst->st_blksize;
#else
		/* XXX TODO XXX Is there a more appropriate choice here ? */
		/* This needn't match the filesystem allocation size. */
		block_size = 16*1024;
#endif
	}

	/* If this write would run beyond the file size, truncate it. */
	if (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)
		start_size = size = (size_t)(a->filesize - a->offset);

	/* Write the data. */
	while (size > 0) {
		if (block_size == 0) {
			bytes_to_write = size;
		} else {
			/* We're sparsifying the file. */
			const char *p, *end;
			int64_t block_end;

			/* Skip leading zero bytes. */
			for (p = buff, end = buff + size; p < end; ++p) {
				if (*p != '\0')
					break;
			}
			a->offset += p - buff;
			size -= p - buff;
			buff = p;
			if (size == 0)
				break;

			/* Calculate next block boundary after offset. */
			block_end
			    = (a->offset / block_size + 1) * block_size;

			/* If the adjusted write would cross block boundary,
			 * truncate it to the block boundary. */
			bytes_to_write = size;
			if (a->offset + bytes_to_write > block_end)
				bytes_to_write = block_end - a->offset;
		}
		/* Seek if necessary to the specified offset. */
		if (a->offset != a->fd_offset) {
			if (lseek(a->fd, a->offset, SEEK_SET) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Seek failed"");
				return (ARCHIVE_FATAL);
			}
			a->fd_offset = a->offset;
		}
		bytes_written = write(a->fd, buff, bytes_to_write);
		if (bytes_written < 0) {
			archive_set_error(&a->archive, errno, ""Write failed"");
			return (ARCHIVE_WARN);
		}
		buff += bytes_written;
		size -= bytes_written;
		a->total_bytes_written += bytes_written;
		a->offset += bytes_written;
		a->fd_offset = a->offset;
	}
	return (start_size - size);
}

#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\
	&& defined(HAVE_ZLIB_H)

/*
 * Set UF_COMPRESSED file flag.
 * This have to be called after hfs_write_decmpfs() because if the
 * file does not have ""com.apple.decmpfs"" xattr the flag is ignored.
 */
static int
hfs_set_compressed_fflag(struct archive_write_disk *a)
{
	int r;

	if ((r = lazy_stat(a)) != ARCHIVE_OK)
		return (r);

	a->st.st_flags |= UF_COMPRESSED;
	if (fchflags(a->fd, a->st.st_flags) != 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to set UF_COMPRESSED file flag"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

/*
 * HFS+ Compression decmpfs
 *
 *     +------------------------------+ +0
 *     |      Magic(LE 4 bytes)       |
 *     +------------------------------+
 *     |      Type(LE 4 bytes)        |
 *     +------------------------------+
 *     | Uncompressed size(LE 8 bytes)|
 *     +------------------------------+ +16
 *     |                              |
 *     |       Compressed data        |
 *     |  (Placed only if Type == 3)  |
 *     |                              |
 *     +------------------------------+  +3802 = MAX_DECMPFS_XATTR_SIZE
 *
 *  Type is 3: decmpfs has compressed data.
 *  Type is 4: Resource Fork has compressed data.
 */
/*
 * Write ""com.apple.decmpfs""
 */
static int
hfs_write_decmpfs(struct archive_write_disk *a)
{
	int r;
	uint32_t compression_type;

	r = fsetxattr(a->fd, DECMPFS_XATTR_NAME, a->decmpfs_header_p,
	    a->decmpfs_attr_size, 0, 0);
	if (r < 0) {
		archive_set_error(&a->archive, errno,
		    ""Cannot restore xattr:%s"", DECMPFS_XATTR_NAME);
		compression_type = archive_le32dec(
		    &a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE]);
		if (compression_type == CMP_RESOURCE_FORK)
			fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME,
			    XATTR_SHOWCOMPRESSION);
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

/*
 * HFS+ Compression Resource Fork
 *
 *     +-----------------------------+
 *     |     Header(260 bytes)       |
 *     +-----------------------------+
 *     |   Block count(LE 4 bytes)   |
 *     +-----------------------------+  --+
 * +-- |     Offset (LE 4 bytes)     |    |
 * |   | [distance from Block count] |    | Block 0
 * |   +-----------------------------+    |
 * |   | Compressed size(LE 4 bytes) |    |
 * |   +-----------------------------+  --+
 * |   |                             |
 * |   |      ..................     |
 * |   |                             |
 * |   +-----------------------------+  --+
 * |   |     Offset (LE 4 bytes)     |    |
 * |   +-----------------------------+    | Block (Block count -1)
 * |   | Compressed size(LE 4 bytes) |    |
 * +-> +-----------------------------+  --+
 *     |   Compressed data(n bytes)  |  Block 0
 *     +-----------------------------+
 *     |                             |
 *     |      ..................     |
 *     |                             |
 *     +-----------------------------+
 *     |   Compressed data(n bytes)  |  Block (Block count -1)
 *     +-----------------------------+
 *     |      Footer(50 bytes)       |
 *     +-----------------------------+
 *
 */
/*
 * Write the header of ""com.apple.ResourceFork""
 */
static int
hfs_write_resource_fork(struct archive_write_disk *a, unsigned char *buff,
    size_t bytes, uint32_t position)
{
	int ret;

	ret = fsetxattr(a->fd, XATTR_RESOURCEFORK_NAME, buff, bytes,
	    position, a->rsrc_xattr_options);
	if (ret < 0) {
		archive_set_error(&a->archive, errno,
		    ""Cannot restore xattr: %s at %u pos %u bytes"",
		    XATTR_RESOURCEFORK_NAME,
		    (unsigned)position,
		    (unsigned)bytes);
		return (ARCHIVE_WARN);
	}
	a->rsrc_xattr_options &= ~XATTR_CREATE;
	return (ARCHIVE_OK);
}

static int
hfs_write_compressed_data(struct archive_write_disk *a, size_t bytes_compressed)
{
	int ret;

	ret = hfs_write_resource_fork(a, a->compressed_buffer,
	    bytes_compressed, a->compressed_rsrc_position);
	if (ret == ARCHIVE_OK)
		a->compressed_rsrc_position += bytes_compressed;
	return (ret);
}

static int
hfs_write_resource_fork_header(struct archive_write_disk *a)
{
	unsigned char *buff;
	uint32_t rsrc_bytes;
	uint32_t rsrc_header_bytes;

	/*
	 * Write resource fork header + block info.
	 */
	buff = a->resource_fork;
	rsrc_bytes = a->compressed_rsrc_position - RSRC_F_SIZE;
	rsrc_header_bytes =
		RSRC_H_SIZE +		/* Header base size. */
		4 +			/* Block count. */
		(a->decmpfs_block_count * 8);/* Block info */
	archive_be32enc(buff, 0x100);
	archive_be32enc(buff + 4, rsrc_bytes);
	archive_be32enc(buff + 8, rsrc_bytes - 256);
	archive_be32enc(buff + 12, 0x32);
	memset(buff + 16, 0, 240);
	archive_be32enc(buff + 256, rsrc_bytes - 260);
	return hfs_write_resource_fork(a, buff, rsrc_header_bytes, 0);
}

static size_t
hfs_set_resource_fork_footer(unsigned char *buff, size_t buff_size)
{
	static const char rsrc_footer[RSRC_F_SIZE] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 'c',  'm',
		'p', 'f',   0x00, 0x00, 0x00, 0x0a, 0x00, 0x01,
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00
	};
	if (buff_size < sizeof(rsrc_footer))
		return (0);
	memcpy(buff, rsrc_footer, sizeof(rsrc_footer));
	return (sizeof(rsrc_footer));
}

static int
hfs_reset_compressor(struct archive_write_disk *a)
{
	int ret;

	if (a->stream_valid)
		ret = deflateReset(&a->stream);
	else
		ret = deflateInit(&a->stream, a->decmpfs_compression_level);

	if (ret != Z_OK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Failed to initialize compressor"");
		return (ARCHIVE_FATAL);
	} else
		a->stream_valid = 1;

	return (ARCHIVE_OK);
}

static int
hfs_decompress(struct archive_write_disk *a)
{
	uint32_t *block_info;
	unsigned int block_count;
	uint32_t data_pos, data_size;
	ssize_t r;
	ssize_t bytes_written, bytes_to_write;
	unsigned char *b;

	block_info = (uint32_t *)(a->resource_fork + RSRC_H_SIZE);
	block_count = archive_le32dec(block_info++);
	while (block_count--) {
		data_pos = RSRC_H_SIZE + archive_le32dec(block_info++);
		data_size = archive_le32dec(block_info++);
		r = fgetxattr(a->fd, XATTR_RESOURCEFORK_NAME,
		    a->compressed_buffer, data_size, data_pos, 0);
		if (r != data_size)  {
			archive_set_error(&a->archive,
			    (r < 0)?errno:ARCHIVE_ERRNO_MISC,
			    ""Failed to read resource fork"");
			return (ARCHIVE_WARN);
		}
		if (a->compressed_buffer[0] == 0xff) {
			bytes_to_write = data_size -1;
			b = a->compressed_buffer + 1;
		} else {
			uLong dest_len = MAX_DECMPFS_BLOCK_SIZE;
			int zr;

			zr = uncompress((Bytef *)a->uncompressed_buffer,
			    &dest_len, a->compressed_buffer, data_size);
			if (zr != Z_OK) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to decompress resource fork"");
				return (ARCHIVE_WARN);
			}
			bytes_to_write = dest_len;
			b = (unsigned char *)a->uncompressed_buffer;
		}
		do {
			bytes_written = write(a->fd, b, bytes_to_write);
			if (bytes_written < 0) {
				archive_set_error(&a->archive, errno,
				    ""Write failed"");
				return (ARCHIVE_WARN);
			}
			bytes_to_write -= bytes_written;
			b += bytes_written;
		} while (bytes_to_write > 0);
	}
	r = fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME, 0);
	if (r == -1)  {
		archive_set_error(&a->archive, errno,
		    ""Failed to remove resource fork"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

static int
hfs_drive_compressor(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	unsigned char *buffer_compressed;
	size_t bytes_compressed;
	size_t bytes_used;
	int ret;

	ret = hfs_reset_compressor(a);
	if (ret != ARCHIVE_OK)
		return (ret);

	if (a->compressed_buffer == NULL) {
		size_t block_size;

		block_size = COMPRESSED_W_SIZE + RSRC_F_SIZE +
		    + compressBound(MAX_DECMPFS_BLOCK_SIZE);
		a->compressed_buffer = malloc(block_size);
		if (a->compressed_buffer == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Resource Fork"");
			return (ARCHIVE_FATAL);
		}
		a->compressed_buffer_size = block_size;
		a->compressed_buffer_remaining = block_size;
	}

	buffer_compressed = a->compressed_buffer +
	    a->compressed_buffer_size - a->compressed_buffer_remaining;
	a->stream.next_in = (Bytef *)(uintptr_t)(const void *)buff;
	a->stream.avail_in = size;
	a->stream.next_out = buffer_compressed;
	a->stream.avail_out = a->compressed_buffer_remaining;
	do {
		ret = deflate(&a->stream, Z_FINISH);
		switch (ret) {
		case Z_OK:
		case Z_STREAM_END:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Failed to compress data"");
			return (ARCHIVE_FAILED);
		}
	} while (ret == Z_OK);
	bytes_compressed = a->compressed_buffer_remaining - a->stream.avail_out;

	/*
	 * If the compressed size is larger than the original size,
	 * throw away compressed data, use uncompressed data instead.
	 */
	if (bytes_compressed > size) {
		buffer_compressed[0] = 0xFF;/* uncompressed marker. */
		memcpy(buffer_compressed + 1, buff, size);
		bytes_compressed = size + 1;
	}
	a->compressed_buffer_remaining -= bytes_compressed;

	/*
	 * If the compressed size is smaller than MAX_DECMPFS_XATTR_SIZE
	 * and the block count in the file is only one, store compressed
	 * data to decmpfs xattr instead of the resource fork.
	 */
	if (a->decmpfs_block_count == 1 &&
	    (a->decmpfs_attr_size + bytes_compressed)
	      <= MAX_DECMPFS_XATTR_SIZE) {
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],
		    CMP_XATTR);
		memcpy(a->decmpfs_header_p + DECMPFS_HEADER_SIZE,
		    buffer_compressed, bytes_compressed);
		a->decmpfs_attr_size += bytes_compressed;
		a->compressed_buffer_remaining = a->compressed_buffer_size;
		/*
		 * Finish HFS+ Compression.
		 * - Write the decmpfs xattr.
		 * - Set the UF_COMPRESSED file flag.
		 */
		ret = hfs_write_decmpfs(a);
		if (ret == ARCHIVE_OK)
			ret = hfs_set_compressed_fflag(a);
		return (ret);
	}

	/* Update block info. */
	archive_le32enc(a->decmpfs_block_info++,
	    a->compressed_rsrc_position_v - RSRC_H_SIZE);
	archive_le32enc(a->decmpfs_block_info++, bytes_compressed);
	a->compressed_rsrc_position_v += bytes_compressed;

	/*
	 * Write the compressed data to the resource fork.
	 */
	bytes_used = a->compressed_buffer_size - a->compressed_buffer_remaining;
	while (bytes_used >= COMPRESSED_W_SIZE) {
		ret = hfs_write_compressed_data(a, COMPRESSED_W_SIZE);
		if (ret != ARCHIVE_OK)
			return (ret);
		bytes_used -= COMPRESSED_W_SIZE;
		if (bytes_used > COMPRESSED_W_SIZE)
			memmove(a->compressed_buffer,
			    a->compressed_buffer + COMPRESSED_W_SIZE,
			    bytes_used);
		else
			memcpy(a->compressed_buffer,
			    a->compressed_buffer + COMPRESSED_W_SIZE,
			    bytes_used);
	}
	a->compressed_buffer_remaining = a->compressed_buffer_size - bytes_used;

	/*
	 * If the current block is the last block, write the remaining
	 * compressed data and the resource fork footer.
	 */
	if (a->file_remaining_bytes == 0) {
		size_t rsrc_size;
		int64_t bk;

		/* Append the resource footer. */
		rsrc_size = hfs_set_resource_fork_footer(
		    a->compressed_buffer + bytes_used,
		    a->compressed_buffer_remaining);
		ret = hfs_write_compressed_data(a, bytes_used + rsrc_size);
		a->compressed_buffer_remaining = a->compressed_buffer_size;

		/* If the compressed size is not enouph smaller than
		 * the uncompressed size. cancel HFS+ compression.
		 * TODO: study a behavior of ditto utility and improve
		 * the condition to fall back into no HFS+ compression. */
		bk = HFS_BLOCKS(a->compressed_rsrc_position);
		bk += bk >> 7;
		if (bk > HFS_BLOCKS(a->filesize))
			return hfs_decompress(a);
		/*
		 * Write the resourcefork header.
		 */
		if (ret == ARCHIVE_OK)
			ret = hfs_write_resource_fork_header(a);
		/*
		 * Finish HFS+ Compression.
		 * - Write the decmpfs xattr.
		 * - Set the UF_COMPRESSED file flag.
		 */
		if (ret == ARCHIVE_OK)
			ret = hfs_write_decmpfs(a);
		if (ret == ARCHIVE_OK)
			ret = hfs_set_compressed_fflag(a);
	}
	return (ret);
}

static ssize_t
hfs_write_decmpfs_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	const char *buffer_to_write;
	size_t bytes_to_write;
	int ret;

	if (a->decmpfs_block_count == (unsigned)-1) {
		void *new_block;
		size_t new_size;
		unsigned int block_count;

		if (a->decmpfs_header_p == NULL) {
			new_block = malloc(MAX_DECMPFS_XATTR_SIZE
			    + sizeof(uint32_t));
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for decmpfs"");
				return (ARCHIVE_FATAL);
			}
			a->decmpfs_header_p = new_block;
		}
		a->decmpfs_attr_size = DECMPFS_HEADER_SIZE;
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_MAGIC],
		    DECMPFS_MAGIC);
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],
		    CMP_RESOURCE_FORK);
		archive_le64enc(&a->decmpfs_header_p[DECMPFS_UNCOMPRESSED_SIZE],
		    a->filesize);

		/* Calculate a block count of the file. */
		block_count =
		    (a->filesize + MAX_DECMPFS_BLOCK_SIZE -1) /
			MAX_DECMPFS_BLOCK_SIZE;
		/*
		 * Allocate buffer for resource fork.
		 * Set up related pointers;
		 */
		new_size =
		    RSRC_H_SIZE + /* header */
		    4 + /* Block count */
		    (block_count * sizeof(uint32_t) * 2) +
		    RSRC_F_SIZE; /* footer */
		if (new_size > a->resource_fork_allocated_size) {
			new_block = realloc(a->resource_fork, new_size);
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for ResourceFork"");
				return (ARCHIVE_FATAL);
			}
			a->resource_fork_allocated_size = new_size;
			a->resource_fork = new_block;
		}

		/* Allocate uncompressed buffer */
		if (a->uncompressed_buffer == NULL) {
			new_block = malloc(MAX_DECMPFS_BLOCK_SIZE);
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for decmpfs"");
				return (ARCHIVE_FATAL);
			}
			a->uncompressed_buffer = new_block;
		}
		a->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;
		a->file_remaining_bytes = a->filesize;
		a->compressed_buffer_remaining = a->compressed_buffer_size;

		/*
		 * Set up a resource fork.
		 */
		a->rsrc_xattr_options = XATTR_CREATE;
		/* Get the position where we are going to set a bunch
		 * of block info. */
		a->decmpfs_block_info =
		    (uint32_t *)(a->resource_fork + RSRC_H_SIZE);
		/* Set the block count to the resource fork. */
		archive_le32enc(a->decmpfs_block_info++, block_count);
		/* Get the position where we are goint to set compressed
		 * data. */
		a->compressed_rsrc_position =
		    RSRC_H_SIZE + 4 + (block_count * 8);
		a->compressed_rsrc_position_v = a->compressed_rsrc_position;
		a->decmpfs_block_count = block_count;
	}

	/* Ignore redundant bytes. */
	if (a->file_remaining_bytes == 0)
		return ((ssize_t)size);

	/* Do not overrun a block size. */
	if (size > a->block_remaining_bytes)
		bytes_to_write = a->block_remaining_bytes;
	else
		bytes_to_write = size;
	/* Do not overrun the file size. */
	if (bytes_to_write > a->file_remaining_bytes)
		bytes_to_write = a->file_remaining_bytes;

	/* For efficiency, if a copy length is full of the uncompressed
	 * buffer size, do not copy writing data to it. */
	if (bytes_to_write == MAX_DECMPFS_BLOCK_SIZE)
		buffer_to_write = buff;
	else {
		memcpy(a->uncompressed_buffer +
		    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes,
		    buff, bytes_to_write);
		buffer_to_write = a->uncompressed_buffer;
	}
	a->block_remaining_bytes -= bytes_to_write;
	a->file_remaining_bytes -= bytes_to_write;

	if (a->block_remaining_bytes == 0 || a->file_remaining_bytes == 0) {
		ret = hfs_drive_compressor(a, buffer_to_write,
		    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes);
		if (ret < 0)
			return (ret);
		a->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;
	}
	/* Ignore redundant bytes. */
	if (a->file_remaining_bytes == 0)
		return ((ssize_t)size);
	return (bytes_to_write);
}

static ssize_t
hfs_write_data_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	uint64_t start_size = size;
	ssize_t bytes_written = 0;
	ssize_t bytes_to_write;

	if (size == 0)
		return (ARCHIVE_OK);

	if (a->filesize == 0 || a->fd < 0) {
		archive_set_error(&a->archive, 0,
		    ""Attempt to write to an empty file"");
		return (ARCHIVE_WARN);
	}

	/* If this write would run beyond the file size, truncate it. */
	if (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)
		start_size = size = (size_t)(a->filesize - a->offset);

	/* Write the data. */
	while (size > 0) {
		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
		} else if (a->offset > a->fd_offset) {
			int64_t skip = a->offset - a->fd_offset;
			char nullblock[1024];

			memset(nullblock, 0, sizeof(nullblock));
			while (skip > 0) {
				if (skip > (int64_t)sizeof(nullblock))
					bytes_written = hfs_write_decmpfs_block(
					    a, nullblock, sizeof(nullblock));
				else
					bytes_written = hfs_write_decmpfs_block(
					    a, nullblock, skip);
				if (bytes_written < 0) {
					archive_set_error(&a->archive, errno,
					    ""Write failed"");
					return (ARCHIVE_WARN);
				}
				skip -= bytes_written;
			}

			a->fd_offset = a->offset;
		}
		bytes_written =
		    hfs_write_decmpfs_block(a, buff, bytes_to_write);
		if (bytes_written < 0)
			return (bytes_written);
		buff += bytes_written;
		size -= bytes_written;
		a->total_bytes_written += bytes_written;
		a->offset += bytes_written;
		a->fd_offset = a->offset;
	}
	return (start_size - size);
}
#else
static ssize_t
hfs_write_data_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	return (write_data_block(a, buff, size));
}
#endif

static ssize_t
_archive_write_disk_data_block(struct archive *_a,
    const void *buff, size_t size, int64_t offset)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	ssize_t r;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_DATA, ""archive_write_data_block"");

	a->offset = offset;
	if (a->todo & TODO_HFS_COMPRESSION)
		r = hfs_write_data_block(a, buff, size);
	else
		r = write_data_block(a, buff, size);
	if (r < ARCHIVE_OK)
		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
	return (ARCHIVE_OK);
#else
	return (size);
#endif
}

static ssize_t
_archive_write_disk_data(struct archive *_a, const void *buff, size_t size)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_DATA, ""archive_write_data"");

	if (a->todo & TODO_HFS_COMPRESSION)
		return (hfs_write_data_block(a, buff, size));
	return (write_data_block(a, buff, size));
}

static int
_archive_write_disk_finish_entry(struct archive *_a)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	int ret = ARCHIVE_OK;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_finish_entry"");
	if (a->archive.state & ARCHIVE_STATE_HEADER)
		return (ARCHIVE_OK);
	archive_clear_error(&a->archive);

	/* Pad or truncate file to the right size. */
	if (a->fd < 0) {
		/* There's no file. */
	} else if (a->filesize < 0) {
		/* File size is unknown, so we can't set the size. */
	} else if (a->fd_offset == a->filesize) {
		/* Last write ended at exactly the filesize; we're done. */
		/* Hopefully, this is the common case. */
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	} else if (a->todo & TODO_HFS_COMPRESSION) {
		char null_d[1024];
		ssize_t r;

		if (a->file_remaining_bytes)
			memset(null_d, 0, sizeof(null_d));
		while (a->file_remaining_bytes) {
			if (a->file_remaining_bytes > sizeof(null_d))
				r = hfs_write_data_block(
				    a, null_d, sizeof(null_d));
			else
				r = hfs_write_data_block(
				    a, null_d, a->file_remaining_bytes);
			if (r < 0)
				return ((int)r);
		}
#endif
	} else {
#if HAVE_FTRUNCATE
		if (ftruncate(a->fd, a->filesize) == -1 &&
		    a->filesize == 0) {
			archive_set_error(&a->archive, errno,
			    ""File size could not be restored"");
			return (ARCHIVE_FAILED);
		}
#endif
		/*
		 * Not all platforms implement the XSI option to
		 * extend files via ftruncate.  Stat() the file again
		 * to see what happened.
		 */
		a->pst = NULL;
		if ((ret = lazy_stat(a)) != ARCHIVE_OK)
			return (ret);
		/* We can use lseek()/write() to extend the file if
		 * ftruncate didn't work or isn't available. */
		if (a->st.st_size < a->filesize) {
			const char nul = '\0';
			if (lseek(a->fd, a->filesize - 1, SEEK_SET) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Seek failed"");
				return (ARCHIVE_FATAL);
			}
			if (write(a->fd, &nul, 1) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Write to restore size failed"");
				return (ARCHIVE_FATAL);
			}
			a->pst = NULL;
		}
	}

	/* Restore metadata. */

	/*
	 * This is specific to Mac OS X.
	 * If the current file is an AppleDouble file, it should be
	 * linked with the data fork file and remove it.
	 */
	if (a->todo & TODO_APPLEDOUBLE) {
		int r2 = fixup_appledouble(a, a->name);
		if (r2 == ARCHIVE_EOF) {
			/* The current file has been successfully linked
			 * with the data fork file and removed. So there
			 * is nothing to do on the current file.  */
			goto finish_metadata;
		}
		if (r2 < ret) ret = r2;
	}

	/*
	 * Look up the ""real"" UID only if we're going to need it.
	 * TODO: the TODO_SGID condition can be dropped here, can't it?
	 */
	if (a->todo & (TODO_OWNER | TODO_SUID | TODO_SGID)) {
		a->uid = archive_write_disk_uid(&a->archive,
		    archive_entry_uname(a->entry),
		    archive_entry_uid(a->entry));
	}
	/* Look up the ""real"" GID only if we're going to need it. */
	/* TODO: the TODO_SUID condition can be dropped here, can't it? */
	if (a->todo & (TODO_OWNER | TODO_SGID | TODO_SUID)) {
		a->gid = archive_write_disk_gid(&a->archive,
		    archive_entry_gname(a->entry),
		    archive_entry_gid(a->entry));
	 }

	/*
	 * Restore ownership before set_mode tries to restore suid/sgid
	 * bits.  If we set the owner, we know what it is and can skip
	 * a stat() call to examine the ownership of the file on disk.
	 */
	if (a->todo & TODO_OWNER) {
		int r2 = set_ownership(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * set_mode must precede ACLs on systems such as Solaris and
	 * FreeBSD where setting the mode implicitly clears extended ACLs
	 */
	if (a->todo & TODO_MODE) {
		int r2 = set_mode(a, a->mode);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Security-related extended attributes (such as
	 * security.capability on Linux) have to be restored last,
	 * since they're implicitly removed by other file changes.
	 */
	if (a->todo & TODO_XATTR) {
		int r2 = set_xattrs(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Some flags prevent file modification; they must be restored after
	 * file contents are written.
	 */
	if (a->todo & TODO_FFLAGS) {
		int r2 = set_fflags(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Time must follow most other metadata;
	 * otherwise atime will get changed.
	 */
	if (a->todo & TODO_TIMES) {
		int r2 = set_times_from_entry(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Mac extended metadata includes ACLs.
	 */
	if (a->todo & TODO_MAC_METADATA) {
		const void *metadata;
		size_t metadata_size;
		metadata = archive_entry_mac_metadata(a->entry, &metadata_size);
		if (metadata != NULL && metadata_size > 0) {
			int r2 = set_mac_metadata(a, archive_entry_pathname(
			    a->entry), metadata, metadata_size);
			if (r2 < ret) ret = r2;
		}
	}

	/*
	 * ACLs must be restored after timestamps because there are
	 * ACLs that prevent attribute changes (including time).
	 */
	if (a->todo & TODO_ACLS) {
		int r2 = archive_write_disk_set_acls(&a->archive, a->fd,
				  archive_entry_pathname(a->entry),
				  archive_entry_acl(a->entry));
		if (r2 < ret) ret = r2;
	}

finish_metadata:
	/* If there's an fd, we can close it now. */
	if (a->fd >= 0) {
		close(a->fd);
		a->fd = -1;
	}
	/* If there's an entry, we can release it now. */
	if (a->entry) {
		archive_entry_free(a->entry);
		a->entry = NULL;
	}
	a->archive.state = ARCHIVE_STATE_HEADER;
	return (ret);
}

int
archive_write_disk_set_group_lookup(struct archive *_a,
    void *private_data,
    int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid),
    void (*cleanup_gid)(void *private))
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_group_lookup"");

	if (a->cleanup_gid != NULL && a->lookup_gid_data != NULL)
		(a->cleanup_gid)(a->lookup_gid_data);

	a->lookup_gid = lookup_gid;
	a->cleanup_gid = cleanup_gid;
	a->lookup_gid_data = private_data;
	return (ARCHIVE_OK);
}

int
archive_write_disk_set_user_lookup(struct archive *_a,
    void *private_data,
    int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),
    void (*cleanup_uid)(void *private))
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_user_lookup"");

	if (a->cleanup_uid != NULL && a->lookup_uid_data != NULL)
		(a->cleanup_uid)(a->lookup_uid_data);

	a->lookup_uid = lookup_uid;
	a->cleanup_uid = cleanup_uid;
	a->lookup_uid_data = private_data;
	return (ARCHIVE_OK);
}

int64_t
archive_write_disk_gid(struct archive *_a, const char *name, int64_t id)
{
       struct archive_write_disk *a = (struct archive_write_disk *)_a;
       archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
           ARCHIVE_STATE_ANY, ""archive_write_disk_gid"");
       if (a->lookup_gid)
               return (a->lookup_gid)(a->lookup_gid_data, name, id);
       return (id);
}
 
int64_t
archive_write_disk_uid(struct archive *_a, const char *name, int64_t id)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_uid"");
	if (a->lookup_uid)
		return (a->lookup_uid)(a->lookup_uid_data, name, id);
	return (id);
}

/*
 * Create a new archive_write_disk object and initialize it with global state.
 */
struct archive *
archive_write_disk_new(void)
{
	struct archive_write_disk *a;

	a = (struct archive_write_disk *)malloc(sizeof(*a));
	if (a == NULL)
		return (NULL);
	memset(a, 0, sizeof(*a));
	a->archive.magic = ARCHIVE_WRITE_DISK_MAGIC;
	/* We're ready to write a header immediately. */
	a->archive.state = ARCHIVE_STATE_HEADER;
	a->archive.vtable = archive_write_disk_vtable();
	a->start_time = time(NULL);
	/* Query and restore the umask. */
	umask(a->user_umask = umask(0));
#ifdef HAVE_GETEUID
	a->user_uid = geteuid();
#endif /* HAVE_GETEUID */
	if (archive_string_ensure(&a->path_safe, 512) == NULL) {
		free(a);
		return (NULL);
	}
#ifdef HAVE_ZLIB_H
	a->decmpfs_compression_level = 5;
#endif
	return (&a->archive);
}


/*
 * If pathname is longer than PATH_MAX, chdir to a suitable
 * intermediate dir and edit the path down to a shorter suffix.  Note
 * that this routine never returns an error; if the chdir() attempt
 * fails for any reason, we just go ahead with the long pathname.  The
 * object creation is likely to fail, but any error will get handled
 * at that time.
 */
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
static void
edit_deep_directories(struct archive_write_disk *a)
{
	int ret;
	char *tail = a->name;

	/* If path is short, avoid the open() below. */
	if (strlen(tail) <= PATH_MAX)
		return;

	/* Try to record our starting dir. */
	a->restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(a->restore_pwd);
	if (a->restore_pwd < 0)
		return;

	/* As long as the path is too long... */
	while (strlen(tail) > PATH_MAX) {
		/* Locate a dir prefix shorter than PATH_MAX. */
		tail += PATH_MAX - 8;
		while (tail > a->name && *tail != '/')
			tail--;
		/* Exit if we find a too-long path component. */
		if (tail <= a->name)
			return;
		/* Create the intermediate dir and chdir to it. */
		*tail = '\0'; /* Terminate dir portion */
		ret = create_dir(a, a->name);
		if (ret == ARCHIVE_OK && chdir(a->name) != 0)
			ret = ARCHIVE_FAILED;
		*tail = '/'; /* Restore the / we removed. */
		if (ret != ARCHIVE_OK)
			return;
		tail++;
		/* The chdir() succeeded; we've now shortened the path. */
		a->name = tail;
	}
	return;
}
#endif

/*
 * The main restore function.
 */
static int
restore_entry(struct archive_write_disk *a)
{
	int ret = ARCHIVE_OK, en;

	if (a->flags & ARCHIVE_EXTRACT_UNLINK && !S_ISDIR(a->mode)) {
		/*
		 * TODO: Fix this.  Apparently, there are platforms
		 * that still allow root to hose the entire filesystem
		 * by unlinking a dir.  The S_ISDIR() test above
		 * prevents us from using unlink() here if the new
		 * object is a dir, but that doesn't mean the old
		 * object isn't a dir.
		 */
		if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
			(void)clear_nochange_fflags(a);
		if (unlink(a->name) == 0) {
			/* We removed it, reset cached stat. */
			a->pst = NULL;
		} else if (errno == ENOENT) {
			/* File didn't exist, that's just as good. */
		} else if (rmdir(a->name) == 0) {
			/* It was a dir, but now it's gone. */
			a->pst = NULL;
		} else {
			/* We tried, but couldn't get rid of it. */
			archive_set_error(&a->archive, errno,
			    ""Could not unlink"");
			return(ARCHIVE_FAILED);
		}
	}

	/* Try creating it first; if this fails, we'll try to recover. */
	en = create_filesystem_object(a);

	if ((en == ENOTDIR || en == ENOENT)
	    && !(a->flags & ARCHIVE_EXTRACT_NO_AUTODIR)) {
		/* If the parent dir doesn't exist, try creating it. */
		create_parent_dir(a, a->name);
		/* Now try to create the object again. */
		en = create_filesystem_object(a);
	}

	if ((en == ENOENT) && (archive_entry_hardlink(a->entry) != NULL)) {
		archive_set_error(&a->archive, en,
		    ""Hard-link target '%s' does not exist."",
		    archive_entry_hardlink(a->entry));
		return (ARCHIVE_FAILED);
	}

	if ((en == EISDIR || en == EEXIST)
	    && (a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {
		/* If we're not overwriting, we're done. */
		archive_entry_unset_size(a->entry);
		return (ARCHIVE_OK);
	}

	/*
	 * Some platforms return EISDIR if you call
	 * open(O_WRONLY | O_EXCL | O_CREAT) on a directory, some
	 * return EEXIST.  POSIX is ambiguous, requiring EISDIR
	 * for open(O_WRONLY) on a dir and EEXIST for open(O_EXCL | O_CREAT)
	 * on an existing item.
	 */
	if (en == EISDIR) {
		/* A dir is in the way of a non-dir, rmdir it. */
		if (rmdir(a->name) != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't remove already-existing dir"");
			return (ARCHIVE_FAILED);
		}
		a->pst = NULL;
		/* Try again. */
		en = create_filesystem_object(a);
	} else if (en == EEXIST) {
		/*
		 * We know something is in the way, but we don't know what;
		 * we need to find out before we go any further.
		 */
		int r = 0;
		/*
		 * The SECURE_SYMLINKS logic has already removed a
		 * symlink to a dir if the client wants that.  So
		 * follow the symlink if we're creating a dir.
		 */
		if (S_ISDIR(a->mode))
			r = stat(a->name, &a->st);
		/*
		 * If it's not a dir (or it's a broken symlink),
		 * then don't follow it.
		 */
		if (r != 0 || !S_ISDIR(a->mode))
			r = lstat(a->name, &a->st);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't stat existing object"");
			return (ARCHIVE_FAILED);
		}

		/*
		 * NO_OVERWRITE_NEWER doesn't apply to directories.
		 */
		if ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER)
		    &&  !S_ISDIR(a->st.st_mode)) {
			if (!older(&(a->st), a->entry)) {
				archive_entry_unset_size(a->entry);
				return (ARCHIVE_OK);
			}
		}

		/* If it's our archive, we're done. */
		if (a->skip_file_set &&
		    a->st.st_dev == (dev_t)a->skip_file_dev &&
		    a->st.st_ino == (ino_t)a->skip_file_ino) {
			archive_set_error(&a->archive, 0,
			    ""Refusing to overwrite archive"");
			return (ARCHIVE_FAILED);
		}

		if (!S_ISDIR(a->st.st_mode)) {
			/* A non-dir is in the way, unlink it. */
			if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
				(void)clear_nochange_fflags(a);
			if (unlink(a->name) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"");
				return (ARCHIVE_FAILED);
			}
			a->pst = NULL;
			/* Try again. */
			en = create_filesystem_object(a);
		} else if (!S_ISDIR(a->mode)) {
			/* A dir is in the way of a non-dir, rmdir it. */
			if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
				(void)clear_nochange_fflags(a);
			if (rmdir(a->name) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"");
				return (ARCHIVE_FAILED);
			}
			/* Try again. */
			en = create_filesystem_object(a);
		} else {
			/*
			 * There's a dir in the way of a dir.  Don't
			 * waste time with rmdir()/mkdir(), just fix
			 * up the permissions on the existing dir.
			 * Note that we don't change perms on existing
			 * dirs unless _EXTRACT_PERM is specified.
			 */
			if ((a->mode != a->st.st_mode)
			    && (a->todo & TODO_MODE_FORCE))
				a->deferred |= (a->todo & TODO_MODE);
			/* Ownership doesn't need deferred fixup. */
			en = 0; /* Forget the EEXIST. */
		}
	}

	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

	a->pst = NULL; /* Cached stat data no longer valid. */
	return (ret);
}

/*
 * Returns 0 if creation succeeds, or else returns errno value from
 * the failed system call.   Note:  This function should only ever perform
 * a single system call.
 */
static int
create_filesystem_object(struct archive_write_disk *a)
{
	/* Create the entry. */
	const char *linkname;
	mode_t final_mode, mode;
	int r;

	/* We identify hard/symlinks according to the link names. */
	/* Since link(2) and symlink(2) don't handle modes, we're done here. */
	linkname = archive_entry_hardlink(a->entry);
	if (linkname != NULL) {
#if !HAVE_LINK
		return (EPERM);
#else
		r = link(linkname, a->name) ? errno : 0;
		/*
		 * New cpio and pax formats allow hardlink entries
		 * to carry data, so we may have to open the file
		 * for hardlink entries.
		 *
		 * If the hardlink was successfully created and
		 * the archive doesn't have carry data for it,
		 * consider it to be non-authoritative for meta data.
		 * This is consistent with GNU tar and BSD pax.
		 * If the hardlink does carry data, let the last
		 * archive entry decide ownership.
		 */
		if (r == 0 && a->filesize <= 0) {
			a->todo = 0;
			a->deferred = 0;
		} else if (r == 0 && a->filesize > 0) {
			a->fd = open(a->name,
				     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);
			__archive_ensure_cloexec_flag(a->fd);
			if (a->fd < 0)
				r = errno;
		}
		return (r);
#endif
	}
	linkname = archive_entry_symlink(a->entry);
	if (linkname != NULL) {
#if HAVE_SYMLINK
		return symlink(linkname, a->name) ? errno : 0;
#else
		return (EPERM);
#endif
	}

	/*
	 * The remaining system calls all set permissions, so let's
	 * try to take advantage of that to avoid an extra chmod()
	 * call.  (Recall that umask is set to zero right now!)
	 */

	/* Mode we want for the final restored object (w/o file type bits). */
	final_mode = a->mode & 07777;
	/*
	 * The mode that will actually be restored in this step.  Note
	 * that SUID, SGID, etc, require additional work to ensure
	 * security, so we never restore them at this point.
	 */
	mode = final_mode & 0777 & ~a->user_umask;

	switch (a->mode & AE_IFMT) {
	default:
		/* POSIX requires that we fall through here. */
		/* FALLTHROUGH */
	case AE_IFREG:
		a->fd = open(a->name,
		    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);
		__archive_ensure_cloexec_flag(a->fd);
		r = (a->fd < 0);
		break;
	case AE_IFCHR:
#ifdef HAVE_MKNOD
		/* Note: we use AE_IFCHR for the case label, and
		 * S_IFCHR for the mknod() call.  This is correct.  */
		r = mknod(a->name, mode | S_IFCHR,
		    archive_entry_rdev(a->entry));
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a char device node. */
		return (EINVAL);
#endif /* HAVE_MKNOD */
	case AE_IFBLK:
#ifdef HAVE_MKNOD
		r = mknod(a->name, mode | S_IFBLK,
		    archive_entry_rdev(a->entry));
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a block device node. */
		return (EINVAL);
#endif /* HAVE_MKNOD */
	case AE_IFDIR:
		mode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;
		r = mkdir(a->name, mode);
		if (r == 0) {
			/* Defer setting dir times. */
			a->deferred |= (a->todo & TODO_TIMES);
			a->todo &= ~TODO_TIMES;
			/* Never use an immediate chmod(). */
			/* We can't avoid the chmod() entirely if EXTRACT_PERM
			 * because of SysV SGID inheritance. */
			if ((mode != final_mode)
			    || (a->flags & ARCHIVE_EXTRACT_PERM))
				a->deferred |= (a->todo & TODO_MODE);
			a->todo &= ~TODO_MODE;
		}
		break;
	case AE_IFIFO:
#ifdef HAVE_MKFIFO
		r = mkfifo(a->name, mode);
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a fifo. */
		return (EINVAL);
#endif /* HAVE_MKFIFO */
	}

	/* All the system calls above set errno on failure. */
	if (r)
		return (errno);

	/* If we managed to set the final mode, we've avoided a chmod(). */
	if (mode == final_mode)
		a->todo &= ~TODO_MODE;
	return (0);
}

/*
 * Cleanup function for archive_extract.  Mostly, this involves processing
 * the fixup list, which is used to address a number of problems:
 *   * Dir permissions might prevent us from restoring a file in that
 *     dir, so we restore the dir with minimum 0700 permissions first,
 *     then correct the mode at the end.
 *   * Similarly, the act of restoring a file touches the directory
 *     and changes the timestamp on the dir, so we have to touch-up dir
 *     timestamps at the end as well.
 *   * Some file flags can interfere with the restore by, for example,
 *     preventing the creation of hardlinks to those files.
 *   * Mac OS extended metadata includes ACLs, so must be deferred on dirs.
 *
 * Note that tar/cpio do not require that archives be in a particular
 * order; there is no way to know when the last file has been restored
 * within a directory, so there's no way to optimize the memory usage
 * here by fixing up the directory any earlier than the
 * end-of-archive.
 *
 * XXX TODO: Directory ACLs should be restored here, for the same
 * reason we set directory perms here. XXX
 */
static int
_archive_write_disk_close(struct archive *_a)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	struct fixup_entry *next, *p;
	int ret;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_disk_close"");
	ret = _archive_write_disk_finish_entry(&a->archive);

	/* Sort dir list so directories are fixed up in depth-first order. */
	p = sort_dir_list(a->fixup_list);

	while (p != NULL) {
		a->pst = NULL; /* Mark stat cache as out-of-date. */
		if (p->fixup & TODO_TIMES) {
			set_times(a, -1, p->mode, p->name,
			    p->atime, p->atime_nanos,
			    p->birthtime, p->birthtime_nanos,
			    p->mtime, p->mtime_nanos,
			    p->ctime, p->ctime_nanos);
		}
		if (p->fixup & TODO_MODE_BASE)
			chmod(p->name, p->mode);
		if (p->fixup & TODO_ACLS)
			archive_write_disk_set_acls(&a->archive,
						    -1, p->name, &p->acl);
		if (p->fixup & TODO_FFLAGS)
			set_fflags_platform(a, -1, p->name,
			    p->mode, p->fflags_set, 0);
		if (p->fixup & TODO_MAC_METADATA)
			set_mac_metadata(a, p->name, p->mac_metadata,
					 p->mac_metadata_size);
		next = p->next;
		archive_acl_clear(&p->acl);
		free(p->mac_metadata);
		free(p->name);
		free(p);
		p = next;
	}
	a->fixup_list = NULL;
	return (ret);
}

static int
_archive_write_disk_free(struct archive *_a)
{
	struct archive_write_disk *a;
	int ret;
	if (_a == NULL)
		return (ARCHIVE_OK);
	archive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, ""archive_write_disk_free"");
	a = (struct archive_write_disk *)_a;
	ret = _archive_write_disk_close(&a->archive);
	archive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);
	archive_write_disk_set_user_lookup(&a->archive, NULL, NULL, NULL);
	if (a->entry)
		archive_entry_free(a->entry);
	archive_string_free(&a->_name_data);
	archive_string_free(&a->archive.error_string);
	archive_string_free(&a->path_safe);
	a->archive.magic = 0;
	__archive_clean(&a->archive);
	free(a->decmpfs_header_p);
	free(a->resource_fork);
	free(a->compressed_buffer);
	free(a->uncompressed_buffer);
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\
	&& defined(HAVE_ZLIB_H)
	if (a->stream_valid) {
		switch (deflateEnd(&a->stream)) {
		case Z_OK:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Failed to clean up compressor"");
			ret = ARCHIVE_FATAL;
			break;
		}
	}
#endif
	free(a);
	return (ret);
}

/*
 * Simple O(n log n) merge sort to order the fixup list.  In
 * particular, we want to restore dir timestamps depth-first.
 */
static struct fixup_entry *
sort_dir_list(struct fixup_entry *p)
{
	struct fixup_entry *a, *b, *t;

	if (p == NULL)
		return (NULL);
	/* A one-item list is already sorted. */
	if (p->next == NULL)
		return (p);

	/* Step 1: split the list. */
	t = p;
	a = p->next->next;
	while (a != NULL) {
		/* Step a twice, t once. */
		a = a->next;
		if (a != NULL)
			a = a->next;
		t = t->next;
	}
	/* Now, t is at the mid-point, so break the list here. */
	b = t->next;
	t->next = NULL;
	a = p;

	/* Step 2: Recursively sort the two sub-lists. */
	a = sort_dir_list(a);
	b = sort_dir_list(b);

	/* Step 3: Merge the returned lists. */
	/* Pick the first element for the merged list. */
	if (strcmp(a->name, b->name) > 0) {
		t = p = a;
		a = a->next;
	} else {
		t = p = b;
		b = b->next;
	}

	/* Always put the later element on the list first. */
	while (a != NULL && b != NULL) {
		if (strcmp(a->name, b->name) > 0) {
			t->next = a;
			a = a->next;
		} else {
			t->next = b;
			b = b->next;
		}
		t = t->next;
	}

	/* Only one list is non-empty, so just splice it on. */
	if (a != NULL)
		t->next = a;
	if (b != NULL)
		t->next = b;

	return (p);
}

/*
 * Returns a new, initialized fixup entry.
 *
 * TODO: Reduce the memory requirements for this list by using a tree
 * structure rather than a simple list of names.
 */
static struct fixup_entry *
new_fixup(struct archive_write_disk *a, const char *pathname)
{
	struct fixup_entry *fe;

	fe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));
	if (fe == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate memory for a fixup"");
		return (NULL);
	}
	fe->next = a->fixup_list;
	a->fixup_list = fe;
	fe->fixup = 0;
	fe->name = strdup(pathname);
	return (fe);
}

/*
 * Returns a fixup structure for the current entry.
 */
static struct fixup_entry *
current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
 *    We shouldn't check multibyte character directly because some
 *    character-set have been using the '\' character for a part of
 *    its multibyte character code.
 * 2. Replace unusable characters in Windows with underscore('_').
 * See also : http://msdn.microsoft.com/en-us/library/aa365247.aspx
 */
static void
cleanup_pathname_win(struct archive_write_disk *a)
{
	wchar_t wc;
	char *p;
	size_t alen, l;
	int mb, complete, utf8;

	alen = 0;
	mb = 0;
	complete = 1;
	utf8 = (strcmp(nl_langinfo(CODESET), ""UTF-8"") == 0)? 1: 0;
	for (p = a->name; *p != '\0'; p++) {
		++alen;
		if (*p == '\\') {
			/* If previous byte is smaller than 128,
			 * this is not second byte of multibyte characters,
			 * so we can replace '\' with '/'. */
			if (utf8 || !mb)
				*p = '/';
			else
				complete = 0;/* uncompleted. */
		} else if (*(unsigned char *)p > 127)
			mb = 1;
		else
			mb = 0;
		/* Rewrite the path name if its next character is unusable. */
		if (*p == ':' || *p == '*' || *p == '?' || *p == '""' ||
		    *p == '<' || *p == '>' || *p == '|')
			*p = '_';
	}
	if (complete)
		return;

	/*
	 * Convert path separator in wide-character.
	 */
	p = a->name;
	while (*p != '\0' && alen) {
		l = mbtowc(&wc, p, alen);
		if (l == (size_t)-1) {
			while (*p != '\0') {
				if (*p == '\\')
					*p = '/';
				++p;
			}
			break;
		}
		if (l == 1 && wc == L'\\')
			*p = '/';
		p += l;
		alen -= l;
	}
}
#endif

/*
 * Canonicalize the pathname.  In particular, this strips duplicate
 * '/' characters, '.' elements, and trailing '/'.  It also raises an
 * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is
 * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
 * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

		separator = *src++;
	}

	/* Scan the pathname one element at a time. */
	for (;;) {
		/* src points to first char after '/' */
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			/* Found '//', ignore second one. */
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				/* Ignore trailing '.' */
				break;
			} else if (src[1] == '/') {
				/* Skip './'. */
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
				/*
				 * Note: Under no circumstances do we
				 * remove '..' elements.  In
				 * particular, restoring
				 * '/foo/../bar/' should create the
				 * 'foo' dir as a side-effect.
				 */
			}
		}

		/* Copy current element, including leading '/'. */
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}

		if (*src == '\0')
			break;

		/* Skip '/' separator. */
		separator = *src++;
	}
	/*
	 * We've just copied zero or more path elements, not including the
	 * final '/'.
	 */
	if (dest == a->name) {
		/*
		 * Nothing got copied.  The path must have been something
		 * like '.' or '/' or './' or '/././././/./'.
		 */
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	/* Terminate the result. */
	*dest = '\0';
	return (ARCHIVE_OK);
}

/*
 * Create the parent directory of the specified path, assuming path
 * is already in mutable storage.
 */
static int
create_parent_dir(struct archive_write_disk *a, char *path)
{
	char *slash;
	int r;

	/* Remove tail element to obtain parent name. */
	slash = strrchr(path, '/');
	if (slash == NULL)
		return (ARCHIVE_OK);
	*slash = '\0';
	r = create_dir(a, path);
	*slash = '/';
	return (r);
}

/*
 * Create the specified dir, recursing to create parents as necessary.
 *
 * Returns ARCHIVE_OK if the path exists when we're done here.
 * Otherwise, returns ARCHIVE_FAILED.
 * Assumes path is in mutable storage; path is unchanged on exit.
 */
static int
create_dir(struct archive_write_disk *a, char *path)
{
	struct stat st;
	struct fixup_entry *le;
	char *slash, *base;
	mode_t mode_final, mode;
	int r;

	/* Check for special names and just skip them. */
	slash = strrchr(path, '/');
	if (slash == NULL)
		base = path;
	else
		base = slash + 1;

	if (base[0] == '\0' ||
	    (base[0] == '.' && base[1] == '\0') ||
	    (base[0] == '.' && base[1] == '.' && base[2] == '\0')) {
		/* Don't bother trying to create null path, '.', or '..'. */
		if (slash != NULL) {
			*slash = '\0';
			r = create_dir(a, path);
			*slash = '/';
			return (r);
		}
		return (ARCHIVE_OK);
	}

	/*
	 * Yes, this should be stat() and not lstat().  Using lstat()
	 * here loses the ability to extract through symlinks.  Also note
	 * that this should not use the a->st cache.
	 */
	if (stat(path, &st) == 0) {
		if (S_ISDIR(st.st_mode))
			return (ARCHIVE_OK);
		if ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {
			archive_set_error(&a->archive, EEXIST,
			    ""Can't create directory '%s'"", path);
			return (ARCHIVE_FAILED);
		}
		if (unlink(path) != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't create directory '%s': ""
			    ""Conflicting file cannot be removed"",
			    path);
			return (ARCHIVE_FAILED);
		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
		r = create_dir(a, path);
		*slash = '/';
		if (r != ARCHIVE_OK)
			return (r);
	}

	/*
	 * Mode we want for the final restored directory.  Per POSIX,
	 * implicitly-created dirs must be created obeying the umask.
	 * There's no mention whether this is different for privileged
	 * restores (which the rest of this code handles by pretending
	 * umask=0).  I've chosen here to always obey the user's umask for
	 * implicit dirs, even if _EXTRACT_PERM was specified.
	 */
	mode_final = DEFAULT_DIR_MODE & ~a->user_umask;
	/* Mode we want on disk during the restore process. */
	mode = mode_final;
	mode |= MINIMUM_DIR_MODE;
	mode &= MAXIMUM_DIR_MODE;
	if (mkdir(path, mode) == 0) {
		if (mode != mode_final) {
			le = new_fixup(a, path);
			if (le == NULL)
				return (ARCHIVE_FATAL);
			le->fixup |=TODO_MODE_BASE;
			le->mode = mode_final;
		}
		return (ARCHIVE_OK);
	}

	/*
	 * Without the following check, a/b/../b/c/d fails at the
	 * second visit to 'b', so 'd' can't be created.  Note that we
	 * don't add it to the fixup list here, as it's already been
	 * added.
	 */
	if (stat(path, &st) == 0 && S_ISDIR(st.st_mode))
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, errno, ""Failed to create dir '%s'"",
	    path);
	return (ARCHIVE_FAILED);
}

/*
 * Note: Although we can skip setting the user id if the desired user
 * id matches the current user, we cannot skip setting the group, as
 * many systems set the gid based on the containing directory.  So
 * we have to perform a chown syscall if we want to set the SGID
 * bit.  (The alternative is to stat() and then possibly chown(); it's
 * more efficient to skip the stat() and just always chown().)  Note
 * that a successful chown() here clears the TODO_SGID_CHECK bit, which
 * allows set_mode to skip the stat() check for the GID.
 */
static int
set_ownership(struct archive_write_disk *a)
{
#ifndef __CYGWIN__
/* unfortunately, on win32 there is no 'root' user with uid 0,
   so we just have to try the chown and see if it works */

	/* If we know we can't change it, don't bother trying. */
	if (a->user_uid != 0  &&  a->user_uid != a->uid) {
		archive_set_error(&a->archive, errno,
		    ""Can't set UID=%jd"", (intmax_t)a->uid);
		return (ARCHIVE_WARN);
	}
#endif

#ifdef HAVE_FCHOWN
	/* If we have an fd, we can avoid a race. */
	if (a->fd >= 0 && fchown(a->fd, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#endif

	/* We prefer lchown() but will use chown() if that's all we have. */
	/* Of course, if we have neither, this will always fail. */
#ifdef HAVE_LCHOWN
	if (lchown(a->name, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#elif HAVE_CHOWN
	if (!S_ISLNK(a->mode) && chown(a->name, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#endif

	archive_set_error(&a->archive, errno,
	    ""Can't set user=%jd/group=%jd for %s"",
	    (intmax_t)a->uid, (intmax_t)a->gid, a->name);
	return (ARCHIVE_WARN);
}

/*
 * Note: Returns 0 on success, non-zero on failure.
 */
static int
set_time(int fd, int mode, const char *name,
    time_t atime, long atime_nsec,
    time_t mtime, long mtime_nsec)
{
	/* Select the best implementation for this platform. */
#if defined(HAVE_UTIMENSAT) && defined(HAVE_FUTIMENS)
	/*
	 * utimensat() and futimens() are defined in
	 * POSIX.1-2008. They support ns resolution and setting times
	 * on fds and symlinks.
	 */
	struct timespec ts[2];
	(void)mode; /* UNUSED */
	ts[0].tv_sec = atime;
	ts[0].tv_nsec = atime_nsec;
	ts[1].tv_sec = mtime;
	ts[1].tv_nsec = mtime_nsec;
	if (fd >= 0)
		return futimens(fd, ts);
	return utimensat(AT_FDCWD, name, ts, AT_SYMLINK_NOFOLLOW);

#elif HAVE_UTIMES
	/*
	 * The utimes()-family functions support µs-resolution and
	 * setting times fds and symlinks.  utimes() is documented as
	 * LEGACY by POSIX, futimes() and lutimes() are not described
	 * in POSIX.
	 */
	struct timeval times[2];

	times[0].tv_sec = atime;
	times[0].tv_usec = atime_nsec / 1000;
	times[1].tv_sec = mtime;
	times[1].tv_usec = mtime_nsec / 1000;

#ifdef HAVE_FUTIMES
	if (fd >= 0)
		return (futimes(fd, times));
#else
	(void)fd; /* UNUSED */
#endif
#ifdef HAVE_LUTIMES
	(void)mode; /* UNUSED */
	return (lutimes(name, times));
#else
	if (S_ISLNK(mode))
		return (0);
	return (utimes(name, times));
#endif

#elif defined(HAVE_UTIME)
	/*
	 * utime() is POSIX-standard but only supports 1s resolution and
	 * does not support fds or symlinks.
	 */
	struct utimbuf times;
	(void)fd; /* UNUSED */
	(void)name; /* UNUSED */
	(void)atime_nsec; /* UNUSED */
	(void)mtime_nsec; /* UNUSED */
	times.actime = atime;
	times.modtime = mtime;
	if (S_ISLNK(mode))
		return (ARCHIVE_OK);
	return (utime(name, &times));

#else
	/*
	 * We don't know how to set the time on this platform.
	 */
	(void)fd; /* UNUSED */
	(void)mode; /* UNUSED */
	(void)name; /* UNUSED */
	(void)atime_nsec; /* UNUSED */
	(void)mtime_nsec; /* UNUSED */
	return (ARCHIVE_WARN);
#endif
}

#ifdef F_SETTIMES
static int
set_time_tru64(int fd, int mode, const char *name,
    time_t atime, long atime_nsec,
    time_t mtime, long mtime_nsec,
    time_t ctime, long ctime_nsec)
{
	struct attr_timbuf tstamp;
	tstamp.atime.tv_sec = atime;
	tstamp.mtime.tv_sec = mtime;
	tstamp.ctime.tv_sec = ctime;
#if defined (__hpux) && defined (__ia64)
	tstamp.atime.tv_nsec = atime_nsec;
	tstamp.mtime.tv_nsec = mtime_nsec;
	tstamp.ctime.tv_nsec = ctime_nsec;
#else
	tstamp.atime.tv_usec = atime_nsec / 1000;
	tstamp.mtime.tv_usec = mtime_nsec / 1000;
	tstamp.ctime.tv_usec = ctime_nsec / 1000;
#endif
	return (fcntl(fd,F_SETTIMES,&tstamp));
}
#endif /* F_SETTIMES */

static int
set_times(struct archive_write_disk *a,
    int fd, int mode, const char *name,
    time_t atime, long atime_nanos,
    time_t birthtime, long birthtime_nanos,
    time_t mtime, long mtime_nanos,
    time_t cctime, long ctime_nanos)
{
	/* Note: set_time doesn't use libarchive return conventions!
	 * It uses syscall conventions.  So 0 here instead of ARCHIVE_OK. */
	int r1 = 0, r2 = 0;

#ifdef F_SETTIMES
	 /*
	 * on Tru64 try own fcntl first which can restore even the
	 * ctime, fall back to default code path below if it fails
	 * or if we are not running as root
	 */
	if (a->user_uid == 0 &&
	    set_time_tru64(fd, mode, name,
			   atime, atime_nanos, mtime,
			   mtime_nanos, cctime, ctime_nanos) == 0) {
		return (ARCHIVE_OK);
	}
#else /* Tru64 */
	(void)cctime; /* UNUSED */
	(void)ctime_nanos; /* UNUSED */
#endif /* Tru64 */

#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
	/*
	 * If you have struct stat.st_birthtime, we assume BSD
	 * birthtime semantics, in which {f,l,}utimes() updates
	 * birthtime to earliest mtime.  So we set the time twice,
	 * first using the birthtime, then using the mtime.  If
	 * birthtime == mtime, this isn't necessary, so we skip it.
	 * If birthtime > mtime, then this won't work, so we skip it.
	 */
	if (birthtime < mtime
	    || (birthtime == mtime && birthtime_nanos < mtime_nanos))
		r1 = set_time(fd, mode, name,
			      atime, atime_nanos,
			      birthtime, birthtime_nanos);
#else
	(void)birthtime; /* UNUSED */
	(void)birthtime_nanos; /* UNUSED */
#endif
	r2 = set_time(fd, mode, name,
		      atime, atime_nanos,
		      mtime, mtime_nanos);
	if (r1 != 0 || r2 != 0) {
		archive_set_error(&a->archive, errno,
				  ""Can't restore time"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

static int
set_times_from_entry(struct archive_write_disk *a)
{
	time_t atime, birthtime, mtime, cctime;
	long atime_nsec, birthtime_nsec, mtime_nsec, ctime_nsec;

	/* Suitable defaults. */
	atime = birthtime = mtime = cctime = a->start_time;
	atime_nsec = birthtime_nsec = mtime_nsec = ctime_nsec = 0;

	/* If no time was provided, we're done. */
	if (!archive_entry_atime_is_set(a->entry)
#if HAVE_STRUCT_STAT_ST_BIRTHTIME
	    && !archive_entry_birthtime_is_set(a->entry)
#endif
	    && !archive_entry_mtime_is_set(a->entry))
		return (ARCHIVE_OK);

	if (archive_entry_atime_is_set(a->entry)) {
		atime = archive_entry_atime(a->entry);
		atime_nsec = archive_entry_atime_nsec(a->entry);
	}
	if (archive_entry_birthtime_is_set(a->entry)) {
		birthtime = archive_entry_birthtime(a->entry);
		birthtime_nsec = archive_entry_birthtime_nsec(a->entry);
	}
	if (archive_entry_mtime_is_set(a->entry)) {
		mtime = archive_entry_mtime(a->entry);
		mtime_nsec = archive_entry_mtime_nsec(a->entry);
	}
	if (archive_entry_ctime_is_set(a->entry)) {
		cctime = archive_entry_ctime(a->entry);
		ctime_nsec = archive_entry_ctime_nsec(a->entry);
	}

	return set_times(a, a->fd, a->mode, a->name,
			 atime, atime_nsec,
			 birthtime, birthtime_nsec,
			 mtime, mtime_nsec,
			 cctime, ctime_nsec);
}

static int
set_mode(struct archive_write_disk *a, int mode)
{
	int r = ARCHIVE_OK;
	mode &= 07777; /* Strip off file type bits. */

	if (a->todo & TODO_SGID_CHECK) {
		/*
		 * If we don't know the GID is right, we must stat()
		 * to verify it.  We can't just check the GID of this
		 * process, since systems sometimes set GID from
		 * the enclosing dir or based on ACLs.
		 */
		if ((r = lazy_stat(a)) != ARCHIVE_OK)
			return (r);
		if (a->pst->st_gid != a->gid) {
			mode &= ~ S_ISGID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				/*
				 * This is only an error if you
				 * requested owner restore.  If you
				 * didn't, we'll try to restore
				 * sgid/suid, but won't consider it a
				 * problem if we can't.
				 */
				archive_set_error(&a->archive, -1,
				    ""Can't restore SGID bit"");
				r = ARCHIVE_WARN;
			}
		}
		/* While we're here, double-check the UID. */
		if (a->pst->st_uid != a->uid
		    && (a->todo & TODO_SUID)) {
			mode &= ~ S_ISUID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				archive_set_error(&a->archive, -1,
				    ""Can't restore SUID bit"");
				r = ARCHIVE_WARN;
			}
		}
		a->todo &= ~TODO_SGID_CHECK;
		a->todo &= ~TODO_SUID_CHECK;
	} else if (a->todo & TODO_SUID_CHECK) {
		/*
		 * If we don't know the UID is right, we can just check
		 * the user, since all systems set the file UID from
		 * the process UID.
		 */
		if (a->user_uid != a->uid) {
			mode &= ~ S_ISUID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				archive_set_error(&a->archive, -1,
				    ""Can't make file SUID"");
				r = ARCHIVE_WARN;
			}
		}
		a->todo &= ~TODO_SUID_CHECK;
	}

	if (S_ISLNK(a->mode)) {
#ifdef HAVE_LCHMOD
		/*
		 * If this is a symlink, use lchmod().  If the
		 * platform doesn't support lchmod(), just skip it.  A
		 * platform that doesn't provide a way to set
		 * permissions on symlinks probably ignores
		 * permissions on symlinks, so a failure here has no
		 * impact.
		 */
		if (lchmod(a->name, mode) != 0) {
			switch (errno) {
			case ENOTSUP:
			case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
			case EOPNOTSUPP:
#endif
				/*
				 * if lchmod is defined but the platform
				 * doesn't support it, silently ignore
				 * error
				 */
				break;
			default:
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
		}
#endif
	} else if (!S_ISDIR(a->mode)) {
		/*
		 * If it's not a symlink and not a dir, then use
		 * fchmod() or chmod(), depending on whether we have
		 * an fd.  Dirs get their perms set during the
		 * post-extract fixup, which is handled elsewhere.
		 */
#ifdef HAVE_FCHMOD
		if (a->fd >= 0) {
			if (fchmod(a->fd, mode) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
		} else
#endif
			/* If this platform lacks fchmod(), then
			 * we'll just use chmod(). */
			if (chmod(a->name, mode) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
	}
	return (r);
}

static int
set_fflags(struct archive_write_disk *a)
{
	struct fixup_entry *le;
	unsigned long	set, clear;
	int		r;
	int		critical_flags;
	mode_t		mode = archive_entry_mode(a->entry);

	/*
	 * Make 'critical_flags' hold all file flags that can't be
	 * immediately restored.  For example, on BSD systems,
	 * SF_IMMUTABLE prevents hardlinks from being created, so
	 * should not be set until after any hardlinks are created.  To
	 * preserve some semblance of portability, this uses #ifdef
	 * extensively.  Ugly, but it works.
	 *
	 * Yes, Virginia, this does create a security race.  It's mitigated
	 * somewhat by the practice of creating dirs 0700 until the extract
	 * is done, but it would be nice if we could do more than that.
	 * People restoring critical file systems should be wary of
	 * other programs that might try to muck with files as they're
	 * being restored.
	 */
	/* Hopefully, the compiler will optimize this mess into a constant. */
	critical_flags = 0;
#ifdef SF_IMMUTABLE
	critical_flags |= SF_IMMUTABLE;
#endif
#ifdef UF_IMMUTABLE
	critical_flags |= UF_IMMUTABLE;
#endif
#ifdef SF_APPEND
	critical_flags |= SF_APPEND;
#endif
#ifdef UF_APPEND
	critical_flags |= UF_APPEND;
#endif
#ifdef EXT2_APPEND_FL
	critical_flags |= EXT2_APPEND_FL;
#endif
#ifdef EXT2_IMMUTABLE_FL
	critical_flags |= EXT2_IMMUTABLE_FL;
#endif

	if (a->todo & TODO_FFLAGS) {
		archive_entry_fflags(a->entry, &set, &clear);

		/*
		 * The first test encourages the compiler to eliminate
		 * all of this if it's not necessary.
		 */
		if ((critical_flags != 0)  &&  (set & critical_flags)) {
			le = current_fixup(a, a->name);
			if (le == NULL)
				return (ARCHIVE_FATAL);
			le->fixup |= TODO_FFLAGS;
			le->fflags_set = set;
			/* Store the mode if it's not already there. */
			if ((le->fixup & TODO_MODE) == 0)
				le->mode = mode;
		} else {
			r = set_fflags_platform(a, a->fd,
			    a->name, mode, set, clear);
			if (r != ARCHIVE_OK)
				return (r);
		}
	}
	return (ARCHIVE_OK);
}

static int
clear_nochange_fflags(struct archive_write_disk *a)
{
	int		nochange_flags;
	mode_t		mode = archive_entry_mode(a->entry);

	/* Hopefully, the compiler will optimize this mess into a constant. */
	nochange_flags = 0;
#ifdef SF_IMMUTABLE
	nochange_flags |= SF_IMMUTABLE;
#endif
#ifdef UF_IMMUTABLE
	nochange_flags |= UF_IMMUTABLE;
#endif
#ifdef SF_APPEND
	nochange_flags |= SF_APPEND;
#endif
#ifdef UF_APPEND
	nochange_flags |= UF_APPEND;
#endif
#ifdef EXT2_APPEND_FL
	nochange_flags |= EXT2_APPEND_FL;
#endif
#ifdef EXT2_IMMUTABLE_FL
	nochange_flags |= EXT2_IMMUTABLE_FL;
#endif

	return (set_fflags_platform(a, a->fd, a->name, mode, 0, nochange_flags));
}


#if ( defined(HAVE_LCHFLAGS) || defined(HAVE_CHFLAGS) || defined(HAVE_FCHFLAGS) ) && defined(HAVE_STRUCT_STAT_ST_FLAGS)
/*
 * BSD reads flags using stat() and sets them with one of {f,l,}chflags()
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	int r;

	(void)mode; /* UNUSED */
	if (set == 0  && clear == 0)
		return (ARCHIVE_OK);

	/*
	 * XXX Is the stat here really necessary?  Or can I just use
	 * the 'set' flags directly?  In particular, I'm not sure
	 * about the correct approach if we're overwriting an existing
	 * file that already has flags on it. XXX
	 */
	if ((r = lazy_stat(a)) != ARCHIVE_OK)
		return (r);

	a->st.st_flags &= ~clear;
	a->st.st_flags |= set;
#ifdef HAVE_FCHFLAGS
	/* If platform has fchflags() and we were given an fd, use it. */
	if (fd >= 0 && fchflags(fd, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#endif
	/*
	 * If we can't use the fd to set the flags, we'll use the
	 * pathname to set flags.  We prefer lchflags() but will use
	 * chflags() if we must.
	 */
#ifdef HAVE_LCHFLAGS
	if (lchflags(name, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#elif defined(HAVE_CHFLAGS)
	if (S_ISLNK(a->st.st_mode)) {
		archive_set_error(&a->archive, errno,
		    ""Can't set file flags on symlink."");
		return (ARCHIVE_WARN);
	}
	if (chflags(name, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#endif
	archive_set_error(&a->archive, errno,
	    ""Failed to set file flags"");
	return (ARCHIVE_WARN);
}

#elif defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(HAVE_WORKING_EXT2_IOC_GETFLAGS)
/*
 * Linux uses ioctl() to read and write file flags.
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	int		 ret;
	int		 myfd = fd;
	int newflags, oldflags;
	int sf_mask = 0;

	if (set == 0  && clear == 0)
		return (ARCHIVE_OK);
	/* Only regular files and dirs can have flags. */
	if (!S_ISREG(mode) && !S_ISDIR(mode))
		return (ARCHIVE_OK);

	/* If we weren't given an fd, open it ourselves. */
	if (myfd < 0) {
		myfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);
		__archive_ensure_cloexec_flag(myfd);
	}
	if (myfd < 0)
		return (ARCHIVE_OK);

	/*
	 * Linux has no define for the flags that are only settable by
	 * the root user.  This code may seem a little complex, but
	 * there seem to be some Linux systems that lack these
	 * defines. (?)  The code below degrades reasonably gracefully
	 * if sf_mask is incomplete.
	 */
#ifdef EXT2_IMMUTABLE_FL
	sf_mask |= EXT2_IMMUTABLE_FL;
#endif
#ifdef EXT2_APPEND_FL
	sf_mask |= EXT2_APPEND_FL;
#endif
	/*
	 * XXX As above, this would be way simpler if we didn't have
	 * to read the current flags from disk. XXX
	 */
	ret = ARCHIVE_OK;

	/* Read the current file flags. */
	if (ioctl(myfd, EXT2_IOC_GETFLAGS, &oldflags) < 0)
		goto fail;

	/* Try setting the flags as given. */
	newflags = (oldflags & ~clear) | set;
	if (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)
		goto cleanup;
	if (errno != EPERM)
		goto fail;

	/* If we couldn't set all the flags, try again with a subset. */
	newflags &= ~sf_mask;
	oldflags &= sf_mask;
	newflags |= oldflags;
	if (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)
		goto cleanup;

	/* We couldn't set the flags, so report the failure. */
fail:
	archive_set_error(&a->archive, errno,
	    ""Failed to set file flags"");
	ret = ARCHIVE_WARN;
cleanup:
	if (fd < 0)
		close(myfd);
	return (ret);
}

#else

/*
 * Of course, some systems have neither BSD chflags() nor Linux' flags
 * support through ioctl().
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	(void)a; /* UNUSED */
	(void)fd; /* UNUSED */
	(void)name; /* UNUSED */
	(void)mode; /* UNUSED */
	(void)set; /* UNUSED */
	(void)clear; /* UNUSED */
	return (ARCHIVE_OK);
}

#endif /* __linux */

#ifndef HAVE_COPYFILE_H
/* Default is to simply drop Mac extended metadata. */
static int
set_mac_metadata(struct archive_write_disk *a, const char *pathname,
		 const void *metadata, size_t metadata_size)
{
	(void)a; /* UNUSED */
	(void)pathname; /* UNUSED */
	(void)metadata; /* UNUSED */
	(void)metadata_size; /* UNUSED */
	return (ARCHIVE_OK);
}

static int
fixup_appledouble(struct archive_write_disk *a, const char *pathname)
{
	(void)a; /* UNUSED */
	(void)pathname; /* UNUSED */
	return (ARCHIVE_OK);
}
#else

/*
 * On Mac OS, we use copyfile() to unpack the metadata and
 * apply it to the target file.
 */

#if defined(HAVE_SYS_XATTR_H)
static int
copy_xattrs(struct archive_write_disk *a, int tmpfd, int dffd)
{
	ssize_t xattr_size;
	char *xattr_names = NULL, *xattr_val = NULL;
	int ret = ARCHIVE_OK, xattr_i;

	xattr_size = flistxattr(tmpfd, NULL, 0, 0);
	if (xattr_size == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read metadata(xattr)"");
		ret = ARCHIVE_WARN;
		goto exit_xattr;
	}
	xattr_names = malloc(xattr_size);
	if (xattr_names == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate memory for metadata(xattr)"");
		ret = ARCHIVE_FATAL;
		goto exit_xattr;
	}
	xattr_size = flistxattr(tmpfd, xattr_names, xattr_size, 0);
	if (xattr_size == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read metadata(xattr)"");
		ret = ARCHIVE_WARN;
		goto exit_xattr;
	}
	for (xattr_i = 0; xattr_i < xattr_size;
	    xattr_i += strlen(xattr_names + xattr_i) + 1) {
		char *xattr_val_saved;
		ssize_t s;
		int f;

		s = fgetxattr(tmpfd, xattr_names + xattr_i, NULL, 0, 0, 0);
		if (s == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
		xattr_val_saved = xattr_val;
		xattr_val = realloc(xattr_val, s);
		if (xattr_val == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			free(xattr_val_saved);
			goto exit_xattr;
		}
		s = fgetxattr(tmpfd, xattr_names + xattr_i, xattr_val, s, 0, 0);
		if (s == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
		f = fsetxattr(dffd, xattr_names + xattr_i, xattr_val, s, 0, 0);
		if (f == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
	}
exit_xattr:
	free(xattr_names);
	free(xattr_val);
	return (ret);
}
#endif

static int
copy_acls(struct archive_write_disk *a, int tmpfd, int dffd)
{
	acl_t acl, dfacl = NULL;
	int acl_r, ret = ARCHIVE_OK;

	acl = acl_get_fd(tmpfd);
	if (acl == NULL) {
		if (errno == ENOENT)
			/* There are not any ACLs. */
			return (ret);
		archive_set_error(&a->archive, errno,
		    ""Failed to get metadata(acl)"");
		ret = ARCHIVE_WARN;
		goto exit_acl;
	}
	dfacl = acl_dup(acl);
	acl_r = acl_set_fd(dffd, dfacl);
	if (acl_r == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to get metadata(acl)"");
		ret = ARCHIVE_WARN;
		goto exit_acl;
	}
exit_acl:
	if (acl)
		acl_free(acl);
	if (dfacl)
		acl_free(dfacl);
	return (ret);
}

static int
create_tempdatafork(struct archive_write_disk *a, const char *pathname)
{
	struct archive_string tmpdatafork;
	int tmpfd;

	archive_string_init(&tmpdatafork);
	archive_strcpy(&tmpdatafork, ""tar.md.XXXXXX"");
	tmpfd = mkstemp(tmpdatafork.s);
	if (tmpfd < 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to mkstemp"");
		archive_string_free(&tmpdatafork);
		return (-1);
	}
	if (copyfile(pathname, tmpdatafork.s, 0,
	    COPYFILE_UNPACK | COPYFILE_NOFOLLOW
	    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to restore metadata"");
		close(tmpfd);
		tmpfd = -1;
	}
	unlink(tmpdatafork.s);
	archive_string_free(&tmpdatafork);
	return (tmpfd);
}

static int
copy_metadata(struct archive_write_disk *a, const char *metadata,
    const char *datafork, int datafork_compressed)
{
	int ret = ARCHIVE_OK;

	if (datafork_compressed) {
		int dffd, tmpfd;

		tmpfd = create_tempdatafork(a, metadata);
		if (tmpfd == -1)
			return (ARCHIVE_WARN);

		/*
		 * Do not open the data fork compressed by HFS+ compression
		 * with at least a writing mode(O_RDWR or O_WRONLY). it
		 * makes the data fork uncompressed.
		 */
		dffd = open(datafork, 0);
		if (dffd == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to open the data fork for metadata"");
			close(tmpfd);
			return (ARCHIVE_WARN);
		}

#if defined(HAVE_SYS_XATTR_H)
		ret = copy_xattrs(a, tmpfd, dffd);
		if (ret == ARCHIVE_OK)
#endif
			ret = copy_acls(a, tmpfd, dffd);
		close(tmpfd);
		close(dffd);
	} else {
		if (copyfile(metadata, datafork, 0,
		    COPYFILE_UNPACK | COPYFILE_NOFOLLOW
		    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {
			archive_set_error(&a->archive, errno,
			    ""Failed to restore metadata"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}

static int
set_mac_metadata(struct archive_write_disk *a, const char *pathname,
		 const void *metadata, size_t metadata_size)
{
	struct archive_string tmp;
	ssize_t written;
	int fd;
	int ret = ARCHIVE_OK;

	/* This would be simpler if copyfile() could just accept the
	 * metadata as a block of memory; then we could sidestep this
	 * silly dance of writing the data to disk just so that
	 * copyfile() can read it back in again. */
	archive_string_init(&tmp);
	archive_strcpy(&tmp, pathname);
	archive_strcat(&tmp, "".XXXXXX"");
	fd = mkstemp(tmp.s);

	if (fd < 0) {
		archive_set_error(&a->archive, errno,
				  ""Failed to restore metadata"");
		archive_string_free(&tmp);
		return (ARCHIVE_WARN);
	}
	written = write(fd, metadata, metadata_size);
	close(fd);
	if ((size_t)written != metadata_size) {
		archive_set_error(&a->archive, errno,
				  ""Failed to restore metadata"");
		ret = ARCHIVE_WARN;
	} else {
		int compressed;

#if defined(UF_COMPRESSED)
		if ((a->todo & TODO_HFS_COMPRESSION) != 0 &&
		    (ret = lazy_stat(a)) == ARCHIVE_OK)
			compressed = a->st.st_flags & UF_COMPRESSED;
		else
#endif
			compressed = 0;
		ret = copy_metadata(a, tmp.s, pathname, compressed);
	}
	unlink(tmp.s);
	archive_string_free(&tmp);
	return (ret);
}

static int
fixup_appledouble(struct archive_write_disk *a, const char *pathname)
{
	char buff[8];
	struct stat st;
	const char *p;
	struct archive_string datafork;
	int fd = -1, ret = ARCHIVE_OK;

	archive_string_init(&datafork);
	/* Check if the current file name is a type of the resource
	 * fork file. */
	p = strrchr(pathname, '/');
	if (p == NULL)
		p = pathname;
	else
		p++;
	if (p[0] != '.' || p[1] != '_')
		goto skip_appledouble;

	/*
	 * Check if the data fork file exists.
	 *
	 * TODO: Check if this write disk object has handled it.
	 */
	archive_strncpy(&datafork, pathname, p - pathname);
	archive_strcat(&datafork, p + 2);
	if (lstat(datafork.s, &st) == -1 ||
	    (st.st_mode & AE_IFMT) != AE_IFREG)
		goto skip_appledouble;

	/*
	 * Check if the file is in the AppleDouble form.
	 */
	fd = open(pathname, O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(fd);
	if (fd == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to open a restoring file"");
		ret = ARCHIVE_WARN;
		goto skip_appledouble;
	}
	if (read(fd, buff, 8) == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read a restoring file"");
		close(fd);
		ret = ARCHIVE_WARN;
		goto skip_appledouble;
	}
	close(fd);
	/* Check AppleDouble Magic Code. */
	if (archive_be32dec(buff) != 0x00051607)
		goto skip_appledouble;
	/* Check AppleDouble Version. */
	if (archive_be32dec(buff+4) != 0x00020000)
		goto skip_appledouble;

	ret = copy_metadata(a, pathname, datafork.s,
#if defined(UF_COMPRESSED)
	    st.st_flags & UF_COMPRESSED);
#else
	    0);
#endif
	if (ret == ARCHIVE_OK) {
		unlink(pathname);
		ret = ARCHIVE_EOF;
	}
skip_appledouble:
	archive_string_free(&datafork);
	return (ret);
}
#endif

#if HAVE_LSETXATTR || HAVE_LSETEA
/*
 * Restore extended attributes -  Linux and AIX implementations:
 * AIX' ea interface is syntaxwise identical to the Linux xattr interface.
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL &&
				strncmp(name, ""xfsroot."", 8) != 0 &&
				strncmp(name, ""system."", 7) != 0) {
			int e;
#if HAVE_FSETXATTR
			if (a->fd >= 0)
				e = fsetxattr(a->fd, name, value, size, 0);
			else
#elif HAVE_FSETEA
			if (a->fd >= 0)
				e = fsetea(a->fd, name, value, size, 0);
			else
#endif
			{
#if HAVE_LSETXATTR
				e = lsetxattr(archive_entry_pathname(entry),
				    name, value, size, 0);
#elif HAVE_LSETEA
				e = lsetea(archive_entry_pathname(entry),
				    name, value, size, 0);
#endif
			}
			if (e == -1) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}
#elif HAVE_EXTATTR_SET_FILE && HAVE_DECL_EXTATTR_NAMESPACE_USER
/*
 * Restore extended attributes -  FreeBSD implementation
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL) {
			int e;
			int namespace;

			if (strncmp(name, ""user."", 5) == 0) {
				/* ""user."" attributes go to user namespace */
				name += 5;
				namespace = EXTATTR_NAMESPACE_USER;
			} else {
				/* Warn about other extended attributes. */
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);
				ret = ARCHIVE_WARN;
				continue;
			}
			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else {
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				}

				ret = ARCHIVE_WARN;
			}
		}
	}
	return (ret);
}
#else
/*
 * Restore extended attributes - stub implementation for unsupported systems
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	static int warning_done = 0;

	/* If there aren't any extended attributes, then it's okay not
	 * to extract them, otherwise, issue a single warning. */
	if (archive_entry_xattr_count(a->entry) != 0 && !warning_done) {
		warning_done = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Cannot restore extended attributes on this system"");
		return (ARCHIVE_WARN);
	}
	/* Warning was already emitted; suppress further warnings. */
	return (ARCHIVE_OK);
}
#endif

/*
 * Test if file on disk is older than entry.
 */
static int
older(struct stat *st, struct archive_entry *entry)
{
	/* First, test the seconds and return if we have a definite answer. */
	/* Definitely older. */
	if (st->st_mtime < archive_entry_mtime(entry))
		return (1);
	/* Definitely younger. */
	if (st->st_mtime > archive_entry_mtime(entry))
		return (0);
	/* If this platform supports fractional seconds, try those. */
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
	/* Definitely older. */
	if (st->st_mtimespec.tv_nsec < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
	/* Definitely older. */
	if (st->st_mtim.tv_nsec < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIME_N
	/* older. */
	if (st->st_mtime_n < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_UMTIME
	/* older. */
	if (st->st_umtime * 1000 < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIME_USEC
	/* older. */
	if (st->st_mtime_usec * 1000 < archive_entry_mtime_nsec(entry))
		return (1);
#else
	/* This system doesn't have high-res timestamps. */
#endif
	/* Same age or newer, so not older. */
	return (0);
}

#endi",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_127.cpp,"[397, 19, 4, 2, 16, 3, 206, 4, 11, 4, 497, 6, 20, 0, 155, 6633, 0, 0, 231, 508, 39, 63, 65, 581, 0, 2, 0, 0, 233, 0, 545, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3061, 5, 2715, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 611, 0, 53, 0, 396, 366, 63, 0, 561, 250, 0, 750, 22, 1141, 296, 4, 35, 38, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_127.cpp,2463
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_172.cpp,2534,2807,2543,2817,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_128.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_128.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_128.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_128.cpp,8
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_172.cpp,2534,2807,2554,2828,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_129.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_129.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_129.cpp,19
a59a7ee95601f3496ec9ba9ae1283a8d980460bf,"Merge branch 'upstream-LibArchive' into update-libarchive

* upstream-LibArchive:
  LibArchive 2017-02-19 (100ee75a)",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_76.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_76.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_173.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_173.cpp,2580,2854,2583,2858,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_130.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_130.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_130.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_130.cpp,48
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_182.cpp,302,321,312,324,"archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");","archive_set_error(&a->archive, errno,
			    ""Can't change dir to read extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_131.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_131.cpp,"{
			archive_set_error(&a->archive, errno,
				    ""Couldn't change dir"");
				return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_131.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_131.cpp,25
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_183.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_183.cpp,772,1486,785,1496,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_132.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_132.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_132.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_132.cpp,19
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_81.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_81.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_184.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_184.cpp,932,1645,945,1655,"archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't determine file path to read ""
			    ""extended attributes"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_133.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_133.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""Couldn't access %s"", path);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_133.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_133.cpp,21
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_186.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_186.cpp,938,938,939,939,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_134.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_134.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_134.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_134.cpp,66
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_187.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_187.cpp,1041,1041,1042,1042,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_135.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_135.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_135.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_135.cpp,169
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_82.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_82.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_188.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_188.cpp,1067,1067,1068,1068,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_136.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_136.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_136.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_136.cpp,195
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_83.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_190.cpp,803,802,804,803,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_137.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_137.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_137.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_137.cpp,50
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_83.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_191.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_191.cpp,875,874,876,875,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_138.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_138.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_138.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_138.cpp,122
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_83.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_83.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_192.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_192.cpp,901,900,902,901,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));","archive_set_error(&(a->archive), errno,
			    ""Failed : %s"", archive_error_string(a->matching));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_139.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_139.cpp,"{
			archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));
			return (r);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_139.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_139.cpp,148
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,789,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_140.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_140.cpp,"{
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_140.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_140.cpp,14
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,820,-1,"archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_141.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_141.cpp,"{
	static const size_t out_block_size = 64 * 1024;
	void *out_block;
	struct private_data *state;
	ssize_t ret, avail_in;

	self->code = ARCHIVE_FILTER_LZMA;
	self->name = ""lzma"";

	state = (struct private_data *)calloc(sizeof(*state), 1);
	out_block = (unsigned char *)malloc(out_block_size);
	if (state == NULL || out_block == NULL) {
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Can't allocate data for lzma decompression"");
		free(out_block);
		free(state);
		return (ARCHIVE_FATAL);
	}

	self->data = state;
	state->out_block_size = out_block_size;
	state->out_block = out_block;
	self->read = lzma_filter_read;
	self->skip = NULL; /* not supported */
	self->close = lzma_filter_close;

	/* Prime the lzma library with 18 bytes of input. */
	state->stream.next_in = (unsigned char *)(uintptr_t)
	    __archive_read_filter_ahead(self->upstream, 18, &avail_in);
	if (state->stream.next_in == NULL)
		return (ARCHIVE_FATAL);
	state->stream.avail_in = avail_in;
	state->stream.next_out = state->out_block;
	state->stream.avail_out = state->out_block_size;

	/* Initialize compression library. */
	ret = lzmadec_init(&(state->stream));
	__archive_read_filter_consume(self->upstream,
	    avail_in - state->stream.avail_in);
	if (ret == LZMADEC_OK)
		return (ARCHIVE_OK);

	/* Library setup failed: Clean up. */
	archive_set_error(&self->archive->archive, ARCHIVE_ERRNO_MISC,
	    ""Internal error initializing lzma library"");

	/* Override the error message if we know what really went wrong. */
	switch (ret) {
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}

	free(state->out_block);
	free(state);
	self->data = NULL;
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_141.cpp,"[3, 0, 0, 0, 2, 0, 4, 1, 2, 0, 5, 0, 0, 0, 2, 152, 0, 0, 4, 5, 0, 0, 1, 11, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 0, 62, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 4, 3, 0, 0, 14, 0, 0, 25, 0, 26, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_141.cpp,45
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,826,-1,"archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_142.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_142.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_142.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_142.cpp,51
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,832,-1,"archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_143.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_143.cpp,"{
	case LZMADEC_HEADER_ERROR:
		archive_set_error(&self->archive->archive,
		    ARCHIVE_ERRNO_MISC,
		    ""Internal error initializing compression library: ""
		    ""invalid header"");
		break;
	case LZMADEC_MEM_ERROR:
		archive_set_error(&self->archive->archive, ENOMEM,
		    ""Internal error initializing compression library: ""
		    ""out of memory"");
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_143.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_143.cpp,57
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,865,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_144.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_144.cpp,"{
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""truncated lzma input"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_144.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_144.cpp,18
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,883,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_145.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_145.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_145.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_145.cpp,36
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,889,-1,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_146.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_146.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			state->eof = 1;
			/* FALL THROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			__archive_read_filter_consume(self->upstream,
			    avail_in - state->stream.avail_in);
			break;
		case LZMADEC_BUF_ERROR: /* Insufficient input data? */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		default:
			/* Return an error. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Lzma decompression failed"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_146.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 3, 1, 1, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_146.cpp,42
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_87.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_87.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_199.cpp,763,744,920,-1,"archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_147.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_147.cpp,"{
	case LZMADEC_OK:
		break;
	default:
		archive_set_error(&(self->archive->archive),
		    ARCHIVE_ERRNO_MISC,
		    ""Failed to clean up %s compressor"",
		    self->archive->archive.compression_name);
		ret = ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_147.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_147.cpp,12
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_216.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_216.cpp,935,989,939,991,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");",acl_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_148.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_148.cpp,"{
	case 01000000:
		/* POSIX.1e ACL */
		break;
	case 03000000:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Solaris NFSv4 ACLs not supported"");
		return (ARCHIVE_WARN);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Malformed Solaris ACL attribute (unsupported type %o)"",
		    (int)type);
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_148.cpp,"[0, 0, 0, 0, 1, 0, 2, 0, 2, 1, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_148.cpp,53
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_218.cpp,1128,1183,1129,1184,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_149.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_149.cpp,"{
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_149.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_149.cpp,23
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_218.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_218.cpp,1128,1183,1133,1191,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry size overflow"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_150.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_150.cpp,"{
	const struct archive_entry_header_ustar	*header;
	char	tartype;
	int     err = ARCHIVE_OK;

	header = (const struct archive_entry_header_ustar *)h;
	if (header->linkname[0])
		archive_strncpy(&(tar->entry_linkpath),
		    header->linkname, sizeof(header->linkname));
	else
		archive_string_empty(&(tar->entry_linkpath));

	/* Parse out the numeric fields (all are octal) */
	archive_entry_set_mode(entry,
		(mode_t)tar_atol(header->mode, sizeof(header->mode)));
	archive_entry_set_uid(entry, tar_atol(header->uid, sizeof(header->uid)));
	archive_entry_set_gid(entry, tar_atol(header->gid, sizeof(header->gid)));
	tar->entry_bytes_remaining = tar_atol(header->size, sizeof(header->size));
	if (tar->entry_bytes_remaining < 0) {
		tar->entry_bytes_remaining = 0;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Tar entry has negative size?"");
		err = ARCHIVE_WARN;
	}
	tar->realsize = tar->entry_bytes_remaining;
	archive_entry_set_size(entry, tar->entry_bytes_remaining);
	archive_entry_set_mtime(entry, tar_atol(header->mtime, sizeof(header->mtime)), 0);

	/* Handle the tar type flag appropriately. */
	tartype = header->typeflag[0];

	switch (tartype) {
	case '1': /* Hard link */
		if (archive_entry_copy_hardlink_l(entry, tar->entry_linkpath.s,
		    archive_strlen(&(tar->entry_linkpath)), tar->sconv) != 0) {
			err = set_conversion_failed_error(a, tar->sconv,
			    ""Linkname"");
			if (err == ARCHIVE_FATAL)
				return (err);
		}
		/*
		 * The following may seem odd, but: Technically, tar
		 * does not store the file type for a ""hard link""
		 * entry, only the fact that it is a hard link.  So, I
		 * leave the type zero normally.  But, pax interchange
		 * format allows hard links to have data, which
		 * implies that the underlying entry is a regular
		 * file.
		 */
		if (archive_entry_size(entry) > 0)
			archive_entry_set_filetype(entry, AE_IFREG);

		/*
		 * A tricky point: Traditionally, tar readers have
		 * ignored the size field when reading hardlink
		 * entries, and some writers put non-zero sizes even
		 * though the body is empty.  POSIX blessed this
		 * convention in the 1988 standard, but broke with
		 * this tradition in 2001 by permitting hardlink
		 * entries to store valid bodies in pax interchange
		 * format, but not in ustar format.  Since there is no
		 * hard and fast way to distinguish pax interchange
		 * from earlier archives (the 'x' and 'g' entries are
		 * optional, after all), we need a heuristic.
		 */
		if (archive_entry_size(entry) == 0) {
			/* If the size is already zero, we're done. */
		}  else if (a->archive.archive_format
		    == ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE) {
			/* Definitely pax extended; must obey hardlink size. */
		} else if (a->archive.archive_format == ARCHIVE_FORMAT_TAR
		    || a->archive.archive_format == ARCHIVE_FORMAT_TAR_GNUTAR)
		{
			/* Old-style or GNU tar: we must ignore the size. */
			archive_entry_set_size(entry, 0);
			tar->entry_bytes_remaining = 0;
		} else if (archive_read_format_tar_bid(a, 50) > 50) {
			/*
			 * We don't know if it's pax: If the bid
			 * function sees a valid ustar header
			 * immediately following, then let's ignore
			 * the hardlink size.
			 */
			archive_entry_set_size(entry, 0);
			tar->entry_bytes_remaining = 0;
		}
		/*
		 * TODO: There are still two cases I'd like to handle:
		 *   = a ustar non-pax archive with a hardlink entry at
		 *     end-of-archive.  (Look for block of nulls following?)
		 *   = a pax archive that has not seen any pax headers
		 *     and has an entry which is a hardlink entry storing
		 *     a body containing an uncompressed tar archive.
		 * The first is worth addressing; I don't see any reliable
		 * way to deal with the second possibility.
		 */
		break;
	case '2': /* Symlink */
		archive_entry_set_filetype(entry, AE_IFLNK);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		if (archive_entry_copy_symlink_l(entry, tar->entry_linkpath.s,
		    archive_strlen(&(tar->entry_linkpath)), tar->sconv) != 0) {
			err = set_conversion_failed_error(a, tar->sconv,
			    ""Linkname"");
			if (err == ARCHIVE_FATAL)
				return (err);
		}
		break;
	case '3': /* Character device */
		archive_entry_set_filetype(entry, AE_IFCHR);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '4': /* Block device */
		archive_entry_set_filetype(entry, AE_IFBLK);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '5': /* Dir */
		archive_entry_set_filetype(entry, AE_IFDIR);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case '6': /* FIFO device */
		archive_entry_set_filetype(entry, AE_IFIFO);
		archive_entry_set_size(entry, 0);
		tar->entry_bytes_remaining = 0;
		break;
	case 'D': /* GNU incremental directory type */
		/*
		 * No special handling is actually required here.
		 * It might be nice someday to preprocess the file list and
		 * provide it to the client, though.
		 */
		archive_entry_set_filetype(entry, AE_IFDIR);
		break;
	case 'M': /* GNU ""Multi-volume"" (remainder of file from last archive)*/
		/*
		 * As far as I can tell, this is just like a regular file
		 * entry, except that the contents should be _appended_ to
		 * the indicated file at the indicated offset.  This may
		 * require some API work to fully support.
		 */
		break;
	case 'N': /* Old GNU ""long filename"" entry. */
		/* The body of this entry is a script for renaming
		 * previously-extracted entries.  Ugh.  It will never
		 * be supported by libarchive. */
		archive_entry_set_filetype(entry, AE_IFREG);
		break;
	case 'S': /* GNU sparse files */
		/*
		 * Sparse files are really just regular files with
		 * sparse information in the extended area.
		 */
		/* FALLTHROUGH */
	default: /* Regular file  and non-standard types */
		/*
		 * Per POSIX: non-recognized types should always be
		 * treated as regular files.
		 */
		archive_entry_set_filetype(entry, AE_IFREG);
		break;
	}
	return (err);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_150.cpp,"[11, 0, 0, 0, 10, 0, 3, 1, 10, 1, 14, 0, 0, 0, 2, 233, 0, 0, 3, 3, 0, 0, 1, 38, 0, 0, 0, 0, 1, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 97, 0, 153, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 12, 11, 1, 0, 44, 0, 0, 39, 3, 86, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_150.cpp,27
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_219.cpp,1803,1944,1819,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_151.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_151.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_151.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_151.cpp,109
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_219.cpp,1803,1944,1824,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_152.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_152.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.access"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.access"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_152.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_152.cpp,114
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_219.cpp,1803,1944,1843,-1,"archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_153.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_153.cpp,"{
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_153.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_153.cpp,133
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_94.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_94.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_219.cpp,1803,1944,1848,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_154.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_154.cpp,"{
				err = r;
				if (err == ARCHIVE_FATAL) {
					archive_set_error(&a->archive, ENOMEM,
					    ""Can't allocate memory for ""
					    ""SCHILY.acl.default"");
					return (err);
				}
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Parse error: SCHILY.acl.default"");
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_154.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_154.cpp,138
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_95.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_222.cpp,255,254,262,260,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");","archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Invalid record version"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_155.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_155.cpp,"{
		/* nawww, I wish they promised backward compatibility
		 * anyhoo, in their infinite wisdom the 28500 guys might
		 * come up with something we can't possibly handle so
		 * best end things here */
		archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_155.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_155.cpp,52
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_95.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_222.cpp,255,254,274,265,,"archive_set_error(
			&a->archive, ARCHIVE_ERRNO_MISC,
			""Unsupported record version: %u.%u"",
			ver / 10000, (ver % 10000) / 100);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_156.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_156.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_156.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_156.cpp,0
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_warc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_95.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_95.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_223.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_223.cpp,285,293,286,294,"archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);","archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, (ver % 10000) / 100);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_157.cpp,"{
		/* stringify this entry's version */
		archive_string_sprintf(&w->sver,
			""WARC/%u.%u"", ver / 10000, ver % 10000);
		/* remember the version */
		w->pver = ver;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_157.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_157.cpp,76
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_224.cpp,1526,1524,1536,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_158.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_158.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_158.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_158.cpp,121
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_224.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_224.cpp,1526,1524,1543,-1,"archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_159.cpp,"{
			case LZMADEC_HEADER_ERROR:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""invalid header"");
				break;
			case LZMADEC_MEM_ERROR:
				archive_set_error(&a->archive,
				    ENOMEM,
				    ""Internal error initializing ""
				    ""compression library: ""
				    ""out of memory"");
				break;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_159.cpp,"[0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_159.cpp,128
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_225.cpp,1685,1653,1700,-1,"archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_160.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_160.cpp,"{
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_160.cpp,"[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_160.cpp,116
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_96.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_96.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_225.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_225.cpp,1685,1653,1710,-1,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_161.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_161.cpp,"{
		case LZMADEC_STREAM_END: /* Found end of stream. */
			switch (lzmadec_end(&(xar->lzstream))) {
			case LZMADEC_OK:
				break;
			default:
				archive_set_error(&(a->archive),
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to clean up lzmadec decompressor"");
				return (ARCHIVE_FATAL);
			}
			xar->lzstream_valid = 0;
			/* FALLTHROUGH */
		case LZMADEC_OK: /* Decompressor made some progress. */
			break;
		default:
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""lzmadec decompression failed(%d)"",
			    r);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_161.cpp,"[0, 0, 0, 0, 2, 0, 2, 1, 3, 2, 2, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_161.cpp,126
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_97.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_226.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_226.cpp,418,418,417,430,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Too-small extra data: Need at least 4 bytes, but only found %d bytes"", (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_162.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_162.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_162.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_162.cpp,0
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_97.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_97.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_97.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_227.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_227.cpp,715,739,720,742,"fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed extra data: Consumed %d bytes of %d bytes"",
		    (int)offset, (int)extra_length);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_163.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_163.cpp,"{
		fprintf(stderr,
		    ""Extra data field contents do not match reported size!\n"");
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_163.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_163.cpp,300
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2413,2598,"archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, errno,
					    ""Could not remove symlink %s"",
					    path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_164.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_164.cpp,"{
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_164.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_164.cpp,49
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2427,2628,"archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot remove intervening ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_165.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_165.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_165.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_165.cpp,63
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2437,2659,"archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);","fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_166.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_166.cpp,"{
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_166.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_166.cpp,73
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2445,2672,"archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);","fsobj_error(a_eno, a_estr, 0,
					    ""Cannot extract through ""
					    ""symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_167.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_167.cpp,"{
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_167.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_167.cpp,81
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2353,2467,,"archive_string_sprintf(a_estr, errstr, path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_168.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_168.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_168.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_168.cpp,0
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2393,2572,,"fsobj_error(a_eno, a_estr, errno,
				    ""Could not stat %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_169.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_169.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_169.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_169.cpp,29
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2393,2581,,"fsobj_error(a_eno, a_estr, errno,
					    ""Could not chdir %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_170.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_170.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_170.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_170.cpp,29
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2393,2650,,"fsobj_error(a_eno, a_estr,
						    errno,
						    ""Could not stat %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_171.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_171.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_171.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_171.cpp,29
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2393,2680,,"fsobj_error(a_eno, a_estr, 0,
				    ""Cannot extract through symlink %s"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_172.cpp,"(pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_172.cpp,"[9, 1, 0, 0, 1, 0, 4, 0, 0, 0, 12, 0, 0, 0, 0, 102, 0, 0, 0, 0, 0, 0, 0, 29, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 10, 9, 1, 0, 9, 0, 0, 16, 2, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_172.cpp,29
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2460,2698,,"fsobj_error(a_eno, a_estr, errno,
			    ""chdir() failure"", """");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_173.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_173.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_173.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_173.cpp,0
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_235.cpp,2351,2457,2463,2727,,"archive_set_error(&a->archive, error_number, ""%s"",
		    error_string.s);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_174.cpp,"/*-
 * Copyright (c) 2003-2010 Tim Kientzle
 * Copyright (c) 2012 Michihiro NAKAJIMA
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer
 *    in this position and unchanged.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include ""archive_platform.h""
__FBSDID(""$FreeBSD$"");

#if !defined(_WIN32) || defined(__CYGWIN__)

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif
#ifdef HAVE_SYS_ACL_H
#include <sys/acl.h>
#endif
#ifdef HAVE_SYS_EXTATTR_H
#include <sys/extattr.h>
#endif
#if defined(HAVE_SYS_XATTR_H)
#include <sys/xattr.h>
#elif defined(HAVE_ATTR_XATTR_H)
#include <attr/xattr.h>
#endif
#ifdef HAVE_SYS_EA_H
#include <sys/ea.h>
#endif
#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_STAT_H
#include <sys/stat.h>
#endif
#ifdef HAVE_SYS_TIME_H
#include <sys/time.h>
#endif
#ifdef HAVE_SYS_UTIME_H
#include <sys/utime.h>
#endif
#ifdef HAVE_COPYFILE_H
#include <copyfile.h>
#endif
#ifdef HAVE_ERRNO_H
#include <errno.h>
#endif
#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#endif
#ifdef HAVE_GRP_H
#include <grp.h>
#endif
#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#ifdef HAVE_LINUX_FS_H
#include <linux/fs.h>	/* for Linux file flags */
#endif
/*
 * Some Linux distributions have both linux/ext2_fs.h and ext2fs/ext2_fs.h.
 * As the include guards don't agree, the order of include is important.
 */
#ifdef HAVE_LINUX_EXT2_FS_H
#include <linux/ext2_fs.h>	/* for Linux file flags */
#endif
#if defined(HAVE_EXT2FS_EXT2_FS_H) && !defined(__CYGWIN__)
#include <ext2fs/ext2_fs.h>	/* Linux file flags, broken on Cygwin */
#endif
#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif
#ifdef HAVE_PWD_H
#include <pwd.h>
#endif
#include <stdio.h>
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
#ifdef HAVE_STRING_H
#include <string.h>
#endif
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#ifdef HAVE_UTIME_H
#include <utime.h>
#endif
#ifdef F_GETTIMES /* Tru64 specific */
#include <sys/fcntl1.h>
#endif

#if __APPLE__
#include <TargetConditionals.h>
#if TARGET_OS_MAC && !TARGET_OS_EMBEDDED && HAVE_QUARANTINE_H
#include <quarantine.h>
#define HAVE_QUARANTINE 1
#endif
#endif

#ifdef HAVE_ZLIB_H
#include <zlib.h>
#endif

/* TODO: Support Mac OS 'quarantine' feature.  This is really just a
 * standard tag to mark files that have been downloaded as ""tainted"".
 * On Mac OS, we should mark the extracted files as tainted if the
 * archive being read was tainted.  Windows has a similar feature; we
 * should investigate ways to support this generically. */

#include ""archive.h""
#include ""archive_acl_private.h""
#include ""archive_string.h""
#include ""archive_endian.h""
#include ""archive_entry.h""
#include ""archive_private.h""
#include ""archive_write_disk_private.h""

#ifndef O_BINARY
#define O_BINARY 0
#endif
#ifndef O_CLOEXEC
#define O_CLOEXEC	0
#endif

struct fixup_entry {
	struct fixup_entry	*next;
	struct archive_acl	 acl;
	mode_t			 mode;
	int64_t			 atime;
	int64_t                  birthtime;
	int64_t			 mtime;
	int64_t			 ctime;
	unsigned long		 atime_nanos;
	unsigned long            birthtime_nanos;
	unsigned long		 mtime_nanos;
	unsigned long		 ctime_nanos;
	unsigned long		 fflags_set;
	size_t			 mac_metadata_size;
	void			*mac_metadata;
	int			 fixup; /* bitmask of what needs fixing */
	char			*name;
};

/*
 * We use a bitmask to track which operations remain to be done for
 * this file.  In particular, this helps us avoid unnecessary
 * operations when it's possible to take care of one step as a
 * side-effect of another.  For example, mkdir() can specify the mode
 * for the newly-created object but symlink() cannot.  This means we
 * can skip chmod() if mkdir() succeeded, but we must explicitly
 * chmod() if we're trying to create a directory that already exists
 * (mkdir() failed) or if we're restoring a symlink.  Similarly, we
 * need to verify UID/GID before trying to restore SUID/SGID bits;
 * that verification can occur explicitly through a stat() call or
 * implicitly because of a successful chown() call.
 */
#define	TODO_MODE_FORCE		0x40000000
#define	TODO_MODE_BASE		0x20000000
#define	TODO_SUID		0x10000000
#define	TODO_SUID_CHECK		0x08000000
#define	TODO_SGID		0x04000000
#define	TODO_SGID_CHECK		0x02000000
#define	TODO_APPLEDOUBLE	0x01000000
#define	TODO_MODE		(TODO_MODE_BASE|TODO_SUID|TODO_SGID)
#define	TODO_TIMES		ARCHIVE_EXTRACT_TIME
#define	TODO_OWNER		ARCHIVE_EXTRACT_OWNER
#define	TODO_FFLAGS		ARCHIVE_EXTRACT_FFLAGS
#define	TODO_ACLS		ARCHIVE_EXTRACT_ACL
#define	TODO_XATTR		ARCHIVE_EXTRACT_XATTR
#define	TODO_MAC_METADATA	ARCHIVE_EXTRACT_MAC_METADATA
#define	TODO_HFS_COMPRESSION	ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED

struct archive_write_disk {
	struct archive	archive;

	mode_t			 user_umask;
	struct fixup_entry	*fixup_list;
	struct fixup_entry	*current_fixup;
	int64_t			 user_uid;
	int			 skip_file_set;
	int64_t			 skip_file_dev;
	int64_t			 skip_file_ino;
	time_t			 start_time;

	int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid);
	void  (*cleanup_gid)(void *private);
	void			*lookup_gid_data;
	int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid);
	void  (*cleanup_uid)(void *private);
	void			*lookup_uid_data;

	/*
	 * Full path of last file to satisfy symlink checks.
	 */
	struct archive_string	path_safe;

	/*
	 * Cached stat data from disk for the current entry.
	 * If this is valid, pst points to st.  Otherwise,
	 * pst is null.
	 */
	struct stat		 st;
	struct stat		*pst;

	/* Information about the object being restored right now. */
	struct archive_entry	*entry; /* Entry being extracted. */
	char			*name; /* Name of entry, possibly edited. */
	struct archive_string	 _name_data; /* backing store for 'name' */
	/* Tasks remaining for this object. */
	int			 todo;
	/* Tasks deferred until end-of-archive. */
	int			 deferred;
	/* Options requested by the client. */
	int			 flags;
	/* Handle for the file we're restoring. */
	int			 fd;
	/* Current offset for writing data to the file. */
	int64_t			 offset;
	/* Last offset actually written to disk. */
	int64_t			 fd_offset;
	/* Total bytes actually written to files. */
	int64_t			 total_bytes_written;
	/* Maximum size of file, -1 if unknown. */
	int64_t			 filesize;
	/* Dir we were in before this restore; only for deep paths. */
	int			 restore_pwd;
	/* Mode we should use for this entry; affected by _PERM and umask. */
	mode_t			 mode;
	/* UID/GID to use in restoring this entry. */
	int64_t			 uid;
	int64_t			 gid;
	/*
	 * HFS+ Compression.
	 */
	/* Xattr ""com.apple.decmpfs"". */
	uint32_t		 decmpfs_attr_size;
	unsigned char		*decmpfs_header_p;
	/* ResourceFork set options used for fsetxattr. */
	int			 rsrc_xattr_options;
	/* Xattr ""com.apple.ResourceFork"". */
	unsigned char		*resource_fork;
	size_t			 resource_fork_allocated_size;
	unsigned int		 decmpfs_block_count;
	uint32_t		*decmpfs_block_info;
	/* Buffer for compressed data. */
	unsigned char		*compressed_buffer;
	size_t			 compressed_buffer_size;
	size_t			 compressed_buffer_remaining;
	/* The offset of the ResourceFork where compressed data will
	 * be placed. */
	uint32_t		 compressed_rsrc_position;
	uint32_t		 compressed_rsrc_position_v;
	/* Buffer for uncompressed data. */
	char			*uncompressed_buffer;
	size_t			 block_remaining_bytes;
	size_t			 file_remaining_bytes;
#ifdef HAVE_ZLIB_H
	z_stream		 stream;
	int			 stream_valid;
	int			 decmpfs_compression_level;
#endif
};

/*
 * Default mode for dirs created automatically (will be modified by umask).
 * Note that POSIX specifies 0777 for implicitly-created dirs, ""modified
 * by the process' file creation mask.""
 */
#define	DEFAULT_DIR_MODE 0777
/*
 * Dir modes are restored in two steps:  During the extraction, the permissions
 * in the archive are modified to match the following limits.  During
 * the post-extract fixup pass, the permissions from the archive are
 * applied.
 */
#define	MINIMUM_DIR_MODE 0700
#define	MAXIMUM_DIR_MODE 0775

/*
 * Maxinum uncompressed size of a decmpfs block.
 */
#define MAX_DECMPFS_BLOCK_SIZE	(64 * 1024)
/*
 * HFS+ compression type.
 */
#define CMP_XATTR		3/* Compressed data in xattr. */
#define CMP_RESOURCE_FORK	4/* Compressed data in resource fork. */
/*
 * HFS+ compression resource fork.
 */
#define RSRC_H_SIZE	260	/* Base size of Resource fork header. */
#define RSRC_F_SIZE	50	/* Size of Resource fork footer. */
/* Size to write compressed data to resource fork. */
#define COMPRESSED_W_SIZE	(64 * 1024)
/* decmpfs difinitions. */
#define MAX_DECMPFS_XATTR_SIZE		3802
#ifndef DECMPFS_XATTR_NAME
#define DECMPFS_XATTR_NAME		""com.apple.decmpfs""
#endif
#define DECMPFS_MAGIC			0x636d7066
#define DECMPFS_COMPRESSION_MAGIC	0
#define DECMPFS_COMPRESSION_TYPE	4
#define DECMPFS_UNCOMPRESSED_SIZE	8
#define DECMPFS_HEADER_SIZE		16

#define HFS_BLOCKS(s)	((s) >> 12)

static int	check_symlinks(struct archive_write_disk *);
static int	create_filesystem_object(struct archive_write_disk *);
static struct fixup_entry *current_fixup(struct archive_write_disk *, const char *pathname);
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
static void	edit_deep_directories(struct archive_write_disk *ad);
#endif
static int	cleanup_pathname(struct archive_write_disk *);
static int	create_dir(struct archive_write_disk *, char *);
static int	create_parent_dir(struct archive_write_disk *, char *);
static ssize_t	hfs_write_data_block(struct archive_write_disk *,
		    const char *, size_t);
static int	fixup_appledouble(struct archive_write_disk *, const char *);
static int	older(struct stat *, struct archive_entry *);
static int	restore_entry(struct archive_write_disk *);
static int	set_mac_metadata(struct archive_write_disk *, const char *,
				 const void *, size_t);
static int	set_xattrs(struct archive_write_disk *);
static int	clear_nochange_fflags(struct archive_write_disk *);
static int	set_fflags(struct archive_write_disk *);
static int	set_fflags_platform(struct archive_write_disk *, int fd,
		    const char *name, mode_t mode,
		    unsigned long fflags_set, unsigned long fflags_clear);
static int	set_ownership(struct archive_write_disk *);
static int	set_mode(struct archive_write_disk *, int mode);
static int	set_time(int, int, const char *, time_t, long, time_t, long);
static int	set_times(struct archive_write_disk *, int, int, const char *,
		    time_t, long, time_t, long, time_t, long, time_t, long);
static int	set_times_from_entry(struct archive_write_disk *);
static struct fixup_entry *sort_dir_list(struct fixup_entry *p);
static ssize_t	write_data_block(struct archive_write_disk *,
		    const char *, size_t);

static struct archive_vtable *archive_write_disk_vtable(void);

static int	_archive_write_disk_close(struct archive *);
static int	_archive_write_disk_free(struct archive *);
static int	_archive_write_disk_header(struct archive *, struct archive_entry *);
static int64_t	_archive_write_disk_filter_bytes(struct archive *, int);
static int	_archive_write_disk_finish_entry(struct archive *);
static ssize_t	_archive_write_disk_data(struct archive *, const void *, size_t);
static ssize_t	_archive_write_disk_data_block(struct archive *, const void *, size_t, int64_t);

static int
lazy_stat(struct archive_write_disk *a)
{
	if (a->pst != NULL) {
		/* Already have stat() data available. */
		return (ARCHIVE_OK);
	}
#ifdef HAVE_FSTAT
	if (a->fd >= 0 && fstat(a->fd, &a->st) == 0) {
		a->pst = &a->st;
		return (ARCHIVE_OK);
	}
#endif
	/*
	 * XXX At this point, symlinks should not be hit, otherwise
	 * XXX a race occurred.  Do we want to check explicitly for that?
	 */
	if (lstat(a->name, &a->st) == 0) {
		a->pst = &a->st;
		return (ARCHIVE_OK);
	}
	archive_set_error(&a->archive, errno, ""Couldn't stat file"");
	return (ARCHIVE_WARN);
}

static struct archive_vtable *
archive_write_disk_vtable(void)
{
	static struct archive_vtable av;
	static int inited = 0;

	if (!inited) {
		av.archive_close = _archive_write_disk_close;
		av.archive_filter_bytes = _archive_write_disk_filter_bytes;
		av.archive_free = _archive_write_disk_free;
		av.archive_write_header = _archive_write_disk_header;
		av.archive_write_finish_entry
		    = _archive_write_disk_finish_entry;
		av.archive_write_data = _archive_write_disk_data;
		av.archive_write_data_block = _archive_write_disk_data_block;
		inited = 1;
	}
	return (&av);
}

static int64_t
_archive_write_disk_filter_bytes(struct archive *_a, int n)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	(void)n; /* UNUSED */
	if (n == -1 || n == 0)
		return (a->total_bytes_written);
	return (-1);
}


int
archive_write_disk_set_options(struct archive *_a, int flags)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;

	a->flags = flags;
	return (ARCHIVE_OK);
}


/*
 * Extract this entry to disk.
 *
 * TODO: Validate hardlinks.  According to the standards, we're
 * supposed to check each extracted hardlink and squawk if it refers
 * to a file that we didn't restore.  I'm not entirely convinced this
 * is a good idea, but more importantly: Is there any way to validate
 * hardlinks without keeping a complete list of filenames from the
 * entire archive?? Ugh.
 *
 */
static int
_archive_write_disk_header(struct archive *_a, struct archive_entry *entry)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	struct fixup_entry *fe;
	int ret, r;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_disk_header"");
	archive_clear_error(&a->archive);
	if (a->archive.state & ARCHIVE_STATE_DATA) {
		r = _archive_write_disk_finish_entry(&a->archive);
		if (r == ARCHIVE_FATAL)
			return (r);
	}

	/* Set up for this particular entry. */
	a->pst = NULL;
	a->current_fixup = NULL;
	a->deferred = 0;
	if (a->entry) {
		archive_entry_free(a->entry);
		a->entry = NULL;
	}
	a->entry = archive_entry_clone(entry);
	a->fd = -1;
	a->fd_offset = 0;
	a->offset = 0;
	a->restore_pwd = -1;
	a->uid = a->user_uid;
	a->mode = archive_entry_mode(a->entry);
	if (archive_entry_size_is_set(a->entry))
		a->filesize = archive_entry_size(a->entry);
	else
		a->filesize = -1;
	archive_strcpy(&(a->_name_data), archive_entry_pathname(a->entry));
	a->name = a->_name_data.s;
	archive_clear_error(&a->archive);

	/*
	 * Clean up the requested path.  This is necessary for correct
	 * dir restores; the dir restore logic otherwise gets messed
	 * up by nonsense like ""dir/."".
	 */
	ret = cleanup_pathname(a);
	if (ret != ARCHIVE_OK)
		return (ret);

	/*
	 * Query the umask so we get predictable mode settings.
	 * This gets done on every call to _write_header in case the
	 * user edits their umask during the extraction for some
	 * reason.
	 */
	umask(a->user_umask = umask(0));

	/* Figure out what we need to do for this entry. */
	a->todo = TODO_MODE_BASE;
	if (a->flags & ARCHIVE_EXTRACT_PERM) {
		a->todo |= TODO_MODE_FORCE; /* Be pushy about permissions. */
		/*
		 * SGID requires an extra ""check"" step because we
		 * cannot easily predict the GID that the system will
		 * assign.  (Different systems assign GIDs to files
		 * based on a variety of criteria, including process
		 * credentials and the gid of the enclosing
		 * directory.)  We can only restore the SGID bit if
		 * the file has the right GID, and we only know the
		 * GID if we either set it (see set_ownership) or if
		 * we've actually called stat() on the file after it
		 * was restored.  Since there are several places at
		 * which we might verify the GID, we need a TODO bit
		 * to keep track.
		 */
		if (a->mode & S_ISGID)
			a->todo |= TODO_SGID | TODO_SGID_CHECK;
		/*
		 * Verifying the SUID is simpler, but can still be
		 * done in multiple ways, hence the separate ""check"" bit.
		 */
		if (a->mode & S_ISUID)
			a->todo |= TODO_SUID | TODO_SUID_CHECK;
	} else {
		/*
		 * User didn't request full permissions, so don't
		 * restore SUID, SGID bits and obey umask.
		 */
		a->mode &= ~S_ISUID;
		a->mode &= ~S_ISGID;
		a->mode &= ~S_ISVTX;
		a->mode &= ~a->user_umask;
	}
	if (a->flags & ARCHIVE_EXTRACT_OWNER)
		a->todo |= TODO_OWNER;
	if (a->flags & ARCHIVE_EXTRACT_TIME)
		a->todo |= TODO_TIMES;
	if (a->flags & ARCHIVE_EXTRACT_ACL) {
		if (archive_entry_filetype(a->entry) == AE_IFDIR)
			a->deferred |= TODO_ACLS;
		else
			a->todo |= TODO_ACLS;
	}
	if (a->flags & ARCHIVE_EXTRACT_MAC_METADATA) {
		if (archive_entry_filetype(a->entry) == AE_IFDIR)
			a->deferred |= TODO_MAC_METADATA;
		else
			a->todo |= TODO_MAC_METADATA;
	}
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	if ((a->flags & ARCHIVE_EXTRACT_NO_HFS_COMPRESSION) == 0) {
		unsigned long set, clear;
		archive_entry_fflags(a->entry, &set, &clear);
		if ((set & ~clear) & UF_COMPRESSED) {
			a->todo |= TODO_HFS_COMPRESSION;
			a->decmpfs_block_count = (unsigned)-1;
		}
	}
	if ((a->flags & ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED) != 0 &&
	    (a->mode & AE_IFMT) == AE_IFREG && a->filesize > 0) {
		a->todo |= TODO_HFS_COMPRESSION;
		a->decmpfs_block_count = (unsigned)-1;
	}
	{
		const char *p;

		/* Check if the current file name is a type of the
		 * resource fork file. */
		p = strrchr(a->name, '/');
		if (p == NULL)
			p = a->name;
		else
			p++;
		if (p[0] == '.' && p[1] == '_') {
			/* Do not compress ""._XXX"" files. */
			a->todo &= ~TODO_HFS_COMPRESSION;
			if (a->filesize > 0)
				a->todo |= TODO_APPLEDOUBLE;
		}
	}
#endif

	if (a->flags & ARCHIVE_EXTRACT_XATTR)
		a->todo |= TODO_XATTR;
	if (a->flags & ARCHIVE_EXTRACT_FFLAGS)
		a->todo |= TODO_FFLAGS;
	if (a->flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS) {
		ret = check_symlinks(a);
		if (ret != ARCHIVE_OK)
			return (ret);
	}
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
	/* If path exceeds PATH_MAX, shorten the path. */
	edit_deep_directories(a);
#endif

	ret = restore_entry(a);

#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	/*
	 * Check if the filesystem the file is restoring on supports
	 * HFS+ Compression. If not, cancel HFS+ Compression.
	 */
	if (a->todo | TODO_HFS_COMPRESSION) {
		/*
		 * NOTE: UF_COMPRESSED is ignored even if the filesystem
		 * supports HFS+ Compression because the file should
		 * have at least an extended attriute ""com.apple.decmpfs""
		 * before the flag is set to indicate that the file have
		 * been compressed. If hte filesystem does not support
		 * HFS+ Compression the system call will fail.
		 */
		if (a->fd < 0 || fchflags(a->fd, UF_COMPRESSED) != 0)
			a->todo &= ~TODO_HFS_COMPRESSION;
	}
#endif

	/*
	 * TODO: There are rumours that some extended attributes must
	 * be restored before file data is written.  If this is true,
	 * then we either need to write all extended attributes both
	 * before and after restoring the data, or find some rule for
	 * determining which must go first and which last.  Due to the
	 * many ways people are using xattrs, this may prove to be an
	 * intractable problem.
	 */

#ifdef HAVE_FCHDIR
	/* If we changed directory above, restore it here. */
	if (a->restore_pwd >= 0) {
		r = fchdir(a->restore_pwd);
		if (r != 0) {
			archive_set_error(&a->archive, errno, ""chdir() failure"");
			ret = ARCHIVE_FATAL;
		}
		close(a->restore_pwd);
		a->restore_pwd = -1;
	}
#endif

	/*
	 * Fixup uses the unedited pathname from archive_entry_pathname(),
	 * because it is relative to the base dir and the edited path
	 * might be relative to some intermediate dir as a result of the
	 * deep restore logic.
	 */
	if (a->deferred & TODO_MODE) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_MODE_BASE;
		fe->mode = a->mode;
	}

	if ((a->deferred & TODO_TIMES)
		&& (archive_entry_mtime_is_set(entry)
		    || archive_entry_atime_is_set(entry))) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->mode = a->mode;
		fe->fixup |= TODO_TIMES;
		if (archive_entry_atime_is_set(entry)) {
			fe->atime = archive_entry_atime(entry);
			fe->atime_nanos = archive_entry_atime_nsec(entry);
		} else {
			/* If atime is unset, use start time. */
			fe->atime = a->start_time;
			fe->atime_nanos = 0;
		}
		if (archive_entry_mtime_is_set(entry)) {
			fe->mtime = archive_entry_mtime(entry);
			fe->mtime_nanos = archive_entry_mtime_nsec(entry);
		} else {
			/* If mtime is unset, use start time. */
			fe->mtime = a->start_time;
			fe->mtime_nanos = 0;
		}
		if (archive_entry_birthtime_is_set(entry)) {
			fe->birthtime = archive_entry_birthtime(entry);
			fe->birthtime_nanos = archive_entry_birthtime_nsec(entry);
		} else {
			/* If birthtime is unset, use mtime. */
			fe->birthtime = fe->mtime;
			fe->birthtime_nanos = fe->mtime_nanos;
		}
	}

	if (a->deferred & TODO_ACLS) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_ACLS;
		archive_acl_copy(&fe->acl, archive_entry_acl(entry));
	}

	if (a->deferred & TODO_MAC_METADATA) {
		const void *metadata;
		size_t metadata_size;
		metadata = archive_entry_mac_metadata(a->entry, &metadata_size);
		if (metadata != NULL && metadata_size > 0) {
			fe = current_fixup(a, archive_entry_pathname(entry));
			if (fe == NULL)
				return (ARCHIVE_FATAL);
			fe->mac_metadata = malloc(metadata_size);
			if (fe->mac_metadata != NULL) {
				memcpy(fe->mac_metadata, metadata, metadata_size);
				fe->mac_metadata_size = metadata_size;
				fe->fixup |= TODO_MAC_METADATA;
			}
		}
	}

	if (a->deferred & TODO_FFLAGS) {
		fe = current_fixup(a, archive_entry_pathname(entry));
		if (fe == NULL)
			return (ARCHIVE_FATAL);
		fe->fixup |= TODO_FFLAGS;
		/* TODO: Complete this.. defer fflags from below. */
	}

	/* We've created the object and are ready to pour data into it. */
	if (ret >= ARCHIVE_WARN)
		a->archive.state = ARCHIVE_STATE_DATA;
	/*
	 * If it's not open, tell our client not to try writing.
	 * In particular, dirs, links, etc, don't get written to.
	 */
	if (a->fd < 0) {
		archive_entry_set_size(entry, 0);
		a->filesize = 0;
	}

	return (ret);
}

int
archive_write_disk_set_skip_file(struct archive *_a, int64_t d, int64_t i)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_skip_file"");
	a->skip_file_set = 1;
	a->skip_file_dev = d;
	a->skip_file_ino = i;
	return (ARCHIVE_OK);
}

static ssize_t
write_data_block(struct archive_write_disk *a, const char *buff, size_t size)
{
	uint64_t start_size = size;
	ssize_t bytes_written = 0;
	ssize_t block_size = 0, bytes_to_write;

	if (size == 0)
		return (ARCHIVE_OK);

	if (a->filesize == 0 || a->fd < 0) {
		archive_set_error(&a->archive, 0,
		    ""Attempt to write to an empty file"");
		return (ARCHIVE_WARN);
	}

	if (a->flags & ARCHIVE_EXTRACT_SPARSE) {
#if HAVE_STRUCT_STAT_ST_BLKSIZE
		int r;
		if ((r = lazy_stat(a)) != ARCHIVE_OK)
			return (r);
		block_size = a->pst->st_blksize;
#else
		/* XXX TODO XXX Is there a more appropriate choice here ? */
		/* This needn't match the filesystem allocation size. */
		block_size = 16*1024;
#endif
	}

	/* If this write would run beyond the file size, truncate it. */
	if (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)
		start_size = size = (size_t)(a->filesize - a->offset);

	/* Write the data. */
	while (size > 0) {
		if (block_size == 0) {
			bytes_to_write = size;
		} else {
			/* We're sparsifying the file. */
			const char *p, *end;
			int64_t block_end;

			/* Skip leading zero bytes. */
			for (p = buff, end = buff + size; p < end; ++p) {
				if (*p != '\0')
					break;
			}
			a->offset += p - buff;
			size -= p - buff;
			buff = p;
			if (size == 0)
				break;

			/* Calculate next block boundary after offset. */
			block_end
			    = (a->offset / block_size + 1) * block_size;

			/* If the adjusted write would cross block boundary,
			 * truncate it to the block boundary. */
			bytes_to_write = size;
			if (a->offset + bytes_to_write > block_end)
				bytes_to_write = block_end - a->offset;
		}
		/* Seek if necessary to the specified offset. */
		if (a->offset != a->fd_offset) {
			if (lseek(a->fd, a->offset, SEEK_SET) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Seek failed"");
				return (ARCHIVE_FATAL);
			}
			a->fd_offset = a->offset;
		}
		bytes_written = write(a->fd, buff, bytes_to_write);
		if (bytes_written < 0) {
			archive_set_error(&a->archive, errno, ""Write failed"");
			return (ARCHIVE_WARN);
		}
		buff += bytes_written;
		size -= bytes_written;
		a->total_bytes_written += bytes_written;
		a->offset += bytes_written;
		a->fd_offset = a->offset;
	}
	return (start_size - size);
}

#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\
	&& defined(HAVE_ZLIB_H)

/*
 * Set UF_COMPRESSED file flag.
 * This have to be called after hfs_write_decmpfs() because if the
 * file does not have ""com.apple.decmpfs"" xattr the flag is ignored.
 */
static int
hfs_set_compressed_fflag(struct archive_write_disk *a)
{
	int r;

	if ((r = lazy_stat(a)) != ARCHIVE_OK)
		return (r);

	a->st.st_flags |= UF_COMPRESSED;
	if (fchflags(a->fd, a->st.st_flags) != 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to set UF_COMPRESSED file flag"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

/*
 * HFS+ Compression decmpfs
 *
 *     +------------------------------+ +0
 *     |      Magic(LE 4 bytes)       |
 *     +------------------------------+
 *     |      Type(LE 4 bytes)        |
 *     +------------------------------+
 *     | Uncompressed size(LE 8 bytes)|
 *     +------------------------------+ +16
 *     |                              |
 *     |       Compressed data        |
 *     |  (Placed only if Type == 3)  |
 *     |                              |
 *     +------------------------------+  +3802 = MAX_DECMPFS_XATTR_SIZE
 *
 *  Type is 3: decmpfs has compressed data.
 *  Type is 4: Resource Fork has compressed data.
 */
/*
 * Write ""com.apple.decmpfs""
 */
static int
hfs_write_decmpfs(struct archive_write_disk *a)
{
	int r;
	uint32_t compression_type;

	r = fsetxattr(a->fd, DECMPFS_XATTR_NAME, a->decmpfs_header_p,
	    a->decmpfs_attr_size, 0, 0);
	if (r < 0) {
		archive_set_error(&a->archive, errno,
		    ""Cannot restore xattr:%s"", DECMPFS_XATTR_NAME);
		compression_type = archive_le32dec(
		    &a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE]);
		if (compression_type == CMP_RESOURCE_FORK)
			fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME,
			    XATTR_SHOWCOMPRESSION);
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

/*
 * HFS+ Compression Resource Fork
 *
 *     +-----------------------------+
 *     |     Header(260 bytes)       |
 *     +-----------------------------+
 *     |   Block count(LE 4 bytes)   |
 *     +-----------------------------+  --+
 * +-- |     Offset (LE 4 bytes)     |    |
 * |   | [distance from Block count] |    | Block 0
 * |   +-----------------------------+    |
 * |   | Compressed size(LE 4 bytes) |    |
 * |   +-----------------------------+  --+
 * |   |                             |
 * |   |      ..................     |
 * |   |                             |
 * |   +-----------------------------+  --+
 * |   |     Offset (LE 4 bytes)     |    |
 * |   +-----------------------------+    | Block (Block count -1)
 * |   | Compressed size(LE 4 bytes) |    |
 * +-> +-----------------------------+  --+
 *     |   Compressed data(n bytes)  |  Block 0
 *     +-----------------------------+
 *     |                             |
 *     |      ..................     |
 *     |                             |
 *     +-----------------------------+
 *     |   Compressed data(n bytes)  |  Block (Block count -1)
 *     +-----------------------------+
 *     |      Footer(50 bytes)       |
 *     +-----------------------------+
 *
 */
/*
 * Write the header of ""com.apple.ResourceFork""
 */
static int
hfs_write_resource_fork(struct archive_write_disk *a, unsigned char *buff,
    size_t bytes, uint32_t position)
{
	int ret;

	ret = fsetxattr(a->fd, XATTR_RESOURCEFORK_NAME, buff, bytes,
	    position, a->rsrc_xattr_options);
	if (ret < 0) {
		archive_set_error(&a->archive, errno,
		    ""Cannot restore xattr: %s at %u pos %u bytes"",
		    XATTR_RESOURCEFORK_NAME,
		    (unsigned)position,
		    (unsigned)bytes);
		return (ARCHIVE_WARN);
	}
	a->rsrc_xattr_options &= ~XATTR_CREATE;
	return (ARCHIVE_OK);
}

static int
hfs_write_compressed_data(struct archive_write_disk *a, size_t bytes_compressed)
{
	int ret;

	ret = hfs_write_resource_fork(a, a->compressed_buffer,
	    bytes_compressed, a->compressed_rsrc_position);
	if (ret == ARCHIVE_OK)
		a->compressed_rsrc_position += bytes_compressed;
	return (ret);
}

static int
hfs_write_resource_fork_header(struct archive_write_disk *a)
{
	unsigned char *buff;
	uint32_t rsrc_bytes;
	uint32_t rsrc_header_bytes;

	/*
	 * Write resource fork header + block info.
	 */
	buff = a->resource_fork;
	rsrc_bytes = a->compressed_rsrc_position - RSRC_F_SIZE;
	rsrc_header_bytes =
		RSRC_H_SIZE +		/* Header base size. */
		4 +			/* Block count. */
		(a->decmpfs_block_count * 8);/* Block info */
	archive_be32enc(buff, 0x100);
	archive_be32enc(buff + 4, rsrc_bytes);
	archive_be32enc(buff + 8, rsrc_bytes - 256);
	archive_be32enc(buff + 12, 0x32);
	memset(buff + 16, 0, 240);
	archive_be32enc(buff + 256, rsrc_bytes - 260);
	return hfs_write_resource_fork(a, buff, rsrc_header_bytes, 0);
}

static size_t
hfs_set_resource_fork_footer(unsigned char *buff, size_t buff_size)
{
	static const char rsrc_footer[RSRC_F_SIZE] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 'c',  'm',
		'p', 'f',   0x00, 0x00, 0x00, 0x0a, 0x00, 0x01,
		0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00
	};
	if (buff_size < sizeof(rsrc_footer))
		return (0);
	memcpy(buff, rsrc_footer, sizeof(rsrc_footer));
	return (sizeof(rsrc_footer));
}

static int
hfs_reset_compressor(struct archive_write_disk *a)
{
	int ret;

	if (a->stream_valid)
		ret = deflateReset(&a->stream);
	else
		ret = deflateInit(&a->stream, a->decmpfs_compression_level);

	if (ret != Z_OK) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Failed to initialize compressor"");
		return (ARCHIVE_FATAL);
	} else
		a->stream_valid = 1;

	return (ARCHIVE_OK);
}

static int
hfs_decompress(struct archive_write_disk *a)
{
	uint32_t *block_info;
	unsigned int block_count;
	uint32_t data_pos, data_size;
	ssize_t r;
	ssize_t bytes_written, bytes_to_write;
	unsigned char *b;

	block_info = (uint32_t *)(a->resource_fork + RSRC_H_SIZE);
	block_count = archive_le32dec(block_info++);
	while (block_count--) {
		data_pos = RSRC_H_SIZE + archive_le32dec(block_info++);
		data_size = archive_le32dec(block_info++);
		r = fgetxattr(a->fd, XATTR_RESOURCEFORK_NAME,
		    a->compressed_buffer, data_size, data_pos, 0);
		if (r != data_size)  {
			archive_set_error(&a->archive,
			    (r < 0)?errno:ARCHIVE_ERRNO_MISC,
			    ""Failed to read resource fork"");
			return (ARCHIVE_WARN);
		}
		if (a->compressed_buffer[0] == 0xff) {
			bytes_to_write = data_size -1;
			b = a->compressed_buffer + 1;
		} else {
			uLong dest_len = MAX_DECMPFS_BLOCK_SIZE;
			int zr;

			zr = uncompress((Bytef *)a->uncompressed_buffer,
			    &dest_len, a->compressed_buffer, data_size);
			if (zr != Z_OK) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Failed to decompress resource fork"");
				return (ARCHIVE_WARN);
			}
			bytes_to_write = dest_len;
			b = (unsigned char *)a->uncompressed_buffer;
		}
		do {
			bytes_written = write(a->fd, b, bytes_to_write);
			if (bytes_written < 0) {
				archive_set_error(&a->archive, errno,
				    ""Write failed"");
				return (ARCHIVE_WARN);
			}
			bytes_to_write -= bytes_written;
			b += bytes_written;
		} while (bytes_to_write > 0);
	}
	r = fremovexattr(a->fd, XATTR_RESOURCEFORK_NAME, 0);
	if (r == -1)  {
		archive_set_error(&a->archive, errno,
		    ""Failed to remove resource fork"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

static int
hfs_drive_compressor(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	unsigned char *buffer_compressed;
	size_t bytes_compressed;
	size_t bytes_used;
	int ret;

	ret = hfs_reset_compressor(a);
	if (ret != ARCHIVE_OK)
		return (ret);

	if (a->compressed_buffer == NULL) {
		size_t block_size;

		block_size = COMPRESSED_W_SIZE + RSRC_F_SIZE +
		    + compressBound(MAX_DECMPFS_BLOCK_SIZE);
		a->compressed_buffer = malloc(block_size);
		if (a->compressed_buffer == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Resource Fork"");
			return (ARCHIVE_FATAL);
		}
		a->compressed_buffer_size = block_size;
		a->compressed_buffer_remaining = block_size;
	}

	buffer_compressed = a->compressed_buffer +
	    a->compressed_buffer_size - a->compressed_buffer_remaining;
	a->stream.next_in = (Bytef *)(uintptr_t)(const void *)buff;
	a->stream.avail_in = size;
	a->stream.next_out = buffer_compressed;
	a->stream.avail_out = a->compressed_buffer_remaining;
	do {
		ret = deflate(&a->stream, Z_FINISH);
		switch (ret) {
		case Z_OK:
		case Z_STREAM_END:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Failed to compress data"");
			return (ARCHIVE_FAILED);
		}
	} while (ret == Z_OK);
	bytes_compressed = a->compressed_buffer_remaining - a->stream.avail_out;

	/*
	 * If the compressed size is larger than the original size,
	 * throw away compressed data, use uncompressed data instead.
	 */
	if (bytes_compressed > size) {
		buffer_compressed[0] = 0xFF;/* uncompressed marker. */
		memcpy(buffer_compressed + 1, buff, size);
		bytes_compressed = size + 1;
	}
	a->compressed_buffer_remaining -= bytes_compressed;

	/*
	 * If the compressed size is smaller than MAX_DECMPFS_XATTR_SIZE
	 * and the block count in the file is only one, store compressed
	 * data to decmpfs xattr instead of the resource fork.
	 */
	if (a->decmpfs_block_count == 1 &&
	    (a->decmpfs_attr_size + bytes_compressed)
	      <= MAX_DECMPFS_XATTR_SIZE) {
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],
		    CMP_XATTR);
		memcpy(a->decmpfs_header_p + DECMPFS_HEADER_SIZE,
		    buffer_compressed, bytes_compressed);
		a->decmpfs_attr_size += bytes_compressed;
		a->compressed_buffer_remaining = a->compressed_buffer_size;
		/*
		 * Finish HFS+ Compression.
		 * - Write the decmpfs xattr.
		 * - Set the UF_COMPRESSED file flag.
		 */
		ret = hfs_write_decmpfs(a);
		if (ret == ARCHIVE_OK)
			ret = hfs_set_compressed_fflag(a);
		return (ret);
	}

	/* Update block info. */
	archive_le32enc(a->decmpfs_block_info++,
	    a->compressed_rsrc_position_v - RSRC_H_SIZE);
	archive_le32enc(a->decmpfs_block_info++, bytes_compressed);
	a->compressed_rsrc_position_v += bytes_compressed;

	/*
	 * Write the compressed data to the resource fork.
	 */
	bytes_used = a->compressed_buffer_size - a->compressed_buffer_remaining;
	while (bytes_used >= COMPRESSED_W_SIZE) {
		ret = hfs_write_compressed_data(a, COMPRESSED_W_SIZE);
		if (ret != ARCHIVE_OK)
			return (ret);
		bytes_used -= COMPRESSED_W_SIZE;
		if (bytes_used > COMPRESSED_W_SIZE)
			memmove(a->compressed_buffer,
			    a->compressed_buffer + COMPRESSED_W_SIZE,
			    bytes_used);
		else
			memcpy(a->compressed_buffer,
			    a->compressed_buffer + COMPRESSED_W_SIZE,
			    bytes_used);
	}
	a->compressed_buffer_remaining = a->compressed_buffer_size - bytes_used;

	/*
	 * If the current block is the last block, write the remaining
	 * compressed data and the resource fork footer.
	 */
	if (a->file_remaining_bytes == 0) {
		size_t rsrc_size;
		int64_t bk;

		/* Append the resource footer. */
		rsrc_size = hfs_set_resource_fork_footer(
		    a->compressed_buffer + bytes_used,
		    a->compressed_buffer_remaining);
		ret = hfs_write_compressed_data(a, bytes_used + rsrc_size);
		a->compressed_buffer_remaining = a->compressed_buffer_size;

		/* If the compressed size is not enouph smaller than
		 * the uncompressed size. cancel HFS+ compression.
		 * TODO: study a behavior of ditto utility and improve
		 * the condition to fall back into no HFS+ compression. */
		bk = HFS_BLOCKS(a->compressed_rsrc_position);
		bk += bk >> 7;
		if (bk > HFS_BLOCKS(a->filesize))
			return hfs_decompress(a);
		/*
		 * Write the resourcefork header.
		 */
		if (ret == ARCHIVE_OK)
			ret = hfs_write_resource_fork_header(a);
		/*
		 * Finish HFS+ Compression.
		 * - Write the decmpfs xattr.
		 * - Set the UF_COMPRESSED file flag.
		 */
		if (ret == ARCHIVE_OK)
			ret = hfs_write_decmpfs(a);
		if (ret == ARCHIVE_OK)
			ret = hfs_set_compressed_fflag(a);
	}
	return (ret);
}

static ssize_t
hfs_write_decmpfs_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	const char *buffer_to_write;
	size_t bytes_to_write;
	int ret;

	if (a->decmpfs_block_count == (unsigned)-1) {
		void *new_block;
		size_t new_size;
		unsigned int block_count;

		if (a->decmpfs_header_p == NULL) {
			new_block = malloc(MAX_DECMPFS_XATTR_SIZE
			    + sizeof(uint32_t));
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for decmpfs"");
				return (ARCHIVE_FATAL);
			}
			a->decmpfs_header_p = new_block;
		}
		a->decmpfs_attr_size = DECMPFS_HEADER_SIZE;
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_MAGIC],
		    DECMPFS_MAGIC);
		archive_le32enc(&a->decmpfs_header_p[DECMPFS_COMPRESSION_TYPE],
		    CMP_RESOURCE_FORK);
		archive_le64enc(&a->decmpfs_header_p[DECMPFS_UNCOMPRESSED_SIZE],
		    a->filesize);

		/* Calculate a block count of the file. */
		block_count =
		    (a->filesize + MAX_DECMPFS_BLOCK_SIZE -1) /
			MAX_DECMPFS_BLOCK_SIZE;
		/*
		 * Allocate buffer for resource fork.
		 * Set up related pointers;
		 */
		new_size =
		    RSRC_H_SIZE + /* header */
		    4 + /* Block count */
		    (block_count * sizeof(uint32_t) * 2) +
		    RSRC_F_SIZE; /* footer */
		if (new_size > a->resource_fork_allocated_size) {
			new_block = realloc(a->resource_fork, new_size);
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for ResourceFork"");
				return (ARCHIVE_FATAL);
			}
			a->resource_fork_allocated_size = new_size;
			a->resource_fork = new_block;
		}

		/* Allocate uncompressed buffer */
		if (a->uncompressed_buffer == NULL) {
			new_block = malloc(MAX_DECMPFS_BLOCK_SIZE);
			if (new_block == NULL) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for decmpfs"");
				return (ARCHIVE_FATAL);
			}
			a->uncompressed_buffer = new_block;
		}
		a->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;
		a->file_remaining_bytes = a->filesize;
		a->compressed_buffer_remaining = a->compressed_buffer_size;

		/*
		 * Set up a resource fork.
		 */
		a->rsrc_xattr_options = XATTR_CREATE;
		/* Get the position where we are going to set a bunch
		 * of block info. */
		a->decmpfs_block_info =
		    (uint32_t *)(a->resource_fork + RSRC_H_SIZE);
		/* Set the block count to the resource fork. */
		archive_le32enc(a->decmpfs_block_info++, block_count);
		/* Get the position where we are goint to set compressed
		 * data. */
		a->compressed_rsrc_position =
		    RSRC_H_SIZE + 4 + (block_count * 8);
		a->compressed_rsrc_position_v = a->compressed_rsrc_position;
		a->decmpfs_block_count = block_count;
	}

	/* Ignore redundant bytes. */
	if (a->file_remaining_bytes == 0)
		return ((ssize_t)size);

	/* Do not overrun a block size. */
	if (size > a->block_remaining_bytes)
		bytes_to_write = a->block_remaining_bytes;
	else
		bytes_to_write = size;
	/* Do not overrun the file size. */
	if (bytes_to_write > a->file_remaining_bytes)
		bytes_to_write = a->file_remaining_bytes;

	/* For efficiency, if a copy length is full of the uncompressed
	 * buffer size, do not copy writing data to it. */
	if (bytes_to_write == MAX_DECMPFS_BLOCK_SIZE)
		buffer_to_write = buff;
	else {
		memcpy(a->uncompressed_buffer +
		    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes,
		    buff, bytes_to_write);
		buffer_to_write = a->uncompressed_buffer;
	}
	a->block_remaining_bytes -= bytes_to_write;
	a->file_remaining_bytes -= bytes_to_write;

	if (a->block_remaining_bytes == 0 || a->file_remaining_bytes == 0) {
		ret = hfs_drive_compressor(a, buffer_to_write,
		    MAX_DECMPFS_BLOCK_SIZE - a->block_remaining_bytes);
		if (ret < 0)
			return (ret);
		a->block_remaining_bytes = MAX_DECMPFS_BLOCK_SIZE;
	}
	/* Ignore redundant bytes. */
	if (a->file_remaining_bytes == 0)
		return ((ssize_t)size);
	return (bytes_to_write);
}

static ssize_t
hfs_write_data_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	uint64_t start_size = size;
	ssize_t bytes_written = 0;
	ssize_t bytes_to_write;

	if (size == 0)
		return (ARCHIVE_OK);

	if (a->filesize == 0 || a->fd < 0) {
		archive_set_error(&a->archive, 0,
		    ""Attempt to write to an empty file"");
		return (ARCHIVE_WARN);
	}

	/* If this write would run beyond the file size, truncate it. */
	if (a->filesize >= 0 && (int64_t)(a->offset + size) > a->filesize)
		start_size = size = (size_t)(a->filesize - a->offset);

	/* Write the data. */
	while (size > 0) {
		bytes_to_write = size;
		/* Seek if necessary to the specified offset. */
		if (a->offset < a->fd_offset) {
			/* Can't support backword move. */
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Seek failed"");
			return (ARCHIVE_FATAL);
		} else if (a->offset > a->fd_offset) {
			int64_t skip = a->offset - a->fd_offset;
			char nullblock[1024];

			memset(nullblock, 0, sizeof(nullblock));
			while (skip > 0) {
				if (skip > (int64_t)sizeof(nullblock))
					bytes_written = hfs_write_decmpfs_block(
					    a, nullblock, sizeof(nullblock));
				else
					bytes_written = hfs_write_decmpfs_block(
					    a, nullblock, skip);
				if (bytes_written < 0) {
					archive_set_error(&a->archive, errno,
					    ""Write failed"");
					return (ARCHIVE_WARN);
				}
				skip -= bytes_written;
			}

			a->fd_offset = a->offset;
		}
		bytes_written =
		    hfs_write_decmpfs_block(a, buff, bytes_to_write);
		if (bytes_written < 0)
			return (bytes_written);
		buff += bytes_written;
		size -= bytes_written;
		a->total_bytes_written += bytes_written;
		a->offset += bytes_written;
		a->fd_offset = a->offset;
	}
	return (start_size - size);
}
#else
static ssize_t
hfs_write_data_block(struct archive_write_disk *a, const char *buff,
    size_t size)
{
	return (write_data_block(a, buff, size));
}
#endif

static ssize_t
_archive_write_disk_data_block(struct archive *_a,
    const void *buff, size_t size, int64_t offset)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	ssize_t r;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_DATA, ""archive_write_data_block"");

	a->offset = offset;
	if (a->todo & TODO_HFS_COMPRESSION)
		r = hfs_write_data_block(a, buff, size);
	else
		r = write_data_block(a, buff, size);
	if (r < ARCHIVE_OK)
		return (r);
	if ((size_t)r < size) {
		archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);
		return (ARCHIVE_WARN);
	}
#if ARCHIVE_VERSION_NUMBER < 3999000
	return (ARCHIVE_OK);
#else
	return (size);
#endif
}

static ssize_t
_archive_write_disk_data(struct archive *_a, const void *buff, size_t size)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_DATA, ""archive_write_data"");

	if (a->todo & TODO_HFS_COMPRESSION)
		return (hfs_write_data_block(a, buff, size));
	return (write_data_block(a, buff, size));
}

static int
_archive_write_disk_finish_entry(struct archive *_a)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	int ret = ARCHIVE_OK;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_finish_entry"");
	if (a->archive.state & ARCHIVE_STATE_HEADER)
		return (ARCHIVE_OK);
	archive_clear_error(&a->archive);

	/* Pad or truncate file to the right size. */
	if (a->fd < 0) {
		/* There's no file. */
	} else if (a->filesize < 0) {
		/* File size is unknown, so we can't set the size. */
	} else if (a->fd_offset == a->filesize) {
		/* Last write ended at exactly the filesize; we're done. */
		/* Hopefully, this is the common case. */
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)
	} else if (a->todo & TODO_HFS_COMPRESSION) {
		char null_d[1024];
		ssize_t r;

		if (a->file_remaining_bytes)
			memset(null_d, 0, sizeof(null_d));
		while (a->file_remaining_bytes) {
			if (a->file_remaining_bytes > sizeof(null_d))
				r = hfs_write_data_block(
				    a, null_d, sizeof(null_d));
			else
				r = hfs_write_data_block(
				    a, null_d, a->file_remaining_bytes);
			if (r < 0)
				return ((int)r);
		}
#endif
	} else {
#if HAVE_FTRUNCATE
		if (ftruncate(a->fd, a->filesize) == -1 &&
		    a->filesize == 0) {
			archive_set_error(&a->archive, errno,
			    ""File size could not be restored"");
			return (ARCHIVE_FAILED);
		}
#endif
		/*
		 * Not all platforms implement the XSI option to
		 * extend files via ftruncate.  Stat() the file again
		 * to see what happened.
		 */
		a->pst = NULL;
		if ((ret = lazy_stat(a)) != ARCHIVE_OK)
			return (ret);
		/* We can use lseek()/write() to extend the file if
		 * ftruncate didn't work or isn't available. */
		if (a->st.st_size < a->filesize) {
			const char nul = '\0';
			if (lseek(a->fd, a->filesize - 1, SEEK_SET) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Seek failed"");
				return (ARCHIVE_FATAL);
			}
			if (write(a->fd, &nul, 1) < 0) {
				archive_set_error(&a->archive, errno,
				    ""Write to restore size failed"");
				return (ARCHIVE_FATAL);
			}
			a->pst = NULL;
		}
	}

	/* Restore metadata. */

	/*
	 * This is specific to Mac OS X.
	 * If the current file is an AppleDouble file, it should be
	 * linked with the data fork file and remove it.
	 */
	if (a->todo & TODO_APPLEDOUBLE) {
		int r2 = fixup_appledouble(a, a->name);
		if (r2 == ARCHIVE_EOF) {
			/* The current file has been successfully linked
			 * with the data fork file and removed. So there
			 * is nothing to do on the current file.  */
			goto finish_metadata;
		}
		if (r2 < ret) ret = r2;
	}

	/*
	 * Look up the ""real"" UID only if we're going to need it.
	 * TODO: the TODO_SGID condition can be dropped here, can't it?
	 */
	if (a->todo & (TODO_OWNER | TODO_SUID | TODO_SGID)) {
		a->uid = archive_write_disk_uid(&a->archive,
		    archive_entry_uname(a->entry),
		    archive_entry_uid(a->entry));
	}
	/* Look up the ""real"" GID only if we're going to need it. */
	/* TODO: the TODO_SUID condition can be dropped here, can't it? */
	if (a->todo & (TODO_OWNER | TODO_SGID | TODO_SUID)) {
		a->gid = archive_write_disk_gid(&a->archive,
		    archive_entry_gname(a->entry),
		    archive_entry_gid(a->entry));
	 }

	/*
	 * Restore ownership before set_mode tries to restore suid/sgid
	 * bits.  If we set the owner, we know what it is and can skip
	 * a stat() call to examine the ownership of the file on disk.
	 */
	if (a->todo & TODO_OWNER) {
		int r2 = set_ownership(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * set_mode must precede ACLs on systems such as Solaris and
	 * FreeBSD where setting the mode implicitly clears extended ACLs
	 */
	if (a->todo & TODO_MODE) {
		int r2 = set_mode(a, a->mode);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Security-related extended attributes (such as
	 * security.capability on Linux) have to be restored last,
	 * since they're implicitly removed by other file changes.
	 */
	if (a->todo & TODO_XATTR) {
		int r2 = set_xattrs(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Some flags prevent file modification; they must be restored after
	 * file contents are written.
	 */
	if (a->todo & TODO_FFLAGS) {
		int r2 = set_fflags(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Time must follow most other metadata;
	 * otherwise atime will get changed.
	 */
	if (a->todo & TODO_TIMES) {
		int r2 = set_times_from_entry(a);
		if (r2 < ret) ret = r2;
	}

	/*
	 * Mac extended metadata includes ACLs.
	 */
	if (a->todo & TODO_MAC_METADATA) {
		const void *metadata;
		size_t metadata_size;
		metadata = archive_entry_mac_metadata(a->entry, &metadata_size);
		if (metadata != NULL && metadata_size > 0) {
			int r2 = set_mac_metadata(a, archive_entry_pathname(
			    a->entry), metadata, metadata_size);
			if (r2 < ret) ret = r2;
		}
	}

	/*
	 * ACLs must be restored after timestamps because there are
	 * ACLs that prevent attribute changes (including time).
	 */
	if (a->todo & TODO_ACLS) {
		int r2 = archive_write_disk_set_acls(&a->archive, a->fd,
				  archive_entry_pathname(a->entry),
				  archive_entry_acl(a->entry));
		if (r2 < ret) ret = r2;
	}

finish_metadata:
	/* If there's an fd, we can close it now. */
	if (a->fd >= 0) {
		close(a->fd);
		a->fd = -1;
	}
	/* If there's an entry, we can release it now. */
	if (a->entry) {
		archive_entry_free(a->entry);
		a->entry = NULL;
	}
	a->archive.state = ARCHIVE_STATE_HEADER;
	return (ret);
}

int
archive_write_disk_set_group_lookup(struct archive *_a,
    void *private_data,
    int64_t (*lookup_gid)(void *private, const char *gname, int64_t gid),
    void (*cleanup_gid)(void *private))
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_group_lookup"");

	if (a->cleanup_gid != NULL && a->lookup_gid_data != NULL)
		(a->cleanup_gid)(a->lookup_gid_data);

	a->lookup_gid = lookup_gid;
	a->cleanup_gid = cleanup_gid;
	a->lookup_gid_data = private_data;
	return (ARCHIVE_OK);
}

int
archive_write_disk_set_user_lookup(struct archive *_a,
    void *private_data,
    int64_t (*lookup_uid)(void *private, const char *uname, int64_t uid),
    void (*cleanup_uid)(void *private))
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_set_user_lookup"");

	if (a->cleanup_uid != NULL && a->lookup_uid_data != NULL)
		(a->cleanup_uid)(a->lookup_uid_data);

	a->lookup_uid = lookup_uid;
	a->cleanup_uid = cleanup_uid;
	a->lookup_uid_data = private_data;
	return (ARCHIVE_OK);
}

int64_t
archive_write_disk_gid(struct archive *_a, const char *name, int64_t id)
{
       struct archive_write_disk *a = (struct archive_write_disk *)_a;
       archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
           ARCHIVE_STATE_ANY, ""archive_write_disk_gid"");
       if (a->lookup_gid)
               return (a->lookup_gid)(a->lookup_gid_data, name, id);
       return (id);
}
 
int64_t
archive_write_disk_uid(struct archive *_a, const char *name, int64_t id)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY, ""archive_write_disk_uid"");
	if (a->lookup_uid)
		return (a->lookup_uid)(a->lookup_uid_data, name, id);
	return (id);
}

/*
 * Create a new archive_write_disk object and initialize it with global state.
 */
struct archive *
archive_write_disk_new(void)
{
	struct archive_write_disk *a;

	a = (struct archive_write_disk *)malloc(sizeof(*a));
	if (a == NULL)
		return (NULL);
	memset(a, 0, sizeof(*a));
	a->archive.magic = ARCHIVE_WRITE_DISK_MAGIC;
	/* We're ready to write a header immediately. */
	a->archive.state = ARCHIVE_STATE_HEADER;
	a->archive.vtable = archive_write_disk_vtable();
	a->start_time = time(NULL);
	/* Query and restore the umask. */
	umask(a->user_umask = umask(0));
#ifdef HAVE_GETEUID
	a->user_uid = geteuid();
#endif /* HAVE_GETEUID */
	if (archive_string_ensure(&a->path_safe, 512) == NULL) {
		free(a);
		return (NULL);
	}
#ifdef HAVE_ZLIB_H
	a->decmpfs_compression_level = 5;
#endif
	return (&a->archive);
}


/*
 * If pathname is longer than PATH_MAX, chdir to a suitable
 * intermediate dir and edit the path down to a shorter suffix.  Note
 * that this routine never returns an error; if the chdir() attempt
 * fails for any reason, we just go ahead with the long pathname.  The
 * object creation is likely to fail, but any error will get handled
 * at that time.
 */
#if defined(HAVE_FCHDIR) && defined(PATH_MAX)
static void
edit_deep_directories(struct archive_write_disk *a)
{
	int ret;
	char *tail = a->name;

	/* If path is short, avoid the open() below. */
	if (strlen(tail) <= PATH_MAX)
		return;

	/* Try to record our starting dir. */
	a->restore_pwd = open(""."", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(a->restore_pwd);
	if (a->restore_pwd < 0)
		return;

	/* As long as the path is too long... */
	while (strlen(tail) > PATH_MAX) {
		/* Locate a dir prefix shorter than PATH_MAX. */
		tail += PATH_MAX - 8;
		while (tail > a->name && *tail != '/')
			tail--;
		/* Exit if we find a too-long path component. */
		if (tail <= a->name)
			return;
		/* Create the intermediate dir and chdir to it. */
		*tail = '\0'; /* Terminate dir portion */
		ret = create_dir(a, a->name);
		if (ret == ARCHIVE_OK && chdir(a->name) != 0)
			ret = ARCHIVE_FAILED;
		*tail = '/'; /* Restore the / we removed. */
		if (ret != ARCHIVE_OK)
			return;
		tail++;
		/* The chdir() succeeded; we've now shortened the path. */
		a->name = tail;
	}
	return;
}
#endif

/*
 * The main restore function.
 */
static int
restore_entry(struct archive_write_disk *a)
{
	int ret = ARCHIVE_OK, en;

	if (a->flags & ARCHIVE_EXTRACT_UNLINK && !S_ISDIR(a->mode)) {
		/*
		 * TODO: Fix this.  Apparently, there are platforms
		 * that still allow root to hose the entire filesystem
		 * by unlinking a dir.  The S_ISDIR() test above
		 * prevents us from using unlink() here if the new
		 * object is a dir, but that doesn't mean the old
		 * object isn't a dir.
		 */
		if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
			(void)clear_nochange_fflags(a);
		if (unlink(a->name) == 0) {
			/* We removed it, reset cached stat. */
			a->pst = NULL;
		} else if (errno == ENOENT) {
			/* File didn't exist, that's just as good. */
		} else if (rmdir(a->name) == 0) {
			/* It was a dir, but now it's gone. */
			a->pst = NULL;
		} else {
			/* We tried, but couldn't get rid of it. */
			archive_set_error(&a->archive, errno,
			    ""Could not unlink"");
			return(ARCHIVE_FAILED);
		}
	}

	/* Try creating it first; if this fails, we'll try to recover. */
	en = create_filesystem_object(a);

	if ((en == ENOTDIR || en == ENOENT)
	    && !(a->flags & ARCHIVE_EXTRACT_NO_AUTODIR)) {
		/* If the parent dir doesn't exist, try creating it. */
		create_parent_dir(a, a->name);
		/* Now try to create the object again. */
		en = create_filesystem_object(a);
	}

	if ((en == ENOENT) && (archive_entry_hardlink(a->entry) != NULL)) {
		archive_set_error(&a->archive, en,
		    ""Hard-link target '%s' does not exist."",
		    archive_entry_hardlink(a->entry));
		return (ARCHIVE_FAILED);
	}

	if ((en == EISDIR || en == EEXIST)
	    && (a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {
		/* If we're not overwriting, we're done. */
		archive_entry_unset_size(a->entry);
		return (ARCHIVE_OK);
	}

	/*
	 * Some platforms return EISDIR if you call
	 * open(O_WRONLY | O_EXCL | O_CREAT) on a directory, some
	 * return EEXIST.  POSIX is ambiguous, requiring EISDIR
	 * for open(O_WRONLY) on a dir and EEXIST for open(O_EXCL | O_CREAT)
	 * on an existing item.
	 */
	if (en == EISDIR) {
		/* A dir is in the way of a non-dir, rmdir it. */
		if (rmdir(a->name) != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't remove already-existing dir"");
			return (ARCHIVE_FAILED);
		}
		a->pst = NULL;
		/* Try again. */
		en = create_filesystem_object(a);
	} else if (en == EEXIST) {
		/*
		 * We know something is in the way, but we don't know what;
		 * we need to find out before we go any further.
		 */
		int r = 0;
		/*
		 * The SECURE_SYMLINKS logic has already removed a
		 * symlink to a dir if the client wants that.  So
		 * follow the symlink if we're creating a dir.
		 */
		if (S_ISDIR(a->mode))
			r = stat(a->name, &a->st);
		/*
		 * If it's not a dir (or it's a broken symlink),
		 * then don't follow it.
		 */
		if (r != 0 || !S_ISDIR(a->mode))
			r = lstat(a->name, &a->st);
		if (r != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't stat existing object"");
			return (ARCHIVE_FAILED);
		}

		/*
		 * NO_OVERWRITE_NEWER doesn't apply to directories.
		 */
		if ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER)
		    &&  !S_ISDIR(a->st.st_mode)) {
			if (!older(&(a->st), a->entry)) {
				archive_entry_unset_size(a->entry);
				return (ARCHIVE_OK);
			}
		}

		/* If it's our archive, we're done. */
		if (a->skip_file_set &&
		    a->st.st_dev == (dev_t)a->skip_file_dev &&
		    a->st.st_ino == (ino_t)a->skip_file_ino) {
			archive_set_error(&a->archive, 0,
			    ""Refusing to overwrite archive"");
			return (ARCHIVE_FAILED);
		}

		if (!S_ISDIR(a->st.st_mode)) {
			/* A non-dir is in the way, unlink it. */
			if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
				(void)clear_nochange_fflags(a);
			if (unlink(a->name) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't unlink already-existing object"");
				return (ARCHIVE_FAILED);
			}
			a->pst = NULL;
			/* Try again. */
			en = create_filesystem_object(a);
		} else if (!S_ISDIR(a->mode)) {
			/* A dir is in the way of a non-dir, rmdir it. */
			if (a->flags & ARCHIVE_EXTRACT_CLEAR_NOCHANGE_FFLAGS)
				(void)clear_nochange_fflags(a);
			if (rmdir(a->name) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't replace existing directory with non-directory"");
				return (ARCHIVE_FAILED);
			}
			/* Try again. */
			en = create_filesystem_object(a);
		} else {
			/*
			 * There's a dir in the way of a dir.  Don't
			 * waste time with rmdir()/mkdir(), just fix
			 * up the permissions on the existing dir.
			 * Note that we don't change perms on existing
			 * dirs unless _EXTRACT_PERM is specified.
			 */
			if ((a->mode != a->st.st_mode)
			    && (a->todo & TODO_MODE_FORCE))
				a->deferred |= (a->todo & TODO_MODE);
			/* Ownership doesn't need deferred fixup. */
			en = 0; /* Forget the EEXIST. */
		}
	}

	if (en) {
		/* Everything failed; give up here. */
		archive_set_error(&a->archive, en, ""Can't create '%s'"",
		    a->name);
		return (ARCHIVE_FAILED);
	}

	a->pst = NULL; /* Cached stat data no longer valid. */
	return (ret);
}

/*
 * Returns 0 if creation succeeds, or else returns errno value from
 * the failed system call.   Note:  This function should only ever perform
 * a single system call.
 */
static int
create_filesystem_object(struct archive_write_disk *a)
{
	/* Create the entry. */
	const char *linkname;
	mode_t final_mode, mode;
	int r;

	/* We identify hard/symlinks according to the link names. */
	/* Since link(2) and symlink(2) don't handle modes, we're done here. */
	linkname = archive_entry_hardlink(a->entry);
	if (linkname != NULL) {
#if !HAVE_LINK
		return (EPERM);
#else
		r = link(linkname, a->name) ? errno : 0;
		/*
		 * New cpio and pax formats allow hardlink entries
		 * to carry data, so we may have to open the file
		 * for hardlink entries.
		 *
		 * If the hardlink was successfully created and
		 * the archive doesn't have carry data for it,
		 * consider it to be non-authoritative for meta data.
		 * This is consistent with GNU tar and BSD pax.
		 * If the hardlink does carry data, let the last
		 * archive entry decide ownership.
		 */
		if (r == 0 && a->filesize <= 0) {
			a->todo = 0;
			a->deferred = 0;
		} else if (r == 0 && a->filesize > 0) {
			a->fd = open(a->name,
				     O_WRONLY | O_TRUNC | O_BINARY | O_CLOEXEC);
			__archive_ensure_cloexec_flag(a->fd);
			if (a->fd < 0)
				r = errno;
		}
		return (r);
#endif
	}
	linkname = archive_entry_symlink(a->entry);
	if (linkname != NULL) {
#if HAVE_SYMLINK
		return symlink(linkname, a->name) ? errno : 0;
#else
		return (EPERM);
#endif
	}

	/*
	 * The remaining system calls all set permissions, so let's
	 * try to take advantage of that to avoid an extra chmod()
	 * call.  (Recall that umask is set to zero right now!)
	 */

	/* Mode we want for the final restored object (w/o file type bits). */
	final_mode = a->mode & 07777;
	/*
	 * The mode that will actually be restored in this step.  Note
	 * that SUID, SGID, etc, require additional work to ensure
	 * security, so we never restore them at this point.
	 */
	mode = final_mode & 0777 & ~a->user_umask;

	switch (a->mode & AE_IFMT) {
	default:
		/* POSIX requires that we fall through here. */
		/* FALLTHROUGH */
	case AE_IFREG:
		a->fd = open(a->name,
		    O_WRONLY | O_CREAT | O_EXCL | O_BINARY | O_CLOEXEC, mode);
		__archive_ensure_cloexec_flag(a->fd);
		r = (a->fd < 0);
		break;
	case AE_IFCHR:
#ifdef HAVE_MKNOD
		/* Note: we use AE_IFCHR for the case label, and
		 * S_IFCHR for the mknod() call.  This is correct.  */
		r = mknod(a->name, mode | S_IFCHR,
		    archive_entry_rdev(a->entry));
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a char device node. */
		return (EINVAL);
#endif /* HAVE_MKNOD */
	case AE_IFBLK:
#ifdef HAVE_MKNOD
		r = mknod(a->name, mode | S_IFBLK,
		    archive_entry_rdev(a->entry));
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a block device node. */
		return (EINVAL);
#endif /* HAVE_MKNOD */
	case AE_IFDIR:
		mode = (mode | MINIMUM_DIR_MODE) & MAXIMUM_DIR_MODE;
		r = mkdir(a->name, mode);
		if (r == 0) {
			/* Defer setting dir times. */
			a->deferred |= (a->todo & TODO_TIMES);
			a->todo &= ~TODO_TIMES;
			/* Never use an immediate chmod(). */
			/* We can't avoid the chmod() entirely if EXTRACT_PERM
			 * because of SysV SGID inheritance. */
			if ((mode != final_mode)
			    || (a->flags & ARCHIVE_EXTRACT_PERM))
				a->deferred |= (a->todo & TODO_MODE);
			a->todo &= ~TODO_MODE;
		}
		break;
	case AE_IFIFO:
#ifdef HAVE_MKFIFO
		r = mkfifo(a->name, mode);
		break;
#else
		/* TODO: Find a better way to warn about our inability
		 * to restore a fifo. */
		return (EINVAL);
#endif /* HAVE_MKFIFO */
	}

	/* All the system calls above set errno on failure. */
	if (r)
		return (errno);

	/* If we managed to set the final mode, we've avoided a chmod(). */
	if (mode == final_mode)
		a->todo &= ~TODO_MODE;
	return (0);
}

/*
 * Cleanup function for archive_extract.  Mostly, this involves processing
 * the fixup list, which is used to address a number of problems:
 *   * Dir permissions might prevent us from restoring a file in that
 *     dir, so we restore the dir with minimum 0700 permissions first,
 *     then correct the mode at the end.
 *   * Similarly, the act of restoring a file touches the directory
 *     and changes the timestamp on the dir, so we have to touch-up dir
 *     timestamps at the end as well.
 *   * Some file flags can interfere with the restore by, for example,
 *     preventing the creation of hardlinks to those files.
 *   * Mac OS extended metadata includes ACLs, so must be deferred on dirs.
 *
 * Note that tar/cpio do not require that archives be in a particular
 * order; there is no way to know when the last file has been restored
 * within a directory, so there's no way to optimize the memory usage
 * here by fixing up the directory any earlier than the
 * end-of-archive.
 *
 * XXX TODO: Directory ACLs should be restored here, for the same
 * reason we set directory perms here. XXX
 */
static int
_archive_write_disk_close(struct archive *_a)
{
	struct archive_write_disk *a = (struct archive_write_disk *)_a;
	struct fixup_entry *next, *p;
	int ret;

	archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,
	    ""archive_write_disk_close"");
	ret = _archive_write_disk_finish_entry(&a->archive);

	/* Sort dir list so directories are fixed up in depth-first order. */
	p = sort_dir_list(a->fixup_list);

	while (p != NULL) {
		a->pst = NULL; /* Mark stat cache as out-of-date. */
		if (p->fixup & TODO_TIMES) {
			set_times(a, -1, p->mode, p->name,
			    p->atime, p->atime_nanos,
			    p->birthtime, p->birthtime_nanos,
			    p->mtime, p->mtime_nanos,
			    p->ctime, p->ctime_nanos);
		}
		if (p->fixup & TODO_MODE_BASE)
			chmod(p->name, p->mode);
		if (p->fixup & TODO_ACLS)
			archive_write_disk_set_acls(&a->archive,
						    -1, p->name, &p->acl);
		if (p->fixup & TODO_FFLAGS)
			set_fflags_platform(a, -1, p->name,
			    p->mode, p->fflags_set, 0);
		if (p->fixup & TODO_MAC_METADATA)
			set_mac_metadata(a, p->name, p->mac_metadata,
					 p->mac_metadata_size);
		next = p->next;
		archive_acl_clear(&p->acl);
		free(p->mac_metadata);
		free(p->name);
		free(p);
		p = next;
	}
	a->fixup_list = NULL;
	return (ret);
}

static int
_archive_write_disk_free(struct archive *_a)
{
	struct archive_write_disk *a;
	int ret;
	if (_a == NULL)
		return (ARCHIVE_OK);
	archive_check_magic(_a, ARCHIVE_WRITE_DISK_MAGIC,
	    ARCHIVE_STATE_ANY | ARCHIVE_STATE_FATAL, ""archive_write_disk_free"");
	a = (struct archive_write_disk *)_a;
	ret = _archive_write_disk_close(&a->archive);
	archive_write_disk_set_group_lookup(&a->archive, NULL, NULL, NULL);
	archive_write_disk_set_user_lookup(&a->archive, NULL, NULL, NULL);
	if (a->entry)
		archive_entry_free(a->entry);
	archive_string_free(&a->_name_data);
	archive_string_free(&a->archive.error_string);
	archive_string_free(&a->path_safe);
	a->archive.magic = 0;
	__archive_clean(&a->archive);
	free(a->decmpfs_header_p);
	free(a->resource_fork);
	free(a->compressed_buffer);
	free(a->uncompressed_buffer);
#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_SYS_XATTR_H)\
	&& defined(HAVE_ZLIB_H)
	if (a->stream_valid) {
		switch (deflateEnd(&a->stream)) {
		case Z_OK:
			break;
		default:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Failed to clean up compressor"");
			ret = ARCHIVE_FATAL;
			break;
		}
	}
#endif
	free(a);
	return (ret);
}

/*
 * Simple O(n log n) merge sort to order the fixup list.  In
 * particular, we want to restore dir timestamps depth-first.
 */
static struct fixup_entry *
sort_dir_list(struct fixup_entry *p)
{
	struct fixup_entry *a, *b, *t;

	if (p == NULL)
		return (NULL);
	/* A one-item list is already sorted. */
	if (p->next == NULL)
		return (p);

	/* Step 1: split the list. */
	t = p;
	a = p->next->next;
	while (a != NULL) {
		/* Step a twice, t once. */
		a = a->next;
		if (a != NULL)
			a = a->next;
		t = t->next;
	}
	/* Now, t is at the mid-point, so break the list here. */
	b = t->next;
	t->next = NULL;
	a = p;

	/* Step 2: Recursively sort the two sub-lists. */
	a = sort_dir_list(a);
	b = sort_dir_list(b);

	/* Step 3: Merge the returned lists. */
	/* Pick the first element for the merged list. */
	if (strcmp(a->name, b->name) > 0) {
		t = p = a;
		a = a->next;
	} else {
		t = p = b;
		b = b->next;
	}

	/* Always put the later element on the list first. */
	while (a != NULL && b != NULL) {
		if (strcmp(a->name, b->name) > 0) {
			t->next = a;
			a = a->next;
		} else {
			t->next = b;
			b = b->next;
		}
		t = t->next;
	}

	/* Only one list is non-empty, so just splice it on. */
	if (a != NULL)
		t->next = a;
	if (b != NULL)
		t->next = b;

	return (p);
}

/*
 * Returns a new, initialized fixup entry.
 *
 * TODO: Reduce the memory requirements for this list by using a tree
 * structure rather than a simple list of names.
 */
static struct fixup_entry *
new_fixup(struct archive_write_disk *a, const char *pathname)
{
	struct fixup_entry *fe;

	fe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));
	if (fe == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate memory for a fixup"");
		return (NULL);
	}
	fe->next = a->fixup_list;
	a->fixup_list = fe;
	fe->fixup = 0;
	fe->name = strdup(pathname);
	return (fe);
}

/*
 * Returns a fixup structure for the current entry.
 */
static struct fixup_entry *
current_fixup(struct archive_write_disk *a, const char *pathname)
{
	if (a->current_fixup == NULL)
		a->current_fixup = new_fixup(a, pathname);
	return (a->current_fixup);
}

/* TODO: Make this work. */
/*
 * TODO: The deep-directory support bypasses this; disable deep directory
 * support if we're doing symlink checks.
 */
/*
 * TODO: Someday, integrate this with the deep dir support; they both
 * scan the path and both can be optimized by comparing against other
 * recent paths.
 */
/* TODO: Extend this to support symlinks on Windows Vista and later. */
static int
check_symlinks(struct archive_write_disk *a)
{
#if !defined(HAVE_LSTAT)
	/* Platform doesn't have lstat, so we can't look for symlinks. */
	(void)a; /* UNUSED */
	return (ARCHIVE_OK);
#else
	char *pn;
	char c;
	int r;
	struct stat st;

	/*
	 * Guard against symlink tricks.  Reject any archive entry whose
	 * destination would be altered by a symlink.
	 */
	/* Whatever we checked last time doesn't need to be re-checked. */
	pn = a->name;
	if (archive_strlen(&(a->path_safe)) > 0) {
		char *p = a->path_safe.s;
		while ((*pn != '\0') && (*p == *pn))
			++p, ++pn;
	}
	/* Skip the root directory if the path is absolute. */
	if(pn == a->name && pn[0] == '/')
		++pn;
	c = pn[0];
	/* Keep going until we've checked the entire name. */
	while (pn[0] != '\0' && (pn[0] != '/' || pn[1] != '\0')) {
		/* Skip the next path element. */
		while (*pn != '\0' && *pn != '/')
			++pn;
		c = pn[0];
		pn[0] = '\0';
		/* Check that we haven't hit a symlink. */
		r = lstat(a->name, &st);
		if (r != 0) {
			/* We've hit a dir that doesn't exist; stop now. */
			if (errno == ENOENT)
				break;
		} else if (S_ISLNK(st.st_mode)) {
			if (c == '\0') {
				/*
				 * Last element is symlink; remove it
				 * so we can overwrite it with the
				 * item being extracted.
				 */
				if (unlink(a->name)) {
					archive_set_error(&a->archive, errno,
					    ""Could not remove symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
				/*
				 * Even if we did remove it, a warning
				 * is in order.  The warning is silly,
				 * though, if we're just replacing one
				 * symlink with another symlink.
				 */
				if (!S_ISLNK(a->mode)) {
					archive_set_error(&a->archive, 0,
					    ""Removing symlink %s"",
					    a->name);
				}
				/* Symlink gone.  No more problem! */
				pn[0] = c;
				return (0);
			} else if (a->flags & ARCHIVE_EXTRACT_UNLINK) {
				/* User asked us to remove problems. */
				if (unlink(a->name) != 0) {
					archive_set_error(&a->archive, 0,
					    ""Cannot remove intervening symlink %s"",
					    a->name);
					pn[0] = c;
					return (ARCHIVE_FAILED);
				}
				a->pst = NULL;
			} else {
				archive_set_error(&a->archive, 0,
				    ""Cannot extract through symlink %s"",
				    a->name);
				pn[0] = c;
				return (ARCHIVE_FAILED);
			}
		}
		pn[0] = c;
		if (pn[0] != '\0')
			pn++; /* Advance to the next segment. */
	}
	pn[0] = c;
	/* We've checked and/or cleaned the whole path, so remember it. */
	archive_strcpy(&a->path_safe, a->name);
	return (ARCHIVE_OK);
#endif
}

#if defined(__CYGWIN__)
/*
 * 1. Convert a path separator from '\' to '/' .
 *    We shouldn't check multibyte character directly because some
 *    character-set have been using the '\' character for a part of
 *    its multibyte character code.
 * 2. Replace unusable characters in Windows with underscore('_').
 * See also : http://msdn.microsoft.com/en-us/library/aa365247.aspx
 */
static void
cleanup_pathname_win(struct archive_write_disk *a)
{
	wchar_t wc;
	char *p;
	size_t alen, l;
	int mb, complete, utf8;

	alen = 0;
	mb = 0;
	complete = 1;
	utf8 = (strcmp(nl_langinfo(CODESET), ""UTF-8"") == 0)? 1: 0;
	for (p = a->name; *p != '\0'; p++) {
		++alen;
		if (*p == '\\') {
			/* If previous byte is smaller than 128,
			 * this is not second byte of multibyte characters,
			 * so we can replace '\' with '/'. */
			if (utf8 || !mb)
				*p = '/';
			else
				complete = 0;/* uncompleted. */
		} else if (*(unsigned char *)p > 127)
			mb = 1;
		else
			mb = 0;
		/* Rewrite the path name if its next character is unusable. */
		if (*p == ':' || *p == '*' || *p == '?' || *p == '""' ||
		    *p == '<' || *p == '>' || *p == '|')
			*p = '_';
	}
	if (complete)
		return;

	/*
	 * Convert path separator in wide-character.
	 */
	p = a->name;
	while (*p != '\0' && alen) {
		l = mbtowc(&wc, p, alen);
		if (l == (size_t)-1) {
			while (*p != '\0') {
				if (*p == '\\')
					*p = '/';
				++p;
			}
			break;
		}
		if (l == 1 && wc == L'\\')
			*p = '/';
		p += l;
		alen -= l;
	}
}
#endif

/*
 * Canonicalize the pathname.  In particular, this strips duplicate
 * '/' characters, '.' elements, and trailing '/'.  It also raises an
 * error for an empty path, a trailing '..', (if _SECURE_NODOTDOT is
 * set) any '..' in the path or (if ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
 * is set) if the path is absolute.
 */
static int
cleanup_pathname(struct archive_write_disk *a)
{
	char *dest, *src;
	char separator = '\0';

	dest = src = a->name;
	if (*src == '\0') {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}

#if defined(__CYGWIN__)
	cleanup_pathname_win(a);
#endif
	/* Skip leading '/'. */
	if (*src == '/') {
		if (a->flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}

		separator = *src++;
	}

	/* Scan the pathname one element at a time. */
	for (;;) {
		/* src points to first char after '/' */
		if (src[0] == '\0') {
			break;
		} else if (src[0] == '/') {
			/* Found '//', ignore second one. */
			src++;
			continue;
		} else if (src[0] == '.') {
			if (src[1] == '\0') {
				/* Ignore trailing '.' */
				break;
			} else if (src[1] == '/') {
				/* Skip './'. */
				src += 2;
				continue;
			} else if (src[1] == '.') {
				if (src[2] == '/' || src[2] == '\0') {
					/* Conditionally warn about '..' */
					if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}
				}
				/*
				 * Note: Under no circumstances do we
				 * remove '..' elements.  In
				 * particular, restoring
				 * '/foo/../bar/' should create the
				 * 'foo' dir as a side-effect.
				 */
			}
		}

		/* Copy current element, including leading '/'. */
		if (separator)
			*dest++ = '/';
		while (*src != '\0' && *src != '/') {
			*dest++ = *src++;
		}

		if (*src == '\0')
			break;

		/* Skip '/' separator. */
		separator = *src++;
	}
	/*
	 * We've just copied zero or more path elements, not including the
	 * final '/'.
	 */
	if (dest == a->name) {
		/*
		 * Nothing got copied.  The path must have been something
		 * like '.' or '/' or './' or '/././././/./'.
		 */
		if (separator)
			*dest++ = '/';
		else
			*dest++ = '.';
	}
	/* Terminate the result. */
	*dest = '\0';
	return (ARCHIVE_OK);
}

/*
 * Create the parent directory of the specified path, assuming path
 * is already in mutable storage.
 */
static int
create_parent_dir(struct archive_write_disk *a, char *path)
{
	char *slash;
	int r;

	/* Remove tail element to obtain parent name. */
	slash = strrchr(path, '/');
	if (slash == NULL)
		return (ARCHIVE_OK);
	*slash = '\0';
	r = create_dir(a, path);
	*slash = '/';
	return (r);
}

/*
 * Create the specified dir, recursing to create parents as necessary.
 *
 * Returns ARCHIVE_OK if the path exists when we're done here.
 * Otherwise, returns ARCHIVE_FAILED.
 * Assumes path is in mutable storage; path is unchanged on exit.
 */
static int
create_dir(struct archive_write_disk *a, char *path)
{
	struct stat st;
	struct fixup_entry *le;
	char *slash, *base;
	mode_t mode_final, mode;
	int r;

	/* Check for special names and just skip them. */
	slash = strrchr(path, '/');
	if (slash == NULL)
		base = path;
	else
		base = slash + 1;

	if (base[0] == '\0' ||
	    (base[0] == '.' && base[1] == '\0') ||
	    (base[0] == '.' && base[1] == '.' && base[2] == '\0')) {
		/* Don't bother trying to create null path, '.', or '..'. */
		if (slash != NULL) {
			*slash = '\0';
			r = create_dir(a, path);
			*slash = '/';
			return (r);
		}
		return (ARCHIVE_OK);
	}

	/*
	 * Yes, this should be stat() and not lstat().  Using lstat()
	 * here loses the ability to extract through symlinks.  Also note
	 * that this should not use the a->st cache.
	 */
	if (stat(path, &st) == 0) {
		if (S_ISDIR(st.st_mode))
			return (ARCHIVE_OK);
		if ((a->flags & ARCHIVE_EXTRACT_NO_OVERWRITE)) {
			archive_set_error(&a->archive, EEXIST,
			    ""Can't create directory '%s'"", path);
			return (ARCHIVE_FAILED);
		}
		if (unlink(path) != 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't create directory '%s': ""
			    ""Conflicting file cannot be removed"",
			    path);
			return (ARCHIVE_FAILED);
		}
	} else if (errno != ENOENT && errno != ENOTDIR) {
		/* Stat failed? */
		archive_set_error(&a->archive, errno, ""Can't test directory '%s'"", path);
		return (ARCHIVE_FAILED);
	} else if (slash != NULL) {
		*slash = '\0';
		r = create_dir(a, path);
		*slash = '/';
		if (r != ARCHIVE_OK)
			return (r);
	}

	/*
	 * Mode we want for the final restored directory.  Per POSIX,
	 * implicitly-created dirs must be created obeying the umask.
	 * There's no mention whether this is different for privileged
	 * restores (which the rest of this code handles by pretending
	 * umask=0).  I've chosen here to always obey the user's umask for
	 * implicit dirs, even if _EXTRACT_PERM was specified.
	 */
	mode_final = DEFAULT_DIR_MODE & ~a->user_umask;
	/* Mode we want on disk during the restore process. */
	mode = mode_final;
	mode |= MINIMUM_DIR_MODE;
	mode &= MAXIMUM_DIR_MODE;
	if (mkdir(path, mode) == 0) {
		if (mode != mode_final) {
			le = new_fixup(a, path);
			if (le == NULL)
				return (ARCHIVE_FATAL);
			le->fixup |=TODO_MODE_BASE;
			le->mode = mode_final;
		}
		return (ARCHIVE_OK);
	}

	/*
	 * Without the following check, a/b/../b/c/d fails at the
	 * second visit to 'b', so 'd' can't be created.  Note that we
	 * don't add it to the fixup list here, as it's already been
	 * added.
	 */
	if (stat(path, &st) == 0 && S_ISDIR(st.st_mode))
		return (ARCHIVE_OK);

	archive_set_error(&a->archive, errno, ""Failed to create dir '%s'"",
	    path);
	return (ARCHIVE_FAILED);
}

/*
 * Note: Although we can skip setting the user id if the desired user
 * id matches the current user, we cannot skip setting the group, as
 * many systems set the gid based on the containing directory.  So
 * we have to perform a chown syscall if we want to set the SGID
 * bit.  (The alternative is to stat() and then possibly chown(); it's
 * more efficient to skip the stat() and just always chown().)  Note
 * that a successful chown() here clears the TODO_SGID_CHECK bit, which
 * allows set_mode to skip the stat() check for the GID.
 */
static int
set_ownership(struct archive_write_disk *a)
{
#ifndef __CYGWIN__
/* unfortunately, on win32 there is no 'root' user with uid 0,
   so we just have to try the chown and see if it works */

	/* If we know we can't change it, don't bother trying. */
	if (a->user_uid != 0  &&  a->user_uid != a->uid) {
		archive_set_error(&a->archive, errno,
		    ""Can't set UID=%jd"", (intmax_t)a->uid);
		return (ARCHIVE_WARN);
	}
#endif

#ifdef HAVE_FCHOWN
	/* If we have an fd, we can avoid a race. */
	if (a->fd >= 0 && fchown(a->fd, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#endif

	/* We prefer lchown() but will use chown() if that's all we have. */
	/* Of course, if we have neither, this will always fail. */
#ifdef HAVE_LCHOWN
	if (lchown(a->name, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#elif HAVE_CHOWN
	if (!S_ISLNK(a->mode) && chown(a->name, a->uid, a->gid) == 0) {
		/* We've set owner and know uid/gid are correct. */
		a->todo &= ~(TODO_OWNER | TODO_SGID_CHECK | TODO_SUID_CHECK);
		return (ARCHIVE_OK);
	}
#endif

	archive_set_error(&a->archive, errno,
	    ""Can't set user=%jd/group=%jd for %s"",
	    (intmax_t)a->uid, (intmax_t)a->gid, a->name);
	return (ARCHIVE_WARN);
}

/*
 * Note: Returns 0 on success, non-zero on failure.
 */
static int
set_time(int fd, int mode, const char *name,
    time_t atime, long atime_nsec,
    time_t mtime, long mtime_nsec)
{
	/* Select the best implementation for this platform. */
#if defined(HAVE_UTIMENSAT) && defined(HAVE_FUTIMENS)
	/*
	 * utimensat() and futimens() are defined in
	 * POSIX.1-2008. They support ns resolution and setting times
	 * on fds and symlinks.
	 */
	struct timespec ts[2];
	(void)mode; /* UNUSED */
	ts[0].tv_sec = atime;
	ts[0].tv_nsec = atime_nsec;
	ts[1].tv_sec = mtime;
	ts[1].tv_nsec = mtime_nsec;
	if (fd >= 0)
		return futimens(fd, ts);
	return utimensat(AT_FDCWD, name, ts, AT_SYMLINK_NOFOLLOW);

#elif HAVE_UTIMES
	/*
	 * The utimes()-family functions support µs-resolution and
	 * setting times fds and symlinks.  utimes() is documented as
	 * LEGACY by POSIX, futimes() and lutimes() are not described
	 * in POSIX.
	 */
	struct timeval times[2];

	times[0].tv_sec = atime;
	times[0].tv_usec = atime_nsec / 1000;
	times[1].tv_sec = mtime;
	times[1].tv_usec = mtime_nsec / 1000;

#ifdef HAVE_FUTIMES
	if (fd >= 0)
		return (futimes(fd, times));
#else
	(void)fd; /* UNUSED */
#endif
#ifdef HAVE_LUTIMES
	(void)mode; /* UNUSED */
	return (lutimes(name, times));
#else
	if (S_ISLNK(mode))
		return (0);
	return (utimes(name, times));
#endif

#elif defined(HAVE_UTIME)
	/*
	 * utime() is POSIX-standard but only supports 1s resolution and
	 * does not support fds or symlinks.
	 */
	struct utimbuf times;
	(void)fd; /* UNUSED */
	(void)name; /* UNUSED */
	(void)atime_nsec; /* UNUSED */
	(void)mtime_nsec; /* UNUSED */
	times.actime = atime;
	times.modtime = mtime;
	if (S_ISLNK(mode))
		return (ARCHIVE_OK);
	return (utime(name, &times));

#else
	/*
	 * We don't know how to set the time on this platform.
	 */
	(void)fd; /* UNUSED */
	(void)mode; /* UNUSED */
	(void)name; /* UNUSED */
	(void)atime_nsec; /* UNUSED */
	(void)mtime_nsec; /* UNUSED */
	return (ARCHIVE_WARN);
#endif
}

#ifdef F_SETTIMES
static int
set_time_tru64(int fd, int mode, const char *name,
    time_t atime, long atime_nsec,
    time_t mtime, long mtime_nsec,
    time_t ctime, long ctime_nsec)
{
	struct attr_timbuf tstamp;
	tstamp.atime.tv_sec = atime;
	tstamp.mtime.tv_sec = mtime;
	tstamp.ctime.tv_sec = ctime;
#if defined (__hpux) && defined (__ia64)
	tstamp.atime.tv_nsec = atime_nsec;
	tstamp.mtime.tv_nsec = mtime_nsec;
	tstamp.ctime.tv_nsec = ctime_nsec;
#else
	tstamp.atime.tv_usec = atime_nsec / 1000;
	tstamp.mtime.tv_usec = mtime_nsec / 1000;
	tstamp.ctime.tv_usec = ctime_nsec / 1000;
#endif
	return (fcntl(fd,F_SETTIMES,&tstamp));
}
#endif /* F_SETTIMES */

static int
set_times(struct archive_write_disk *a,
    int fd, int mode, const char *name,
    time_t atime, long atime_nanos,
    time_t birthtime, long birthtime_nanos,
    time_t mtime, long mtime_nanos,
    time_t cctime, long ctime_nanos)
{
	/* Note: set_time doesn't use libarchive return conventions!
	 * It uses syscall conventions.  So 0 here instead of ARCHIVE_OK. */
	int r1 = 0, r2 = 0;

#ifdef F_SETTIMES
	 /*
	 * on Tru64 try own fcntl first which can restore even the
	 * ctime, fall back to default code path below if it fails
	 * or if we are not running as root
	 */
	if (a->user_uid == 0 &&
	    set_time_tru64(fd, mode, name,
			   atime, atime_nanos, mtime,
			   mtime_nanos, cctime, ctime_nanos) == 0) {
		return (ARCHIVE_OK);
	}
#else /* Tru64 */
	(void)cctime; /* UNUSED */
	(void)ctime_nanos; /* UNUSED */
#endif /* Tru64 */

#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
	/*
	 * If you have struct stat.st_birthtime, we assume BSD
	 * birthtime semantics, in which {f,l,}utimes() updates
	 * birthtime to earliest mtime.  So we set the time twice,
	 * first using the birthtime, then using the mtime.  If
	 * birthtime == mtime, this isn't necessary, so we skip it.
	 * If birthtime > mtime, then this won't work, so we skip it.
	 */
	if (birthtime < mtime
	    || (birthtime == mtime && birthtime_nanos < mtime_nanos))
		r1 = set_time(fd, mode, name,
			      atime, atime_nanos,
			      birthtime, birthtime_nanos);
#else
	(void)birthtime; /* UNUSED */
	(void)birthtime_nanos; /* UNUSED */
#endif
	r2 = set_time(fd, mode, name,
		      atime, atime_nanos,
		      mtime, mtime_nanos);
	if (r1 != 0 || r2 != 0) {
		archive_set_error(&a->archive, errno,
				  ""Can't restore time"");
		return (ARCHIVE_WARN);
	}
	return (ARCHIVE_OK);
}

static int
set_times_from_entry(struct archive_write_disk *a)
{
	time_t atime, birthtime, mtime, cctime;
	long atime_nsec, birthtime_nsec, mtime_nsec, ctime_nsec;

	/* Suitable defaults. */
	atime = birthtime = mtime = cctime = a->start_time;
	atime_nsec = birthtime_nsec = mtime_nsec = ctime_nsec = 0;

	/* If no time was provided, we're done. */
	if (!archive_entry_atime_is_set(a->entry)
#if HAVE_STRUCT_STAT_ST_BIRTHTIME
	    && !archive_entry_birthtime_is_set(a->entry)
#endif
	    && !archive_entry_mtime_is_set(a->entry))
		return (ARCHIVE_OK);

	if (archive_entry_atime_is_set(a->entry)) {
		atime = archive_entry_atime(a->entry);
		atime_nsec = archive_entry_atime_nsec(a->entry);
	}
	if (archive_entry_birthtime_is_set(a->entry)) {
		birthtime = archive_entry_birthtime(a->entry);
		birthtime_nsec = archive_entry_birthtime_nsec(a->entry);
	}
	if (archive_entry_mtime_is_set(a->entry)) {
		mtime = archive_entry_mtime(a->entry);
		mtime_nsec = archive_entry_mtime_nsec(a->entry);
	}
	if (archive_entry_ctime_is_set(a->entry)) {
		cctime = archive_entry_ctime(a->entry);
		ctime_nsec = archive_entry_ctime_nsec(a->entry);
	}

	return set_times(a, a->fd, a->mode, a->name,
			 atime, atime_nsec,
			 birthtime, birthtime_nsec,
			 mtime, mtime_nsec,
			 cctime, ctime_nsec);
}

static int
set_mode(struct archive_write_disk *a, int mode)
{
	int r = ARCHIVE_OK;
	mode &= 07777; /* Strip off file type bits. */

	if (a->todo & TODO_SGID_CHECK) {
		/*
		 * If we don't know the GID is right, we must stat()
		 * to verify it.  We can't just check the GID of this
		 * process, since systems sometimes set GID from
		 * the enclosing dir or based on ACLs.
		 */
		if ((r = lazy_stat(a)) != ARCHIVE_OK)
			return (r);
		if (a->pst->st_gid != a->gid) {
			mode &= ~ S_ISGID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				/*
				 * This is only an error if you
				 * requested owner restore.  If you
				 * didn't, we'll try to restore
				 * sgid/suid, but won't consider it a
				 * problem if we can't.
				 */
				archive_set_error(&a->archive, -1,
				    ""Can't restore SGID bit"");
				r = ARCHIVE_WARN;
			}
		}
		/* While we're here, double-check the UID. */
		if (a->pst->st_uid != a->uid
		    && (a->todo & TODO_SUID)) {
			mode &= ~ S_ISUID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				archive_set_error(&a->archive, -1,
				    ""Can't restore SUID bit"");
				r = ARCHIVE_WARN;
			}
		}
		a->todo &= ~TODO_SGID_CHECK;
		a->todo &= ~TODO_SUID_CHECK;
	} else if (a->todo & TODO_SUID_CHECK) {
		/*
		 * If we don't know the UID is right, we can just check
		 * the user, since all systems set the file UID from
		 * the process UID.
		 */
		if (a->user_uid != a->uid) {
			mode &= ~ S_ISUID;
			if (a->flags & ARCHIVE_EXTRACT_OWNER) {
				archive_set_error(&a->archive, -1,
				    ""Can't make file SUID"");
				r = ARCHIVE_WARN;
			}
		}
		a->todo &= ~TODO_SUID_CHECK;
	}

	if (S_ISLNK(a->mode)) {
#ifdef HAVE_LCHMOD
		/*
		 * If this is a symlink, use lchmod().  If the
		 * platform doesn't support lchmod(), just skip it.  A
		 * platform that doesn't provide a way to set
		 * permissions on symlinks probably ignores
		 * permissions on symlinks, so a failure here has no
		 * impact.
		 */
		if (lchmod(a->name, mode) != 0) {
			switch (errno) {
			case ENOTSUP:
			case ENOSYS:
#if ENOTSUP != EOPNOTSUPP
			case EOPNOTSUPP:
#endif
				/*
				 * if lchmod is defined but the platform
				 * doesn't support it, silently ignore
				 * error
				 */
				break;
			default:
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
		}
#endif
	} else if (!S_ISDIR(a->mode)) {
		/*
		 * If it's not a symlink and not a dir, then use
		 * fchmod() or chmod(), depending on whether we have
		 * an fd.  Dirs get their perms set during the
		 * post-extract fixup, which is handled elsewhere.
		 */
#ifdef HAVE_FCHMOD
		if (a->fd >= 0) {
			if (fchmod(a->fd, mode) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
		} else
#endif
			/* If this platform lacks fchmod(), then
			 * we'll just use chmod(). */
			if (chmod(a->name, mode) != 0) {
				archive_set_error(&a->archive, errno,
				    ""Can't set permissions to 0%o"", (int)mode);
				r = ARCHIVE_WARN;
			}
	}
	return (r);
}

static int
set_fflags(struct archive_write_disk *a)
{
	struct fixup_entry *le;
	unsigned long	set, clear;
	int		r;
	int		critical_flags;
	mode_t		mode = archive_entry_mode(a->entry);

	/*
	 * Make 'critical_flags' hold all file flags that can't be
	 * immediately restored.  For example, on BSD systems,
	 * SF_IMMUTABLE prevents hardlinks from being created, so
	 * should not be set until after any hardlinks are created.  To
	 * preserve some semblance of portability, this uses #ifdef
	 * extensively.  Ugly, but it works.
	 *
	 * Yes, Virginia, this does create a security race.  It's mitigated
	 * somewhat by the practice of creating dirs 0700 until the extract
	 * is done, but it would be nice if we could do more than that.
	 * People restoring critical file systems should be wary of
	 * other programs that might try to muck with files as they're
	 * being restored.
	 */
	/* Hopefully, the compiler will optimize this mess into a constant. */
	critical_flags = 0;
#ifdef SF_IMMUTABLE
	critical_flags |= SF_IMMUTABLE;
#endif
#ifdef UF_IMMUTABLE
	critical_flags |= UF_IMMUTABLE;
#endif
#ifdef SF_APPEND
	critical_flags |= SF_APPEND;
#endif
#ifdef UF_APPEND
	critical_flags |= UF_APPEND;
#endif
#ifdef EXT2_APPEND_FL
	critical_flags |= EXT2_APPEND_FL;
#endif
#ifdef EXT2_IMMUTABLE_FL
	critical_flags |= EXT2_IMMUTABLE_FL;
#endif

	if (a->todo & TODO_FFLAGS) {
		archive_entry_fflags(a->entry, &set, &clear);

		/*
		 * The first test encourages the compiler to eliminate
		 * all of this if it's not necessary.
		 */
		if ((critical_flags != 0)  &&  (set & critical_flags)) {
			le = current_fixup(a, a->name);
			if (le == NULL)
				return (ARCHIVE_FATAL);
			le->fixup |= TODO_FFLAGS;
			le->fflags_set = set;
			/* Store the mode if it's not already there. */
			if ((le->fixup & TODO_MODE) == 0)
				le->mode = mode;
		} else {
			r = set_fflags_platform(a, a->fd,
			    a->name, mode, set, clear);
			if (r != ARCHIVE_OK)
				return (r);
		}
	}
	return (ARCHIVE_OK);
}

static int
clear_nochange_fflags(struct archive_write_disk *a)
{
	int		nochange_flags;
	mode_t		mode = archive_entry_mode(a->entry);

	/* Hopefully, the compiler will optimize this mess into a constant. */
	nochange_flags = 0;
#ifdef SF_IMMUTABLE
	nochange_flags |= SF_IMMUTABLE;
#endif
#ifdef UF_IMMUTABLE
	nochange_flags |= UF_IMMUTABLE;
#endif
#ifdef SF_APPEND
	nochange_flags |= SF_APPEND;
#endif
#ifdef UF_APPEND
	nochange_flags |= UF_APPEND;
#endif
#ifdef EXT2_APPEND_FL
	nochange_flags |= EXT2_APPEND_FL;
#endif
#ifdef EXT2_IMMUTABLE_FL
	nochange_flags |= EXT2_IMMUTABLE_FL;
#endif

	return (set_fflags_platform(a, a->fd, a->name, mode, 0, nochange_flags));
}


#if ( defined(HAVE_LCHFLAGS) || defined(HAVE_CHFLAGS) || defined(HAVE_FCHFLAGS) ) && defined(HAVE_STRUCT_STAT_ST_FLAGS)
/*
 * BSD reads flags using stat() and sets them with one of {f,l,}chflags()
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	int r;

	(void)mode; /* UNUSED */
	if (set == 0  && clear == 0)
		return (ARCHIVE_OK);

	/*
	 * XXX Is the stat here really necessary?  Or can I just use
	 * the 'set' flags directly?  In particular, I'm not sure
	 * about the correct approach if we're overwriting an existing
	 * file that already has flags on it. XXX
	 */
	if ((r = lazy_stat(a)) != ARCHIVE_OK)
		return (r);

	a->st.st_flags &= ~clear;
	a->st.st_flags |= set;
#ifdef HAVE_FCHFLAGS
	/* If platform has fchflags() and we were given an fd, use it. */
	if (fd >= 0 && fchflags(fd, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#endif
	/*
	 * If we can't use the fd to set the flags, we'll use the
	 * pathname to set flags.  We prefer lchflags() but will use
	 * chflags() if we must.
	 */
#ifdef HAVE_LCHFLAGS
	if (lchflags(name, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#elif defined(HAVE_CHFLAGS)
	if (S_ISLNK(a->st.st_mode)) {
		archive_set_error(&a->archive, errno,
		    ""Can't set file flags on symlink."");
		return (ARCHIVE_WARN);
	}
	if (chflags(name, a->st.st_flags) == 0)
		return (ARCHIVE_OK);
#endif
	archive_set_error(&a->archive, errno,
	    ""Failed to set file flags"");
	return (ARCHIVE_WARN);
}

#elif defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(HAVE_WORKING_EXT2_IOC_GETFLAGS)
/*
 * Linux uses ioctl() to read and write file flags.
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	int		 ret;
	int		 myfd = fd;
	int newflags, oldflags;
	int sf_mask = 0;

	if (set == 0  && clear == 0)
		return (ARCHIVE_OK);
	/* Only regular files and dirs can have flags. */
	if (!S_ISREG(mode) && !S_ISDIR(mode))
		return (ARCHIVE_OK);

	/* If we weren't given an fd, open it ourselves. */
	if (myfd < 0) {
		myfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);
		__archive_ensure_cloexec_flag(myfd);
	}
	if (myfd < 0)
		return (ARCHIVE_OK);

	/*
	 * Linux has no define for the flags that are only settable by
	 * the root user.  This code may seem a little complex, but
	 * there seem to be some Linux systems that lack these
	 * defines. (?)  The code below degrades reasonably gracefully
	 * if sf_mask is incomplete.
	 */
#ifdef EXT2_IMMUTABLE_FL
	sf_mask |= EXT2_IMMUTABLE_FL;
#endif
#ifdef EXT2_APPEND_FL
	sf_mask |= EXT2_APPEND_FL;
#endif
	/*
	 * XXX As above, this would be way simpler if we didn't have
	 * to read the current flags from disk. XXX
	 */
	ret = ARCHIVE_OK;

	/* Read the current file flags. */
	if (ioctl(myfd, EXT2_IOC_GETFLAGS, &oldflags) < 0)
		goto fail;

	/* Try setting the flags as given. */
	newflags = (oldflags & ~clear) | set;
	if (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)
		goto cleanup;
	if (errno != EPERM)
		goto fail;

	/* If we couldn't set all the flags, try again with a subset. */
	newflags &= ~sf_mask;
	oldflags &= sf_mask;
	newflags |= oldflags;
	if (ioctl(myfd, EXT2_IOC_SETFLAGS, &newflags) >= 0)
		goto cleanup;

	/* We couldn't set the flags, so report the failure. */
fail:
	archive_set_error(&a->archive, errno,
	    ""Failed to set file flags"");
	ret = ARCHIVE_WARN;
cleanup:
	if (fd < 0)
		close(myfd);
	return (ret);
}

#else

/*
 * Of course, some systems have neither BSD chflags() nor Linux' flags
 * support through ioctl().
 */
static int
set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,
    mode_t mode, unsigned long set, unsigned long clear)
{
	(void)a; /* UNUSED */
	(void)fd; /* UNUSED */
	(void)name; /* UNUSED */
	(void)mode; /* UNUSED */
	(void)set; /* UNUSED */
	(void)clear; /* UNUSED */
	return (ARCHIVE_OK);
}

#endif /* __linux */

#ifndef HAVE_COPYFILE_H
/* Default is to simply drop Mac extended metadata. */
static int
set_mac_metadata(struct archive_write_disk *a, const char *pathname,
		 const void *metadata, size_t metadata_size)
{
	(void)a; /* UNUSED */
	(void)pathname; /* UNUSED */
	(void)metadata; /* UNUSED */
	(void)metadata_size; /* UNUSED */
	return (ARCHIVE_OK);
}

static int
fixup_appledouble(struct archive_write_disk *a, const char *pathname)
{
	(void)a; /* UNUSED */
	(void)pathname; /* UNUSED */
	return (ARCHIVE_OK);
}
#else

/*
 * On Mac OS, we use copyfile() to unpack the metadata and
 * apply it to the target file.
 */

#if defined(HAVE_SYS_XATTR_H)
static int
copy_xattrs(struct archive_write_disk *a, int tmpfd, int dffd)
{
	ssize_t xattr_size;
	char *xattr_names = NULL, *xattr_val = NULL;
	int ret = ARCHIVE_OK, xattr_i;

	xattr_size = flistxattr(tmpfd, NULL, 0, 0);
	if (xattr_size == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read metadata(xattr)"");
		ret = ARCHIVE_WARN;
		goto exit_xattr;
	}
	xattr_names = malloc(xattr_size);
	if (xattr_names == NULL) {
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate memory for metadata(xattr)"");
		ret = ARCHIVE_FATAL;
		goto exit_xattr;
	}
	xattr_size = flistxattr(tmpfd, xattr_names, xattr_size, 0);
	if (xattr_size == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read metadata(xattr)"");
		ret = ARCHIVE_WARN;
		goto exit_xattr;
	}
	for (xattr_i = 0; xattr_i < xattr_size;
	    xattr_i += strlen(xattr_names + xattr_i) + 1) {
		char *xattr_val_saved;
		ssize_t s;
		int f;

		s = fgetxattr(tmpfd, xattr_names + xattr_i, NULL, 0, 0, 0);
		if (s == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
		xattr_val_saved = xattr_val;
		xattr_val = realloc(xattr_val, s);
		if (xattr_val == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			free(xattr_val_saved);
			goto exit_xattr;
		}
		s = fgetxattr(tmpfd, xattr_names + xattr_i, xattr_val, s, 0, 0);
		if (s == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
		f = fsetxattr(dffd, xattr_names + xattr_i, xattr_val, s, 0, 0);
		if (f == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to get metadata(xattr)"");
			ret = ARCHIVE_WARN;
			goto exit_xattr;
		}
	}
exit_xattr:
	free(xattr_names);
	free(xattr_val);
	return (ret);
}
#endif

static int
copy_acls(struct archive_write_disk *a, int tmpfd, int dffd)
{
	acl_t acl, dfacl = NULL;
	int acl_r, ret = ARCHIVE_OK;

	acl = acl_get_fd(tmpfd);
	if (acl == NULL) {
		if (errno == ENOENT)
			/* There are not any ACLs. */
			return (ret);
		archive_set_error(&a->archive, errno,
		    ""Failed to get metadata(acl)"");
		ret = ARCHIVE_WARN;
		goto exit_acl;
	}
	dfacl = acl_dup(acl);
	acl_r = acl_set_fd(dffd, dfacl);
	if (acl_r == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to get metadata(acl)"");
		ret = ARCHIVE_WARN;
		goto exit_acl;
	}
exit_acl:
	if (acl)
		acl_free(acl);
	if (dfacl)
		acl_free(dfacl);
	return (ret);
}

static int
create_tempdatafork(struct archive_write_disk *a, const char *pathname)
{
	struct archive_string tmpdatafork;
	int tmpfd;

	archive_string_init(&tmpdatafork);
	archive_strcpy(&tmpdatafork, ""tar.md.XXXXXX"");
	tmpfd = mkstemp(tmpdatafork.s);
	if (tmpfd < 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to mkstemp"");
		archive_string_free(&tmpdatafork);
		return (-1);
	}
	if (copyfile(pathname, tmpdatafork.s, 0,
	    COPYFILE_UNPACK | COPYFILE_NOFOLLOW
	    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {
		archive_set_error(&a->archive, errno,
		    ""Failed to restore metadata"");
		close(tmpfd);
		tmpfd = -1;
	}
	unlink(tmpdatafork.s);
	archive_string_free(&tmpdatafork);
	return (tmpfd);
}

static int
copy_metadata(struct archive_write_disk *a, const char *metadata,
    const char *datafork, int datafork_compressed)
{
	int ret = ARCHIVE_OK;

	if (datafork_compressed) {
		int dffd, tmpfd;

		tmpfd = create_tempdatafork(a, metadata);
		if (tmpfd == -1)
			return (ARCHIVE_WARN);

		/*
		 * Do not open the data fork compressed by HFS+ compression
		 * with at least a writing mode(O_RDWR or O_WRONLY). it
		 * makes the data fork uncompressed.
		 */
		dffd = open(datafork, 0);
		if (dffd == -1) {
			archive_set_error(&a->archive, errno,
			    ""Failed to open the data fork for metadata"");
			close(tmpfd);
			return (ARCHIVE_WARN);
		}

#if defined(HAVE_SYS_XATTR_H)
		ret = copy_xattrs(a, tmpfd, dffd);
		if (ret == ARCHIVE_OK)
#endif
			ret = copy_acls(a, tmpfd, dffd);
		close(tmpfd);
		close(dffd);
	} else {
		if (copyfile(metadata, datafork, 0,
		    COPYFILE_UNPACK | COPYFILE_NOFOLLOW
		    | COPYFILE_ACL | COPYFILE_XATTR) < 0) {
			archive_set_error(&a->archive, errno,
			    ""Failed to restore metadata"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}

static int
set_mac_metadata(struct archive_write_disk *a, const char *pathname,
		 const void *metadata, size_t metadata_size)
{
	struct archive_string tmp;
	ssize_t written;
	int fd;
	int ret = ARCHIVE_OK;

	/* This would be simpler if copyfile() could just accept the
	 * metadata as a block of memory; then we could sidestep this
	 * silly dance of writing the data to disk just so that
	 * copyfile() can read it back in again. */
	archive_string_init(&tmp);
	archive_strcpy(&tmp, pathname);
	archive_strcat(&tmp, "".XXXXXX"");
	fd = mkstemp(tmp.s);

	if (fd < 0) {
		archive_set_error(&a->archive, errno,
				  ""Failed to restore metadata"");
		archive_string_free(&tmp);
		return (ARCHIVE_WARN);
	}
	written = write(fd, metadata, metadata_size);
	close(fd);
	if ((size_t)written != metadata_size) {
		archive_set_error(&a->archive, errno,
				  ""Failed to restore metadata"");
		ret = ARCHIVE_WARN;
	} else {
		int compressed;

#if defined(UF_COMPRESSED)
		if ((a->todo & TODO_HFS_COMPRESSION) != 0 &&
		    (ret = lazy_stat(a)) == ARCHIVE_OK)
			compressed = a->st.st_flags & UF_COMPRESSED;
		else
#endif
			compressed = 0;
		ret = copy_metadata(a, tmp.s, pathname, compressed);
	}
	unlink(tmp.s);
	archive_string_free(&tmp);
	return (ret);
}

static int
fixup_appledouble(struct archive_write_disk *a, const char *pathname)
{
	char buff[8];
	struct stat st;
	const char *p;
	struct archive_string datafork;
	int fd = -1, ret = ARCHIVE_OK;

	archive_string_init(&datafork);
	/* Check if the current file name is a type of the resource
	 * fork file. */
	p = strrchr(pathname, '/');
	if (p == NULL)
		p = pathname;
	else
		p++;
	if (p[0] != '.' || p[1] != '_')
		goto skip_appledouble;

	/*
	 * Check if the data fork file exists.
	 *
	 * TODO: Check if this write disk object has handled it.
	 */
	archive_strncpy(&datafork, pathname, p - pathname);
	archive_strcat(&datafork, p + 2);
	if (lstat(datafork.s, &st) == -1 ||
	    (st.st_mode & AE_IFMT) != AE_IFREG)
		goto skip_appledouble;

	/*
	 * Check if the file is in the AppleDouble form.
	 */
	fd = open(pathname, O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(fd);
	if (fd == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to open a restoring file"");
		ret = ARCHIVE_WARN;
		goto skip_appledouble;
	}
	if (read(fd, buff, 8) == -1) {
		archive_set_error(&a->archive, errno,
		    ""Failed to read a restoring file"");
		close(fd);
		ret = ARCHIVE_WARN;
		goto skip_appledouble;
	}
	close(fd);
	/* Check AppleDouble Magic Code. */
	if (archive_be32dec(buff) != 0x00051607)
		goto skip_appledouble;
	/* Check AppleDouble Version. */
	if (archive_be32dec(buff+4) != 0x00020000)
		goto skip_appledouble;

	ret = copy_metadata(a, pathname, datafork.s,
#if defined(UF_COMPRESSED)
	    st.st_flags & UF_COMPRESSED);
#else
	    0);
#endif
	if (ret == ARCHIVE_OK) {
		unlink(pathname);
		ret = ARCHIVE_EOF;
	}
skip_appledouble:
	archive_string_free(&datafork);
	return (ret);
}
#endif

#if HAVE_LSETXATTR || HAVE_LSETEA
/*
 * Restore extended attributes -  Linux and AIX implementations:
 * AIX' ea interface is syntaxwise identical to the Linux xattr interface.
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL &&
				strncmp(name, ""xfsroot."", 8) != 0 &&
				strncmp(name, ""system."", 7) != 0) {
			int e;
#if HAVE_FSETXATTR
			if (a->fd >= 0)
				e = fsetxattr(a->fd, name, value, size, 0);
			else
#elif HAVE_FSETEA
			if (a->fd >= 0)
				e = fsetea(a->fd, name, value, size, 0);
			else
#endif
			{
#if HAVE_LSETXATTR
				e = lsetxattr(archive_entry_pathname(entry),
				    name, value, size, 0);
#elif HAVE_LSETEA
				e = lsetea(archive_entry_pathname(entry),
				    name, value, size, 0);
#endif
			}
			if (e == -1) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				ret = ARCHIVE_WARN;
			}
		} else {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Invalid extended attribute encountered"");
			ret = ARCHIVE_WARN;
		}
	}
	return (ret);
}
#elif HAVE_EXTATTR_SET_FILE && HAVE_DECL_EXTATTR_NAMESPACE_USER
/*
 * Restore extended attributes -  FreeBSD implementation
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	struct archive_entry *entry = a->entry;
	static int warning_done = 0;
	int ret = ARCHIVE_OK;
	int i = archive_entry_xattr_reset(entry);

	while (i--) {
		const char *name;
		const void *value;
		size_t size;
		archive_entry_xattr_next(entry, &name, &value, &size);
		if (name != NULL) {
			int e;
			int namespace;

			if (strncmp(name, ""user."", 5) == 0) {
				/* ""user."" attributes go to user namespace */
				name += 5;
				namespace = EXTATTR_NAMESPACE_USER;
			} else {
				/* Warn about other extended attributes. */
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Can't restore extended attribute ``%s''"",
				    name);
				ret = ARCHIVE_WARN;
				continue;
			}
			errno = 0;
#if HAVE_EXTATTR_SET_FD
			if (a->fd >= 0)
				e = extattr_set_fd(a->fd, namespace, name, value, size);
			else
#endif
			/* TODO: should we use extattr_set_link() instead? */
			{
				e = extattr_set_file(archive_entry_pathname(entry),
				    namespace, name, value, size);
			}
			if (e != (int)size) {
				if (errno == ENOTSUP || errno == ENOSYS) {
					if (!warning_done) {
						warning_done = 1;
						archive_set_error(&a->archive, errno,
						    ""Cannot restore extended ""
						    ""attributes on this file ""
						    ""system"");
					}
				} else {
					archive_set_error(&a->archive, errno,
					    ""Failed to set extended attribute"");
				}

				ret = ARCHIVE_WARN;
			}
		}
	}
	return (ret);
}
#else
/*
 * Restore extended attributes - stub implementation for unsupported systems
 */
static int
set_xattrs(struct archive_write_disk *a)
{
	static int warning_done = 0;

	/* If there aren't any extended attributes, then it's okay not
	 * to extract them, otherwise, issue a single warning. */
	if (archive_entry_xattr_count(a->entry) != 0 && !warning_done) {
		warning_done = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Cannot restore extended attributes on this system"");
		return (ARCHIVE_WARN);
	}
	/* Warning was already emitted; suppress further warnings. */
	return (ARCHIVE_OK);
}
#endif

/*
 * Test if file on disk is older than entry.
 */
static int
older(struct stat *st, struct archive_entry *entry)
{
	/* First, test the seconds and return if we have a definite answer. */
	/* Definitely older. */
	if (st->st_mtime < archive_entry_mtime(entry))
		return (1);
	/* Definitely younger. */
	if (st->st_mtime > archive_entry_mtime(entry))
		return (0);
	/* If this platform supports fractional seconds, try those. */
#if HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC
	/* Definitely older. */
	if (st->st_mtimespec.tv_nsec < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
	/* Definitely older. */
	if (st->st_mtim.tv_nsec < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIME_N
	/* older. */
	if (st->st_mtime_n < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_UMTIME
	/* older. */
	if (st->st_umtime * 1000 < archive_entry_mtime_nsec(entry))
		return (1);
#elif HAVE_STRUCT_STAT_ST_MTIME_USEC
	/* older. */
	if (st->st_mtime_usec * 1000 < archive_entry_mtime_nsec(entry))
		return (1);
#else
	/* This system doesn't have high-res timestamps. */
#endif
	/* Same age or newer, so not older. */
	return (0);
}

#endi",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_174.cpp,"[397, 19, 4, 2, 16, 3, 206, 4, 11, 4, 497, 6, 20, 0, 155, 6633, 0, 0, 231, 508, 39, 63, 65, 581, 0, 2, 0, 0, 233, 0, 545, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3061, 5, 2715, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 611, 0, 53, 0, 396, 366, 63, 0, 561, 250, 0, 750, 22, 1141, 296, 4, 35, 38, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_174.cpp,2463
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_236.cpp,2534,2807,2543,2817,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty "", ""pathname"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_175.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_175.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid empty pathname"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_175.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_175.cpp,8
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_236.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_236.cpp,2534,2807,2554,2828,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");","fsobj_error(a_eno, a_estr, ARCHIVE_ERRNO_MISC,
			    ""Path is "", ""absolute"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_176.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_176.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			                  ""Path is absolute"");
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_176.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_176.cpp,19
c206211af647dd1f7039da91c34c9c72e50aefdf,"LibArchive 2017-02-19 (100ee75a)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 100ee75a01f1f785fc681f616db49a33405f8bf3 (v3.3.0).",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_98.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_98.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_237.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_237.cpp,2580,2854,2583,2858,"archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");","fsobj_error(a_eno, a_estr,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains "", ""'..'"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_177.cpp,"{
						archive_set_error(&a->archive,
						    ARCHIVE_ERRNO_MISC,
						    ""Path contains '..'"");
						return (ARCHIVE_FAILED);
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_177.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_177.cpp,48
1df9d5f91944e0b5ba00815d55bb7dc545053b4c,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-12-22 (44b9b4d4)",[],Utilities/cmcurl/lib/socks_gssapi.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_104.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_104.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_104.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_247.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_247.cpp,134,135,150,152,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_178.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_178.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_178.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_178.cpp,49
4cc2908fdaaf1ab8afe5c2ae5dbb3401859a9aab,"curl 2016-12-22 (44b9b4d4)

Code extracted from:

    https://github.com/curl/curl.git

at commit 44b9b4d4f56d6f6de92c89636994c03984e9cd01 (curl-7_52_1).",[],lib/socks_gssapi.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_111.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_111.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_255.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_255.cpp,134,135,150,152,"snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);","snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->socks_proxy.host.name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_179.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_179.cpp,"{
    service.value = malloc(strlen(serviceptr) +strlen(conn->proxy.name)+2);
    if(!service.value)
      return CURLE_OUT_OF_MEMORY;
    service.length = strlen(serviceptr) +strlen(conn->proxy.name)+1;
    snprintf(service.value, service.length+1, ""%s@%s"",
             serviceptr, conn->proxy.name);

    gss_major_status = gss_import_name(&gss_minor_status, &service,
                                       GSS_C_NT_HOSTBASED_SERVICE, &server);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_179.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 43, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_179.cpp,49
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_117.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_268.cpp,1802,1809,1813,1820,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmCommandArgument_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_180.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_180.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_180.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_180.cpp,6
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_117.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_117.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_117.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_268.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_268.cpp,1802,1809,1828,1835,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmCommandArgument_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_181.cpp,"yy_fatal_error( ""cmCommandArgument_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_181.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_181.cpp,6
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_270.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_270.cpp,676,684,1097,1125,,"YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_182.cpp,"{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = yyg->yytext_ptr;
  int number_to_move, i;
  int ret_val;

  if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
    YY_FATAL_ERROR(
    ""fatal flex scanner internal error--end of buffer missed"" );

  if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
    { /* Don't try to fill the buffer, so this is an EOF. */
    if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
      {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
      }

    else
      {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
      }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

  else
    {
      size_t nuto_read =
      YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while ( nuto_read <= 0 )
      { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

      int yy_c_buf_p_offset =
        (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

      if ( b->yy_is_our_buffer )
        {
        int new_size = b->yy_buf_size * 2;

        if ( new_size <= 0 )
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
          /* Include room in for 2 EOB chars. */
          cmExpr_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
        }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = 0;

      if ( ! b->yy_ch_buf )
        YY_FATAL_ERROR(
        ""fatal error - scanner input buffer overflow"" );

      yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

      nuto_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
            number_to_move - 1;

      }

    if ( nuto_read > YY_READ_BUF_SIZE )
      nuto_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
      yyg->yy_n_chars, nuto_read );

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
    }

  if ( yyg->yy_n_chars == 0 )
    {
    if ( number_to_move == YY_MORE_ADJ )
      {
      ret_val = EOB_ACT_END_OF_FILE;
      cmExpr_yyrestart(yyin  ,yyscanner);
      }

    else
      {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
        YY_BUFFER_EOF_PENDING;
      }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  yyg->yy_n_chars += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

  yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_182.cpp,"[10, 1, 1, 0, 0, 0, 3, 0, 0, 0, 19, 0, 0, 0, 0, 198, 0, 0, 9, 10, 0, 0, 8, 20, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 0, 65, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 6, 0, 12, 10, 6, 0, 7, 0, 0, 23, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_182.cpp,116
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_270.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_270.cpp,676,684,1167,1227,,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_183.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_183.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_183.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_183.cpp,0
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_273.cpp,1709,1784,1720,1795,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmExpr_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_184.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_184.cpp,"yy_fatal_error( ""cmExpr_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_184.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_184.cpp,6
c5df1f165c7f8f1e31e3144d326c6836af2e678d,"Regenerate lexer source code

Revise the manual procedure in the `*Lexer.in.l` files.  Some of our
post-processing steps are no longer necessary with the current set of
supported compilers.  Some steps changed with newer versions of flex.

Then regenerate all lexers with flex version 2.6.1.",[],Source/cmExprLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_118.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_118.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_273.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_273.cpp,1709,1784,1735,1810,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmExpr_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_185.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_185.cpp,"yy_fatal_error( ""cmExpr_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_185.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_185.cpp,6
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_277.cpp,144,143,159,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_186.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_186.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_186.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_186.cpp,7
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_278.cpp,262,239,269,241,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_187.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_187.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_187.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_187.cpp,47
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_120.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_278.cpp,262,239,269,242,,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_188.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_188.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_188.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_188.cpp,47
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/formdata.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_121.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_121.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_121.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_279.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_279.cpp,906,914,911,920,"vsnprintf(s, sizeof(s), fmt, ap);","s = curl_mvaprintf(fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_189.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_189.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_189.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_189.cpp,7
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_122.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_122.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_122.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_280.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_280.cpp,4107,4103,4111,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_190.cpp,"{
  ssize_t bytes_written;
#define SBUF_SIZE 1024
  char s[SBUF_SIZE];
  size_t write_len;
  char *sptr=s;
  CURLcode result = CURLE_OK;
#ifdef HAVE_GSSAPI
  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;

  bytes_written=0;

  result = Curl_convert_to_network(conn->data, s, write_len);
  /* Curl_convert_to_network calls failf if unsuccessful */
  if(result)
    return result;

  for(;;) {
#ifdef HAVE_GSSAPI
    conn->data_prot = PROT_CMD;
#endif
    result = Curl_write(conn, conn->sock[FIRSTSOCKET], sptr, write_len,
                        &bytes_written);
#ifdef HAVE_GSSAPI
    DEBUGASSERT(data_sec > PROT_NONE && data_sec < PROT_LAST);
    conn->data_prot = data_sec;
#endif

    if(result)
      break;

    if(conn->data->set.verbose)
      Curl_debug(conn->data, CURLINFO_HEADER_OUT,
                 sptr, (size_t)bytes_written, conn);

    if(bytes_written != (ssize_t)write_len) {
      write_len -= bytes_written;
      sptr += bytes_written;
    }
    else
      break;
  }

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_190.cpp,"[4, 0, 1, 0, 2, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 99, 0, 0, 7, 7, 0, 0, 4, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 5, 4, 1, 0, 8, 0, 0, 14, 0, 23, 7, 1, 1, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_190.cpp,15
f8a1ba202f51e70510f12f46fe0633ea908d5144,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-11-02 (3c561c65)",[],Utilities/cmcurl/lib/version.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_127.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_127.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_127.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_285.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_285.cpp,111,111,115,115,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_191.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_191.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_191.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_191.cpp,39
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_287.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_287.cpp,144,143,159,-1,"snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_192.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_192.cpp,"{
    snprintf(buf, sizeof(buf), ""CHARSET=cp%u"", cp);
    putenv(buf);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_192.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_192.cpp,7
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_288.cpp,262,239,269,241,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));","f(Curl_resolver_global_init()) {
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_193.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_193.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_193.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_193.cpp,47
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_129.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_129.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_288.cpp,262,239,269,242,,"DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_194.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_194.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: resolver_global_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_194.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_194.cpp,47
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/formdata.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_130.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_130.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_130.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_289.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_289.cpp,906,914,911,920,"vsnprintf(s, sizeof(s), fmt, ap);","s = curl_mvaprintf(fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_195.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_195.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsnprintf(s, sizeof(s), fmt, ap);
  va_end(ap);

  return AddFormData(formp, FORM_DATA, s, 0, size);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_195.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_195.cpp,7
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_131.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_131.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_131.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_290.cpp,4106,4102,4110,-1,"write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_196.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_196.cpp,"{
  ssize_t bytes_written;
#define SBUF_SIZE 1024
  char s[SBUF_SIZE];
  size_t write_len;
  char *sptr=s;
  CURLcode result = CURLE_OK;
#ifdef HAVE_GSSAPI
  enum protection_level data_sec = conn->data_prot;
#endif

  va_list ap;
  va_start(ap, fmt);
  write_len = vsnprintf(s, SBUF_SIZE-3, fmt, ap);
  va_end(ap);

  strcpy(&s[write_len], ""\r\n""); /* append a trailing CRLF */
  write_len +=2;

  bytes_written=0;

  result = Curl_convert_to_network(conn->data, s, write_len);
  /* Curl_convert_to_network calls failf if unsuccessful */
  if(result)
    return result;

  for(;;) {
#ifdef HAVE_GSSAPI
    conn->data_prot = PROT_CMD;
#endif
    result = Curl_write(conn, conn->sock[FIRSTSOCKET], sptr, write_len,
                        &bytes_written);
#ifdef HAVE_GSSAPI
    DEBUGASSERT(data_sec > PROT_NONE && data_sec < PROT_LAST);
    conn->data_prot = data_sec;
#endif

    if(result)
      break;

    if(conn->data->set.verbose)
      Curl_debug(conn->data, CURLINFO_HEADER_OUT,
                 sptr, (size_t)bytes_written, conn);

    if(bytes_written != (ssize_t)write_len) {
      write_len -= bytes_written;
      sptr += bytes_written;
    }
    else
      break;
  }

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_196.cpp,"[4, 0, 1, 0, 2, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 99, 0, 0, 7, 7, 0, 0, 4, 4, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 5, 4, 1, 0, 8, 0, 0, 14, 0, 23, 7, 1, 1, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_196.cpp,15
93cc249f3dd7ecd621cd063e4c08bbdb54d971e8,"curl 2016-11-02 (3c561c65)

Code extracted from:

    https://github.com/curl/curl.git

at commit 3c561c657c2f0e553b19115a506592a8bbd744bc (curl-7_51_0).",[],lib/version.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_136.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_136.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_136.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_295.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_295.cpp,111,111,115,115,"len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));","len = snprintf(ptr, left, "" libidn2/%s"", idn2_check_version(NULL));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_197.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_197.cpp,"{
    len = snprintf(ptr, left, "" libidn/%s"", stringprep_check_version(NULL));
    left -= len;
    ptr += len;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_197.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_197.cpp,39
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_354.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_354.cpp,132,131,134,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_198.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_198.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_198.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_198.cpp,2
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_157.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_157.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_157.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_354.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_354.cpp,132,131,134,142,,"aprintf(""%s:%d"", hostname, conn->port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_199.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_199.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_199.cpp,2
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,168,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_200.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_200.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_200.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_200.cpp,5
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,277,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_201.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_201.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_201.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_201.cpp,3
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,474,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_202.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_202.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_202.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_202.cpp,31
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,636,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_203.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_203.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_203.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_203.cpp,55
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,669,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_204.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_204.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_204.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_204.cpp,88
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,692,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_205.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_205.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_205.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_205.cpp,111
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,722,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_206.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_206.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_206.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_206.cpp,141
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,725,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_207.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_207.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_207.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_207.cpp,144
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,921,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_208.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_208.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_208.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_208.cpp,25
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,945,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_209.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_209.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_209.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_209.cpp,49
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,956,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_210.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_210.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_210.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_210.cpp,60
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,979,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_211.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_211.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_211.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_211.cpp,83
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,985,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_212.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_212.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_212.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_212.cpp,89
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,999,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_213.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_213.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_213.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_213.cpp,103
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1008,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_214.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_214.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_214.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_214.cpp,112
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1040,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_215.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_215.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_215.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_215.cpp,144
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1063,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_216.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_216.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_216.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_216.cpp,167
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1081,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_217.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_217.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_217.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_217.cpp,185
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1091,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_218.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_218.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_218.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_218.cpp,195
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_159.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_159.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_356.cpp,56,57,1180,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_219.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_219.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_219.cpp,9
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_160.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_160.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_160.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_357.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_357.cpp,269,271,273,277,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_220.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_220.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_220.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_220.cpp,51
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_161.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_161.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_161.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_360.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_360.cpp,479,486,490,494,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_221.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_221.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_221.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_221.cpp,74
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_165.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_165.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_165.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_364.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_364.cpp,22,22,172,109,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_222.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_222.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_222.cpp,28
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_166.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_166.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_166.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_365.cpp,150,160,157,171,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_223.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_223.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_223.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_223.cpp,65
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_166.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_166.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_166.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_365.cpp,150,160,160,172,,"(""%s%s%s:%hu"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_224.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_224.cpp,"f(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_224.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_224.cpp,68
5bcbc3857fd9976389d8eee3bb54e352ea950aec,Merge branch 'update-curl' into release,[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_167.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_167.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_167.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_366.cpp,32,32,32,32,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_225.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_225.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_225.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_225.cpp,0
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_371.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_371.cpp,132,131,134,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_226.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_226.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_226.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_226.cpp,2
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_172.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_172.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_371.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_371.cpp,132,131,134,142,,"aprintf(""%s:%d"", hostname, conn->port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_227.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_227.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_227.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_227.cpp,2
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,168,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_228.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_228.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_228.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_228.cpp,5
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,277,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_229.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_229.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_229.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_229.cpp,3
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,474,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_230.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_230.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_230.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_230.cpp,31
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,636,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_231.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_231.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_231.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_231.cpp,55
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,669,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_232.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_232.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_232.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_232.cpp,88
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,692,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_233.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_233.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_233.cpp,111
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,722,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_234.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_234.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_234.cpp,141
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,725,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_235.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_235.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_235.cpp,144
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,921,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_236.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_236.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_236.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_236.cpp,25
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,945,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_237.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_237.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_237.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_237.cpp,49
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,956,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_238.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_238.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_238.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_238.cpp,60
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,979,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_239.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_239.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_239.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_239.cpp,83
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,985,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_240.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_240.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_240.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_240.cpp,89
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,999,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_241.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_241.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_241.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_241.cpp,103
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1008,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_242.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_242.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_242.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_242.cpp,112
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1040,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_243.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_243.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_243.cpp,144
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1063,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_244.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_244.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_244.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_244.cpp,167
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1081,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_245.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_245.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_245.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_245.cpp,185
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1091,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_246.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_246.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_246.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_246.cpp,195
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_174.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_174.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_373.cpp,56,57,1180,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_247.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_247.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_247.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_247.cpp,9
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_175.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_175.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_175.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_374.cpp,269,271,273,277,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_248.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_248.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_248.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_248.cpp,51
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_176.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_176.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_176.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_377.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_377.cpp,479,486,490,494,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_249.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_249.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_249.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_249.cpp,74
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_180.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_180.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_180.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_381.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_381.cpp,22,22,172,109,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_250.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_250.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_250.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_250.cpp,28
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_181.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_181.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_382.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_382.cpp,150,160,157,171,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_251.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_251.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_251.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_251.cpp,65
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_181.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_181.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_382.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_382.cpp,150,160,160,172,,"(""%s%s%s:%hu"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_252.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_252.cpp,"f(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_252.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_252.cpp,68
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/mprintf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_182.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_182.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_383.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_383.cpp,32,32,32,32,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_253.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_253.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_253.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_253.cpp,0
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_186.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_387.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_387.cpp,494,494,509,511,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_254.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_254.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_254.cpp,64
f53f4a8a2d215dac634effea575a27e000dfcb29,"Merge branch 'upstream-curl' into update-curl

* upstream-curl:
  curl 2016-08-03 (f2cb3a01)",[],Utilities/cmcurl/lib/tftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_186.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_186.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_186.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_387.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_387.cpp,494,494,517,519,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time);","snprintf(buf, sizeof(buf), ""%d"", state->retry_time);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_255.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_255.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_255.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_255.cpp,72
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_188.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_389.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_389.cpp,132,131,134,-1,"aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_256.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_256.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_256.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_256.cpp,2
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/conncache.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_188.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_188.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_188.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_389.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_389.cpp,132,131,134,142,,"aprintf(""%s:%d"", hostname, conn->port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_257.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_257.cpp,"{
  return aprintf(""%s:%d"",
                 conn->bits.proxy?conn->proxy.name:conn->host.name,
                 conn->localport);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_257.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 1, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_257.cpp,2
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,168,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_258.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_258.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_258.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_258.cpp,5
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,277,-1,"aprintf(""%s/%s"", service, host);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_259.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_259.cpp,"{
  /* Generate and return our SPN */
  return aprintf(""%s/%s"", service, host);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_259.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_259.cpp,3
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,474,-1,"response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_260.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_260.cpp,"{
  CURLcode result = CURLE_OK;
  size_t chlglen = 0;
  HMAC_context *ctxt;
  unsigned char digest[MD5_DIGEST_LEN];
  char *response;

  if(chlg)
    chlglen = strlen(chlg);

  /* Compute the digest using the password as the key */
  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
                        (const unsigned char *) passwdp,
                        curlx_uztoui(strlen(passwdp)));
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  /* Update the digest with the given challenge */
  if(chlglen > 0)
    Curl_HMAC_update(ctxt, (const unsigned char *) chlg,
                     curlx_uztoui(chlglen));

  /* Finalise the digest */
  Curl_HMAC_final(ctxt, digest);

  /* Generate the response */
  response = aprintf(
      ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
           userp, digest[0], digest[1], digest[2], digest[3], digest[4],
           digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
           digest[11], digest[12], digest[13], digest[14], digest[15]);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_260.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 5, 0, 0, 0, 2, 86, 0, 0, 5, 5, 0, 0, 2, 20, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 17, 0, 4, 4, 0, 0, 10, 0, 0, 7, 0, 36, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_260.cpp,31
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,636,-1,"snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_261.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_261.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_261.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_261.cpp,55
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,669,-1,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_262.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_262.cpp,"snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_262.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_262.cpp,88
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,692,-1,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_263.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_263.cpp,"snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_263.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_263.cpp,111
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,722,-1,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_264.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_264.cpp,"snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_264.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_264.cpp,141
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,725,-1,"response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_265.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_265.cpp,"{
  CURLcode result = CURLE_OK;
  size_t i;
  MD5_context *ctxt;
  char *response = NULL;
  unsigned char digest[MD5_DIGEST_LEN];
  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  char nonce[64];
  char realm[128];
  char algorithm[64];
  char qop_options[64];
  int qop_values;
  char cnonce[33];
  unsigned int entropy[4];
  char nonceCount[] = ""00000001"";
  char method[]     = ""AUTHENTICATE"";
  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  char *spn         = NULL;

  /* Decode the challange message */
  result = sasl_decode_digest_md5_message(chlg64, nonce, sizeof(nonce),
                                          realm, sizeof(realm),
                                          algorithm, sizeof(algorithm),
                                          qop_options, sizeof(qop_options));
  if(result)
    return result;

  /* We only support md5 sessions */
  if(strcmp(algorithm, ""md5-sess"") != 0)
    return CURLE_BAD_CONTENT_ENCODING;

  /* Get the qop-values from the qop-options */
  result = sasl_digest_get_qop_values(qop_options, &qop_values);
  if(result)
    return result;

  /* We only support auth quality-of-protection */
  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
    return CURLE_BAD_CONTENT_ENCODING;

  /* Generate 16 bytes of random data */
  entropy[0] = Curl_rand(data);
  entropy[1] = Curl_rand(data);
  entropy[2] = Curl_rand(data);
  entropy[3] = Curl_rand(data);

  /* Convert the random data into a 32 byte hex string */
  snprintf(cnonce, sizeof(cnonce), ""%08x%08x%08x%08x"",
           entropy[0], entropy[1], entropy[2], entropy[3]);

  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) userp,
                  curlx_uztoui(strlen(userp)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) realm,
                  curlx_uztoui(strlen(realm)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
                  curlx_uztoui(strlen(passwdp)));
  Curl_MD5_final(ctxt, digest);

  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt)
    return CURLE_OUT_OF_MEMORY;

  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_final(ctxt, digest);

  /* Convert calculated 16 octet hex into 32 bytes string */
  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA1_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate our SPN */
  spn = Curl_sasl_build_spn(service, realm);
  if(!spn)
    return CURLE_OUT_OF_MEMORY;

  /* Calculate H(A2) */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) method,
                  curlx_uztoui(strlen(method)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) spn,
                  curlx_uztoui(strlen(spn)));
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&HA2_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Now calculate the response hash */
  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  if(!ctxt) {
    free(spn);

    return CURLE_OUT_OF_MEMORY;
  }

  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
                  curlx_uztoui(strlen(nonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
                  curlx_uztoui(strlen(nonceCount)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
                  curlx_uztoui(strlen(cnonce)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);
  Curl_MD5_update(ctxt, (const unsigned char *) qop,
                  curlx_uztoui(strlen(qop)));
  Curl_MD5_update(ctxt, (const unsigned char *) "":"", 1);

  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  Curl_MD5_final(ctxt, digest);

  for(i = 0; i < MD5_DIGEST_LEN; i++)
    snprintf(&resp_hash_hex[2 * i], 3, ""%02x"", digest[i]);

  /* Generate the response */
  response = aprintf(""username=\""%s\"",realm=\""%s\"",nonce=\""%s\"",""
                     ""cnonce=\""%s\"",nc=\""%s\"",digest-uri=\""%s\"",response=%s,""
                     ""qop=%s"",
                     userp, realm, nonce,
                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  free(spn);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the response */
  result = Curl_base64_encode(data, response, 0, outptr, outlen);

  free(response);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_265.cpp,"[10, 0, 3, 0, 0, 0, 11, 0, 0, 0, 14, 0, 0, 0, 24, 357, 0, 0, 19, 19, 0, 0, 9, 63, 0, 0, 0, 0, 3, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 0, 276, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 27, 0, 13, 10, 0, 0, 77, 0, 0, 49, 0, 167, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_265.cpp,144
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,921,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_266.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_266.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_266.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_266.cpp,25
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,945,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_267.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_267.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_267.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_267.cpp,49
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,956,-1,"tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_268.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_268.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_268.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_268.cpp,60
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,979,-1,"md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_269.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_269.cpp,"{
  CURLcode result;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *userp_quoted;
  char *response = NULL;
  char *tmp = NULL;

  if(!digest->nc)
    digest->nc = 1;

  if(!digest->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));

    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                                &cnonce, &cnonce_sz);
    if(result)
      return result;

    digest->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, digest->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha1);

  if(digest->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, digest->nonce, digest->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    free(tmp);
    sasl_digest_md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  md5this = (unsigned char *)aprintf(""%s:%s"", request, uripath);

  if(digest->qop && Curl_raw_equal(digest->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, ha2);

  if(digest->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  free(md5this);
  sasl_digest_md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = sasl_digest_string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(digest->qop) {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }
  else {
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }
  free(userp_quoted);
  if(!response)
    return CURLE_OUT_OF_MEMORY;

  /* Add the optional fields */
  if(digest->opaque) {
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  if(digest->algorithm) {
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }

  /* Return the output */
  *outptr = response;
  *outlen = strlen(response);

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_269.cpp,"[18, 0, 0, 0, 0, 0, 10, 0, 0, 0, 21, 0, 0, 0, 0, 287, 0, 0, 13, 13, 0, 0, 5, 32, 0, 0, 0, 0, 6, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 180, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 5, 0, 18, 18, 2, 0, 42, 0, 0, 40, 0, 102, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_269.cpp,83
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,985,-1,"(""%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_270.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_270.cpp,"{
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    free(md5this);
    md5this = md5this2;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_270.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_270.cpp,89
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,999,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_271.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_271.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       digest->nc,
                                       digest->cnonce,
                                       digest->qop,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_271.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_271.cpp,103
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1008,-1,"md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_272.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_272.cpp,"{
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       digest->nonce,
                                       ha2);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_272.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_272.cpp,112
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1040,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_273.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_273.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""cnonce=\""%s\"", ""
                       ""nc=%08x, ""
                       ""qop=%s, ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       digest->cnonce,
                       digest->nc,
                       digest->qop,
                       request_digest);

    if(Curl_raw_equal(digest->qop, ""auth""))
      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
                       padded which tells to the server how many times you are
                       using the same nonce in the qop=auth mode */
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_273.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_273.cpp,144
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1063,-1,"response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_274.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_274.cpp,"{
    response = aprintf(""username=\""%s\"", ""
                       ""realm=\""%s\"", ""
                       ""nonce=\""%s\"", ""
                       ""uri=\""%s\"", ""
                       ""response=\""%s\"""",
                       userp_quoted,
                       digest->realm,
                       digest->nonce,
                       uripath,
                       request_digest);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_274.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_274.cpp,167
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1081,-1,"tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_275.cpp,"{
    /* Append the opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", response, digest->opaque);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_275.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_275.cpp,185
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1091,-1,"tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_276.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_276.cpp,"{
    /* Append the algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", response, digest->algorithm);
    free(response);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;

    response = tmp;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_276.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_276.cpp,195
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/curl_sasl.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_190.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_190.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_391.cpp,56,57,1180,-1,"xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_277.cpp,"{
  CURLcode result = CURLE_OK;
  char *xoauth = NULL;

  /* Generate the message */
  xoauth = aprintf(""user=%s\1auth=Bearer %s\1\1"", user, bearer);
  if(!xoauth)
    return CURLE_OUT_OF_MEMORY;

  /* Base64 encode the reply */
  result = Curl_base64_encode(data, xoauth, strlen(xoauth), outptr, outlen);

  free(xoauth);

  return result;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_277.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 23, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_277.cpp,9
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/easy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_191.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_191.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_191.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_392.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_392.cpp,269,271,273,277,"DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));","DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_278.cpp,"{
    DEBUGF(fprintf(stderr, ""Error: libssh2_init failed\n""));
    return CURLE_FAILED_INIT;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_278.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_278.cpp,51
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_192.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_192.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_192.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_395.cpp,479,486,490,494,"snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);","snprintf(buf, BUFSIZE-1,
             ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
             Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
             tm->tm_mday,
             Curl_month[tm->tm_mon],
             tm->tm_year + 1900,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_279.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_279.cpp,"{
      time_t filetime = (time_t)statbuf.st_mtime;
      struct tm buffer;
      const struct tm *tm = &buffer;
      result = Curl_gmtime(filetime, &buffer);
      if(result)
        return result;

      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      snprintf(buf, BUFSIZE-1,
               ""Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n"",
               Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
               tm->tm_mday,
               Curl_month[tm->tm_mon],
               tm->tm_year + 1900,
               tm->tm_hour,
               tm->tm_min,
               tm->tm_sec);
      result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_279.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 1, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_279.cpp,74
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_196.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_196.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_196.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_399.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_399.cpp,22,22,172,109,"userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded);","userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  base64);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_280.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_280.cpp,"struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
    &conn->data->state.negotiate;
  char *encoded = NULL;
  size_t len = 0;
  char *userp;
  CURLcode result;
  OM_uint32 discard_st;

  result = Curl_base64_encode(conn->data,
                              neg_ctx->output_token.value,
                              neg_ctx->output_token.length,
                              &encoded, &len);
  if(result) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return result;
  }

  if(!encoded || !len) {
    gss_release_buffer(&discard_st, &neg_ctx->output_token);
    neg_ctx->output_token.value = NULL;
    neg_ctx->output_token.length = 0;
    return CURLE_REMOTE_ACCESS_DENIED;
  }

  userp = aprintf(""%sAuthorization: Negotiate %s\r\n"", proxy ? ""Proxy-"" : """",
                  encoded)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_280.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 76, 0, 0, 6, 6, 0, 0, 3, 6, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 1, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 3, 3, 1, 0, 4, 0, 0, 8, 0, 12, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_280.cpp,28
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_197.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_197.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_197.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_400.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_400.cpp,150,160,157,171,"aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);","hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", ipv6_ip?""["":"""", hostname, ipv6_ip?""]"":"""",
                  remote_port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_281.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_281.cpp,"{
        char *host=(char *)"""";
        const char *proxyconn="""";
        const char *useragent="""";
        const char *http = (conn->proxytype == CURLPROXY_HTTP_1_0) ?
          ""1.0"" : ""1.1"";
        char *hostheader= /* host:port with IPv6 support */
          aprintf(""%s%s%s:%hu"", conn->bits.ipv6_ip?""["":"""",
                  hostname, conn->bits.ipv6_ip?""]"":"""",
                  remote_port);
        if(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }

        if(!Curl_checkProxyheaders(conn, ""Host:"")) {
          host = aprintf(""Host: %s\r\n"", hostheader);
          if(!host) {
            free(hostheader);
            Curl_add_buffer_free(req_buffer);
            return CURLE_OUT_OF_MEMORY;
          }
        }
        if(!Curl_checkProxyheaders(conn, ""Proxy-Connection:""))
          proxyconn = ""Proxy-Connection: Keep-Alive\r\n"";

        if(!Curl_checkProxyheaders(conn, ""User-Agent:"") &&
           data->set.str[STRING_USERAGENT])
          useragent = conn->allocptr.uagent;

        result =
          Curl_add_bufferf(req_buffer,
                           ""CONNECT %s HTTP/%s\r\n""
                           ""%s""  /* Host: */
                           ""%s""  /* Proxy-Authorization */
                           ""%s""  /* User-Agent */
                           ""%s"", /* Proxy-Connection */
                           hostheader,
                           http,
                           host,
                           conn->allocptr.proxyuserpwd?
                           conn->allocptr.proxyuserpwd:"""",
                           useragent,
                           proxyconn);

        if(host && *host)
          free(host);
        free(hostheader);

        if(!result)
          result = Curl_add_custom_headers(conn, TRUE, req_buffer);

        if(!result)
          /* CRLF terminate the request */
          result = Curl_add_bufferf(req_buffer, ""\r\n"");

        if(!result) {
          /* Send the connect request to the proxy */
          /* BLOCKING */
          result =
            Curl_add_buffer_send(req_buffer, conn,
                                 &data->info.request_size, 0, sockindex);
        }
        req_buffer = NULL;
        if(result)
          failf(data, ""Failed sending CONNECT to proxy"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_281.cpp,"[10, 0, 0, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 3, 103, 0, 0, 5, 5, 0, 0, 5, 24, 0, 0, 0, 0, 5, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41, 4, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 14, 4, 0, 15, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_281.cpp,65
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/http_proxy.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_197.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_197.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_197.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_400.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_400.cpp,150,160,160,172,,"(""%s%s%s:%hu"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_282.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_282.cpp,"f(!hostheader) {
          Curl_add_buffer_free(req_buffer);
          return CURLE_OUT_OF_MEMORY;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_282.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_282.cpp,68
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/mprintf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_198.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_198.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_198.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_401.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_401.cpp,32,32,32,32,"the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at http://daniel.haxx.se/trio/
 */;","the project that
 * took on from here is named 'Trio' and you find more details on the trio web
 * page at https://daniel.haxx.se/projects/trio/
 */;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_283.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_283.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_283.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_283.cpp,0
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_202.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_202.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_202.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_405.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_405.cpp,494,494,509,511,"snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );","snprintf(buf, sizeof(buf), ""%d"", state->requested_blksize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_284.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_284.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_284.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_284.cpp,64
202adcfe056681109fe61569ecdb3bd69f0b4f97,"curl 2016-08-03 (f2cb3a01)

Code extracted from:

    https://github.com/bagder/curl.git

at commit f2cb3a01192d36395d16acec6cdb93446ca6fd45 (curl-7_50_1).",[],lib/tftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_202.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_202.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_202.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_405.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_405.cpp,494,494,517,519,"snprintf( buf, sizeof(buf), ""%d"", state->retry_time);","snprintf(buf, sizeof(buf), ""%d"", state->retry_time);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_285.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_285.cpp,"{

  case TFTP_EVENT_INIT:    /* Send the first packet out */
  case TFTP_EVENT_TIMEOUT: /* Resend the first packet out */
    /* Increment the retry counter, quit if over the limit */
    state->retries++;
    if(state->retries>state->retry_max) {
      state->error = TFTP_ERR_NORESPONSE;
      state->state = TFTP_STATE_FIN;
      return result;
    }

    if(data->set.upload) {
      /* If we are uploading, send an WRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
      state->conn->data->req.upload_fromhere =
        (char *)state->spacket.data+4;
      if(data->state.infilesize != -1)
        Curl_pgrsSetUploadSize(data, data->state.infilesize);
    }
    else {
      /* If we are downloading, send an RRQ */
      setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
    }
    /* As RFC3617 describes the separator slash is not actually part of the
       file name so we skip the always-present first letter of the path
       string. */
    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                  NULL);
    if(!filename)
      return CURLE_OUT_OF_MEMORY;

    snprintf((char *)state->spacket.data+2,
             state->blksize,
             ""%s%c%s%c"", filename, '\0',  mode, '\0');
    sbytes = 4 + strlen(filename) + strlen(mode);

    /* add tsize option */
    if(data->set.upload && (data->state.infilesize != -1))
      snprintf(buf, sizeof(buf), ""%"" CURL_FORMAT_CURL_OFF_T,
               data->state.infilesize);
    else
      strcpy(buf, ""0""); /* the destination is large enough */

    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_TSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf);
    /* add blksize option */
    snprintf( buf, sizeof(buf), ""%d"", state->requested_blksize );
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_BLKSIZE);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* add timeout option */
    snprintf( buf, sizeof(buf), ""%d"", state->retry_time);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes,
                              TFTP_OPTION_INTERVAL);
    sbytes += tftp_option_add(state, sbytes,
                              (char *)state->spacket.data+sbytes, buf );

    /* the typecase for the 3rd argument is mostly for systems that do
       not have a size_t argument, like older unixes that want an 'int' */
    senddata = sendto(state->sockfd, (void *)state->spacket.data,
                      (SEND_TYPE_ARG3)sbytes, 0,
                      state->conn->ip_addr->ai_addr,
                      state->conn->ip_addr->ai_addrlen);
    if(senddata != (ssize_t)sbytes) {
      failf(data, ""%s"", Curl_strerror(state->conn, SOCKERRNO));
    }
    free(filename);
    break;

  case TFTP_EVENT_OACK:
    if(data->set.upload) {
      result = tftp_connect_for_tx(state, event);
    }
    else {
      result = tftp_connect_for_rx(state, event);
    }
    break;

  case TFTP_EVENT_ACK: /* Connected for transmit */
    result = tftp_connect_for_tx(state, event);
    break;

  case TFTP_EVENT_DATA: /* Connected for receive */
    result = tftp_connect_for_rx(state, event);
    break;

  case TFTP_EVENT_ERROR:
    state->state = TFTP_STATE_FIN;
    break;

  default:
    failf(state->conn->data, ""tftp_send_first: internal error"");
    break;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_285.cpp,"[7, 0, 0, 0, 6, 0, 2, 0, 6, 1, 11, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 127, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 7, 7, 3, 0, 29, 0, 0, 29, 0, 82, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_285.cpp,72
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_211.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_415.cpp,383,405,446,-1,"fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_286.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_286.cpp,"{
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_286.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_286.cpp,424
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_211.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_415.cpp,383,405,450,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_287.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_287.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_287.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_287.cpp,428
fb4791b37ccea1f38b8625b31df952408ab942f3,"cmCoreTryCompile: Refactor forwarding of variables to test project

De-duplicate the logic that constructs the cmake `-D` flag used to pass
variables into the test project cache.  Also subsume variables that were
propagated by generating `set()` commands in the project and pass them
as cache entries instead.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_211.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_211.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_415.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_415.cpp,383,405,454,-1,"fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_288.cpp,"{
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_288.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_288.cpp,432
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_212.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_417.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_417.cpp,1197,1213,1542,1588,,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_289.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_289.cpp,"line 2 ""cmListFileLexer.c""

#line 4 ""cmListFileLexer.c""

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The ""const"" storage-class-modifier is valid. */
#define YY_USE_CONST

#else   /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif  /* defined (__STDC__) */
#endif  /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning ""start processing a new file"". */
#define YY_NEW_FILE cmListFileLexer_yyrestart(yyin ,yyscanner )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE cmListFileLexer_yylex.
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)

/* Return all but the first ""n"" matched characters back to the input stream. */
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                *yy_cp = yyg->yy_hold_char; \
                YY_RESTORE_YY_MORE_OFFSET \
                yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
                YY_DO_BEFORE_ACTION; /* set up yytext again */ \
                } \
        while ( 0 )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
        {
        FILE *yy_input_file;

        char *yy_ch_buf;                /* input buffer */
        char *yy_buf_pos;               /* current position in input buffer */

        /* Size of input buffer in bytes, not including room for EOB
         * characters.
         */
        yy_size_t yy_buf_size;

        /* Number of characters read into yy_ch_buf, not including EOB
         * characters.
         */
        int yy_n_chars;

        /* Whether we ""own"" the buffer - i.e., we know we created it,
         * and can realloc() it to grow it, and should free() it to
         * delete it.
         */
        int yy_is_our_buffer;

        /* Whether this is an ""interactive"" input source; if so, and
         * if we're using stdio for input, then we want to use getc()
         * instead of fread(), to make sure we stop fetching input after
         * each newline.
         */
        int yy_is_interactive;

        /* Whether we're considered to be at the beginning of a line.
         * If so, '^' rules will be active on the next match, otherwise
         * not.
         */
        int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

        /* Whether to try to fill the input buffer when we reach the
         * end of it.
         */
        int yy_fill_buffer;

        int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
        /* When an EOF's been seen but there's still some text to process
         * then we mark the buffer as YY_EOF_PENDING, to indicate that we
         * shouldn't try reading from the input source any more.  We might
         * still have a bunch of tokens to match, though, because of
         * possible backing-up.
         *
         * When we actually see the EOF, we change the status to ""new""
         * (via cmListFileLexer_yyrestart()), so that the user can continue scanning by
         * just pointing yyin at a new input file.
         */
#define YY_BUFFER_EOF_PENDING 2

        };
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * ""scanner state"".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void cmListFileLexer_yyrestart (FILE *input_file ,yyscan_t yyscanner );
void cmListFileLexer_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
YY_BUFFER_STATE cmListFileLexer_yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
void cmListFileLexer_yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
void cmListFileLexer_yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
void cmListFileLexer_yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner );

static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner );
static void cmListFileLexer_yy_load_buffer_state (yyscan_t yyscanner );
static void cmListFileLexer_yy_init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );

#define YY_FLUSH_BUFFER cmListFileLexer_yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)

YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
YY_BUFFER_STATE cmListFileLexer_yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes (yyconst char *bytes,int len ,yyscan_t yyscanner );

void *cmListFileLexer_yyalloc (yy_size_t ,yyscan_t yyscanner );
void *cmListFileLexer_yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
void cmListFileLexer_yyfree (void * ,yyscan_t yyscanner );

#define yy_new_buffer cmListFileLexer_yy_create_buffer

#define yy_set_interactive(is_interactive) \
        { \
        if ( ! YY_CURRENT_BUFFER ){ \
        cmListFileLexer_yyensure_buffer_stack (yyscanner); \
                YY_CURRENT_BUFFER_LVALUE =    \
            cmListFileLexer_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
        } \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
        }

#define yy_set_bol(at_bol) \
        { \
        if ( ! YY_CURRENT_BUFFER ){\
        cmListFileLexer_yyensure_buffer_stack (yyscanner); \
                YY_CURRENT_BUFFER_LVALUE =    \
            cmListFileLexer_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
        } \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
        }

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define cmListFileLexer_yywrap(n) 1
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
static int yy_get_next_buffer (yyscan_t yyscanner );
static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
        yyg->yytext_ptr = yy_bp; \
        yyleng = (size_t) (yy_cp - yy_bp); \
        yyg->yy_hold_char = *yy_cp; \
        *yy_cp = '\0'; \
        yyg->yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 24
#define YY_END_OF_BUFFER 25
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
        {
        flex_int32_t yy_verify;
        flex_int32_t yy_nxt;
        };
static yyconst flex_int16_t yy_accept[77] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,    4,    4,
       25,   13,   22,    1,   16,    3,   13,    5,    6,    7,
       15,   23,   17,   19,   20,   21,   10,   11,    8,   12,
        9,    4,   13,    0,   13,    0,   22,    0,    0,    7,
       13,    0,   13,    0,    2,    0,   13,   17,    0,   18,
       10,    8,    4,    0,   14,    0,    0,    0,    0,   14,
        0,    0,   14,    0,    0,    0,    2,   14,    0,    0,
        0,    0,    0,    0,    0,    0
    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    5,    6,    7,    1,    1,    1,    8,
        9,    1,    1,    1,    1,    1,    1,   10,   10,   10,
       10,   10,   10,   10,   10,   10,   10,    1,    1,    1,
       11,    1,    1,    1,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       13,   14,   15,    1,   12,    1,   12,   12,   12,   12,

       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
       12,   12,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[16] =
    {   0,
        1,    1,    2,    3,    4,    3,    1,    3,    5,    6,
        1,    6,    1,    1,    7
    } ;

static yyconst flex_int16_t yy_base[95] =
    {   0,
        0,    0,   13,   25,   14,   16,   17,   18,   90,   88,
       88,   39,   20,  237,  237,   74,   78,  237,  237,   13,
       54,    0,   71,  237,  237,   31,    0,  237,   73,  237,
      237,    0,    0,   65,   75,    0,   33,   30,   72,    0,
        0,   75,   70,    0,   74,    0,    0,   62,   70,  237,
        0,   63,    0,   85,   99,   65,  111,   62,   34,    0,
       54,  116,    0,   54,  127,   51,  237,   50,    0,   48,
       47,   39,   33,   29,   17,  237,  136,  143,  150,  157,
      164,  171,  178,  184,  191,  198,  201,  207,  214,  217,
      219,  225,  228,  230

    } ;

static yyconst flex_int16_t yy_def[95] =
    {   0,
       76,    1,   77,   77,   78,   78,   79,   79,   80,   80,
       76,   76,   76,   76,   76,   76,   12,   76,   76,   12,
       76,   81,   82,   76,   76,   82,   83,   76,   76,   76,
       76,   84,   12,   85,   12,   86,   76,   76,   87,   20,
       12,   88,   12,   21,   76,   89,   12,   82,   82,   76,
       83,   76,   84,   85,   76,   54,   85,   90,   76,   55,
       87,   88,   55,   62,   88,   91,   76,   55,   92,   93,
       90,   94,   91,   93,   94,    0,   76,   76,   76,   76,
       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
       76,   76,   76,   76

    } ;

static yyconst flex_int16_t yy_nxt[253] =
    {   0,
       12,   13,   14,   13,   15,   16,   17,   18,   19,   12,
       12,   20,   21,   22,   12,   24,   28,   25,   28,   28,
       28,   37,   40,   37,   40,   62,   26,   24,   29,   25,
       29,   31,   31,   50,   37,   48,   37,   54,   26,   33,
       59,   63,   45,   34,   59,   35,   45,   62,   33,   33,
       33,   33,   36,   33,   41,   55,   54,   58,   42,   63,
       43,   72,   60,   41,   44,   41,   45,   46,   41,   55,
       55,   56,   70,   52,   48,   49,   67,   66,   57,   63,
       60,   64,   58,   52,   49,   39,   38,   76,   65,   55,
       14,   56,   14,   76,   76,   76,   76,   76,   57,   55,

       76,   76,   76,   34,   76,   68,   76,   76,   55,   55,
       55,   55,   69,   55,   54,   76,   54,   76,   54,   54,
       63,   76,   64,   76,   76,   76,   76,   76,   76,   65,
       62,   76,   62,   76,   62,   62,   23,   23,   23,   23,
       23,   23,   23,   27,   27,   27,   27,   27,   27,   27,
       30,   30,   30,   30,   30,   30,   30,   32,   32,   32,
       32,   32,   32,   32,   47,   76,   47,   47,   47,   47,
       47,   48,   76,   48,   76,   48,   48,   48,   51,   76,
       51,   51,   51,   51,   53,   76,   53,   53,   53,   53,
       53,   54,   76,   76,   54,   76,   54,   54,   33,   76,

       33,   33,   33,   33,   33,   61,   61,   62,   76,   76,
       62,   76,   62,   62,   41,   76,   41,   41,   41,   41,
       41,   71,   71,   73,   73,   55,   76,   55,   55,   55,
       55,   55,   74,   74,   75,   75,   11,   76,   76,   76,
       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
       76,   76
    } ;

static yyconst flex_int16_t yy_chk[253] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    3,    5,    3,    6,    7,
        8,   13,   20,   13,   20,   75,    3,    4,    5,    4,
        6,    7,    8,   26,   37,   26,   37,   74,    4,   12,
       38,   73,   38,   12,   59,   12,   59,   72,   12,   12,
       12,   12,   12,   12,   21,   71,   70,   68,   21,   66,
       21,   64,   61,   21,   21,   21,   21,   21,   21,   34,
       58,   34,   56,   52,   49,   48,   45,   43,   34,   42,
       39,   42,   35,   29,   23,   17,   16,   11,   42,   54,
       10,   54,    9,    0,    0,    0,    0,    0,   54,   55,

        0,    0,    0,   55,    0,   55,    0,    0,   55,   55,
       55,   55,   55,   55,   57,    0,   57,    0,   57,   57,
       62,    0,   62,    0,    0,    0,    0,    0,    0,   62,
       65,    0,   65,    0,   65,   65,   77,   77,   77,   77,
       77,   77,   77,   78,   78,   78,   78,   78,   78,   78,
       79,   79,   79,   79,   79,   79,   79,   80,   80,   80,
       80,   80,   80,   80,   81,    0,   81,   81,   81,   81,
       81,   82,    0,   82,    0,   82,   82,   82,   83,    0,
       83,   83,   83,   83,   84,    0,   84,   84,   84,   84,
       84,   85,    0,    0,   85,    0,   85,   85,   86,    0,

       86,   86,   86,   86,   86,   87,   87,   88,    0,    0,
       88,    0,   88,   88,   89,    0,   89,   89,   89,   89,
       89,   90,   90,   91,   91,   92,    0,   92,   92,   92,
       92,   92,   93,   93,   94,   94,   76,   76,   76,   76,
       76,   76,   76,   76,   76,   76,   76,   76,   76,   76,
       76,   76
    } ;

/* Table of booleans, true if rule could match eol. */
static yyconst flex_int32_t yy_rule_can_match_eol[25] =
    {   0,
1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1,
    0, 0, 0, 0, 0,     };

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 ""cmListFileLexer.in.l""
#line 2 ""cmListFileLexer.in.l""
/*============================================================================
  CMake - Cross Platform Makefile Generator
  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium

  Distributed under the OSI-approved BSD License (the ""License"");
  see accompanying file Copyright.txt for details.

  This software is distributed WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the License for more information.
============================================================================*/
/*

This file must be translated to C and modified to build everywhere.

Run flex like this:

  flex --prefix=cmListFileLexer_yy -ocmListFileLexer.c cmListFileLexer.in.l

Modify cmListFileLexer.c:
  - remove TABs
  - remove use of the 'register' storage class specifier
  - remove the yyunput function
  - add a statement ""(void)yyscanner;"" to the top of these methods:
      yy_fatal_error, cmListFileLexer_yyalloc, cmListFileLexer_yyrealloc, cmListFileLexer_yyfree
  - remove statement ""yyscanner = NULL;"" from cmListFileLexer_yylex_destroy
  - remove all YY_BREAK lines occurring right after return statements
  - remove the isatty forward declaration

*/

#include ""cmStandardLexer.h""
#ifdef WIN32
#include <cmsys/Encoding.h>
#endif

/* Setup the proper cmListFileLexer_yylex declaration.  */
#define YY_EXTRA_TYPE cmListFileLexer*
#define YY_DECL int cmListFileLexer_yylex (yyscan_t yyscanner, cmListFileLexer* lexer)

#include ""cmListFileLexer.h""

/*--------------------------------------------------------------------------*/
struct cmListFileLexer_s
{
  cmListFileLexer_Token token;
  int bracket;
  int comment;
  int line;
  int column;
  int size;
  FILE* file;
  size_t cr;
  char* string_buffer;
  char* string_position;
  int string_left;
  yyscan_t scanner;
};

static void cmListFileLexerSetToken(cmListFileLexer* lexer, const char* text,
                                    int length);
static void cmListFileLexerAppend(cmListFileLexer* lexer, const char* text,
                                  int length);
static int cmListFileLexerInput(cmListFileLexer* lexer, char* buffer,
                                size_t bufferSize);
static void cmListFileLexerInit(cmListFileLexer* lexer);
static void cmListFileLexerDestroy(cmListFileLexer* lexer);

/* Replace the lexer input function.  */
#undef YY_INPUT
#define YY_INPUT(buf, result, max_size) \
  { result = cmListFileLexerInput(cmListFileLexer_yyget_extra(yyscanner), buf, max_size); }

/*--------------------------------------------------------------------------*/




#line 628 ""cmListFileLexer.c""

#define INITIAL 0
#define STRING 1
#define BRACKET 2
#define BRACKETEND 3
#define COMMENT 4

#ifndef YY_NO_UNISTD_H
/* Special case for ""unistd.h"", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top; /**< index of top of stack. */
    size_t yy_buffer_stack_max; /**< capacity of stack. */
    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char* yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    }; /* end struct yyguts_t */

static int yy_init_globals (yyscan_t yyscanner );

int cmListFileLexer_yylex_init (yyscan_t* scanner);

int cmListFileLexer_yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int cmListFileLexer_yylex_destroy (yyscan_t yyscanner );

int cmListFileLexer_yyget_debug (yyscan_t yyscanner );

void cmListFileLexer_yyset_debug (int debug_flag ,yyscan_t yyscanner );

YY_EXTRA_TYPE cmListFileLexer_yyget_extra (yyscan_t yyscanner );

void cmListFileLexer_yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );

FILE *cmListFileLexer_yyget_in (yyscan_t yyscanner );

void cmListFileLexer_yyset_in  (FILE * in_str ,yyscan_t yyscanner );

FILE *cmListFileLexer_yyget_out (yyscan_t yyscanner );

void cmListFileLexer_yyset_out  (FILE * out_str ,yyscan_t yyscanner );

int cmListFileLexer_yyget_leng (yyscan_t yyscanner );

char *cmListFileLexer_yyget_text (yyscan_t yyscanner );

int cmListFileLexer_yyget_lineno (yyscan_t yyscanner );

void cmListFileLexer_yyset_lineno (int line_number ,yyscan_t yyscanner );

int cmListFileLexer_yyget_column  (yyscan_t yyscanner );

void cmListFileLexer_yyset_column (int column_no ,yyscan_t yyscanner );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern ""C"" int cmListFileLexer_yywrap (yyscan_t yyscanner );
#else
extern int cmListFileLexer_yywrap (yyscan_t yyscanner );
#endif
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (yyscan_t yyscanner );
#else
static int input (yyscan_t yyscanner );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into ""buf"".  number of characters read, or YY_NULL,
 * is returned in ""result"".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
        if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
                { \
                int c = '*'; \
                size_t n; \
                for ( n = 0; n < max_size && \
                             (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
                        buf[n] = (char) c; \
                if ( c == '\n' ) \
                        buf[n++] = (char) c; \
                if ( c == EOF && ferror( yyin ) ) \
                        YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                result = n; \
                } \
        else \
                { \
                errno=0; \
                while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
                        { \
                        if( errno != EINTR) \
                                { \
                                YY_FATAL_ERROR( ""input in flex scanner failed"" ); \
                                break; \
                                } \
                        errno=0; \
                        clearerr(yyin); \
                        } \
                }\
\

#endif

/* No semi-colon after return; correct usage is to write ""yyterminate();"" -
 * we don't want an extra ';' after the ""return"" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int cmListFileLexer_yylex (yyscan_t yyscanner);

#define YY_DECL int cmListFileLexer_yylex (yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
        YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
        yy_state_type yy_current_state;
        char *yy_cp, *yy_bp;
        int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

#line 91 ""cmListFileLexer.in.l""


#line 865 ""cmListFileLexer.c""

        if ( !yyg->yy_init )
                {
                yyg->yy_init = 1;

#ifdef YY_USER_INIT
                YY_USER_INIT;
#endif

                if ( ! yyg->yy_start )
                        yyg->yy_start = 1;      /* first start state */

                if ( ! yyin )
                        yyin = stdin;

                if ( ! yyout )
                        yyout = stdout;

                if ( ! YY_CURRENT_BUFFER ) {
                        cmListFileLexer_yyensure_buffer_stack (yyscanner);
                        YY_CURRENT_BUFFER_LVALUE =
                                cmListFileLexer_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
                }

                cmListFileLexer_yy_load_buffer_state(yyscanner );
                }

        while ( 1 )             /* loops until end-of-file is reached */
                {
                yy_cp = yyg->yy_c_buf_p;

                /* Support of yytext. */
                *yy_cp = yyg->yy_hold_char;

                /* yy_bp points to the position in yy_ch_buf of the start of
                 * the current run.
                 */
                yy_bp = yy_cp;

                yy_current_state = yyg->yy_start;
yy_match:
                do
                        {
                        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                        if ( yy_accept[yy_current_state] )
                                {
                                yyg->yy_last_accepting_state = yy_current_state;
                                yyg->yy_last_accepting_cpos = yy_cp;
                                }
                        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                                {
                                yy_current_state = (int) yy_def[yy_current_state];
                                if ( yy_current_state >= 77 )
                                        yy_c = yy_meta[(unsigned int) yy_c];
                                }
                        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                        ++yy_cp;
                        }
                while ( yy_base[yy_current_state] != 237 );

yy_find_action:
                yy_act = yy_accept[yy_current_state];
                if ( yy_act == 0 )
                        { /* have to back up */
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        yy_act = yy_accept[yy_current_state];
                        }

                YY_DO_BEFORE_ACTION;

                if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
                        {
                        int yyl;
                        for ( yyl = 0; yyl < yyleng; ++yyl )
                                if ( yytext[yyl] == '\n' )

    do{ yylineno++;
        yycolumn=0;
    }while(0)
;
                        }

do_action:      /* This label is used only to access EOF actions. */

                switch ( yy_act )
        { /* beginning of action switch */
                        case 0: /* must back up */
                        /* undo the effects of YY_DO_BEFORE_ACTION */
                        *yy_cp = yyg->yy_hold_char;
                        yy_cp = yyg->yy_last_accepting_cpos;
                        yy_current_state = yyg->yy_last_accepting_state;
                        goto yy_find_action;

case 1:
/* rule 1 can match eol */
YY_RULE_SETUP
#line 93 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_Newline;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  ++lexer->line;
  lexer->column = 1;
  BEGIN(INITIAL);
  return 1;
}
case 2:
/* rule 2 can match eol */
YY_RULE_SETUP
#line 102 ""cmListFileLexer.in.l""
{
  const char* bracket = yytext;
  lexer->comment = yytext[0] == '#';
  if(lexer->comment)
    {
    lexer->token.type = cmListFileLexer_Token_CommentBracket;
    bracket += 1;
    }
  else
    {
    lexer->token.type = cmListFileLexer_Token_ArgumentBracket;
    }
  cmListFileLexerSetToken(lexer, """", 0);
  lexer->bracket = (int)(strchr(bracket+1, '[') - bracket);
  if(yytext[yyleng-1] == '\n')
    {
    ++lexer->line;
    lexer->column = 1;
    }
  else
    {
    lexer->column += yyleng;
    }
  BEGIN(BRACKET);
}
        YY_BREAK
case 3:
YY_RULE_SETUP
#line 128 ""cmListFileLexer.in.l""
{
  lexer->column += yyleng;
  BEGIN(COMMENT);
}
        YY_BREAK
case 4:
YY_RULE_SETUP
#line 133 ""cmListFileLexer.in.l""
{
  lexer->column += yyleng;
}
        YY_BREAK
case 5:
YY_RULE_SETUP
#line 137 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ParenLeft;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 6:
YY_RULE_SETUP
#line 144 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ParenRight;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 7:
YY_RULE_SETUP
#line 151 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_Identifier;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 8:
YY_RULE_SETUP
#line 158 ""cmListFileLexer.in.l""
{
  /* Handle ]]====]=======]*/
  cmListFileLexerAppend(lexer, yytext, yyleng);
  lexer->column += yyleng;
  if(yyleng == lexer->bracket)
    {
    BEGIN(BRACKETEND);
    }
}
        YY_BREAK
case 9:
YY_RULE_SETUP
#line 168 ""cmListFileLexer.in.l""
{
  lexer->column += yyleng;
  /* Erase the partial bracket from the token.  */
  lexer->token.length -= lexer->bracket;
  lexer->token.text[lexer->token.length] = 0;
  BEGIN(INITIAL);
  return 1;
}
case 10:
YY_RULE_SETUP
#line 177 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  lexer->column += yyleng;
}
        YY_BREAK
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 182 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  ++lexer->line;
  lexer->column = 1;
  BEGIN(BRACKET);
}
        YY_BREAK
case 12:
YY_RULE_SETUP
#line 189 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  lexer->column += yyleng;
  BEGIN(BRACKET);
}
        YY_BREAK
case YY_STATE_EOF(BRACKET):
case YY_STATE_EOF(BRACKETEND):
#line 195 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_BadBracket;
  BEGIN(INITIAL);
  return 1;
}
case 13:
YY_RULE_SETUP
#line 201 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ArgumentUnquoted;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 14:
YY_RULE_SETUP
#line 208 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ArgumentUnquoted;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 15:
YY_RULE_SETUP
#line 215 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ArgumentUnquoted;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 16:
YY_RULE_SETUP
#line 222 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_ArgumentQuoted;
  cmListFileLexerSetToken(lexer, """", 0);
  lexer->column += yyleng;
  BEGIN(STRING);
}
        YY_BREAK
case 17:
YY_RULE_SETUP
#line 229 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  lexer->column += yyleng;
}
        YY_BREAK
case 18:
/* rule 18 can match eol */
YY_RULE_SETUP
#line 234 ""cmListFileLexer.in.l""
{
  /* Continuation: text is not part of string */
  ++lexer->line;
  lexer->column = 1;
}
        YY_BREAK
case 19:
/* rule 19 can match eol */
YY_RULE_SETUP
#line 240 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  ++lexer->line;
  lexer->column = 1;
}
        YY_BREAK
case 20:
YY_RULE_SETUP
#line 246 ""cmListFileLexer.in.l""
{
  lexer->column += yyleng;
  BEGIN(INITIAL);
  return 1;
}
case 21:
YY_RULE_SETUP
#line 252 ""cmListFileLexer.in.l""
{
  cmListFileLexerAppend(lexer, yytext, yyleng);
  lexer->column += yyleng;
}
        YY_BREAK
case YY_STATE_EOF(STRING):
#line 257 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_BadString;
  BEGIN(INITIAL);
  return 1;
}
case 22:
YY_RULE_SETUP
#line 263 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_Space;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case 23:
YY_RULE_SETUP
#line 270 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_BadCharacter;
  cmListFileLexerSetToken(lexer, yytext, yyleng);
  lexer->column += yyleng;
  return 1;
}
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(COMMENT):
#line 277 ""cmListFileLexer.in.l""
{
  lexer->token.type = cmListFileLexer_Token_None;
  cmListFileLexerSetToken(lexer, 0, 0);
  return 0;
}
case 24:
YY_RULE_SETUP
#line 283 ""cmListFileLexer.in.l""
ECHO;
        YY_BREAK
#line 1238 ""cmListFileLexer.c""

        case YY_END_OF_BUFFER:
                {
                /* Amount of text matched not including the EOB char. */
                int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

                /* Undo the effects of YY_DO_BEFORE_ACTION. */
                *yy_cp = yyg->yy_hold_char;
                YY_RESTORE_YY_MORE_OFFSET

                if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
                        {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * cmListFileLexer_yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                        }

                /* Note that here we test for yy_c_buf_p ""<="" to the position
                 * of the first EOB in the buffer, since yy_c_buf_p will
                 * already have been incremented past the NUL character
                 * (since all states make transitions on EOB to the
                 * end-of-buffer state).  Contrast this with the test
                 * in input().
                 */
                if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state( yyscanner );

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

                        yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

                        if ( yy_next_state )
                                {
                                /* Consume the NUL. */
                                yy_cp = ++yyg->yy_c_buf_p;
                                yy_current_state = yy_next_state;
                                goto yy_match;
                                }

                        else
                                {
                                yy_cp = yyg->yy_c_buf_p;
                                goto yy_find_action;
                                }
                        }

                else switch ( yy_get_next_buffer( yyscanner ) )
                        {
                        case EOB_ACT_END_OF_FILE:
                                {
                                yyg->yy_did_buffer_switch_on_eof = 0;

                                if ( cmListFileLexer_yywrap(yyscanner ) )
                                        {
                                        /* Note: because we've taken care in
                                         * yy_get_next_buffer() to have set up
                                         * yytext, we can now set up
                                         * yy_c_buf_p so that if some total
                                         * hoser (like flex itself) wants to
                                         * call the scanner after we return the
                                         * YY_NULL, it'll still work - another
                                         * YY_NULL will get returned.
                                         */
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

                                        yy_act = YY_STATE_EOF(YY_START);
                                        goto do_action;
                                        }

                                else
                                        {
                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
                                        }
                                break;
                                }

                        case EOB_ACT_CONTINUE_SCAN:
                                yyg->yy_c_buf_p =
                                        yyg->yytext_ptr + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_match;

                        case EOB_ACT_LAST_MATCH:
                                yyg->yy_c_buf_p =
                                &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

                                yy_current_state = yy_get_previous_state( yyscanner );

                                yy_cp = yyg->yy_c_buf_p;
                                yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                break;
                }

        default:
                YY_FATAL_ERROR(
                        ""fatal flex scanner internal error--no action found"" );
        } /* end of action switch */
                } /* end of scanning one token */
} /* end of cmListFileLexer_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *      EOB_ACT_LAST_MATCH -
 *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *      EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
        char *source = yyg->yytext_ptr;
        int number_to_move, i;
        int ret_val;

        if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
                YY_FATAL_ERROR(
                ""fatal flex scanner internal error--end of buffer missed"" );

        if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
                { /* Don't try to fill the buffer, so this is an EOF. */
                if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
                        {
                        /* We matched a single character, the EOB, so
                         * treat this as a final EOF.
                         */
                        return EOB_ACT_END_OF_FILE;
                        }

                else
                        {
                        /* We matched some text prior to the EOB, first
                         * process it.
                         */
                        return EOB_ACT_LAST_MATCH;
                        }
                }

        /* Try to read more data. */

        /* First move last chars to start of buffer. */
        number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;

        for ( i = 0; i < number_to_move; ++i )
                *(dest++) = *(source++);

        if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
                /* don't do the read, it's not guaranteed to return an EOF,
                 * just force an EOF
                 */
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

        else
                {
                        int num_to_read =
                        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

                while ( num_to_read <= 0 )
                        { /* Not enough room in the buffer - grow it. */

                        /* just a shorter name for the current buffer */
                        YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

                        int yy_c_buf_p_offset =
                                (int) (yyg->yy_c_buf_p - b->yy_ch_buf);

                        if ( b->yy_is_our_buffer )
                                {
                                int new_size = b->yy_buf_size * 2;

                                if ( new_size <= 0 )
                                        b->yy_buf_size += b->yy_buf_size / 8;
                                else
                                        b->yy_buf_size *= 2;

                                b->yy_ch_buf = (char *)
                                        /* Include room in for 2 EOB chars. */
                                        cmListFileLexer_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
                                }
                        else
                                /* Can't grow it, we don't own it. */
                                b->yy_ch_buf = 0;

                        if ( ! b->yy_ch_buf )
                                YY_FATAL_ERROR(
                                ""fatal error - scanner input buffer overflow"" );

                        yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

                        num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
                                                number_to_move - 1;

                        }

                if ( num_to_read > YY_READ_BUF_SIZE )
                        num_to_read = YY_READ_BUF_SIZE;

                /* Read in more data. */
                YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
                        yyg->yy_n_chars, (size_t) num_to_read );

                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        if ( yyg->yy_n_chars == 0 )
                {
                if ( number_to_move == YY_MORE_ADJ )
                        {
                        ret_val = EOB_ACT_END_OF_FILE;
                        cmListFileLexer_yyrestart(yyin  ,yyscanner);
                        }

                else
                        {
                        ret_val = EOB_ACT_LAST_MATCH;
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
                                YY_BUFFER_EOF_PENDING;
                        }
                }

        else
                ret_val = EOB_ACT_CONTINUE_SCAN;

        if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
                /* Extend the array by 50%, plus the number we really need. */
                yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
                YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cmListFileLexer_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
                if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
                        YY_FATAL_ERROR( ""out of dynamic memory in yy_get_next_buffer()"" );
        }

        yyg->yy_n_chars += number_to_move;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

        yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

        return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
        yy_state_type yy_current_state;
        char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        yy_current_state = yyg->yy_start;

        for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
                {
                YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
                if ( yy_accept[yy_current_state] )
                        {
                        yyg->yy_last_accepting_state = yy_current_state;
                        yyg->yy_last_accepting_cpos = yy_cp;
                        }
                while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                        {
                        yy_current_state = (int) yy_def[yy_current_state];
                        if ( yy_current_state >= 77 )
                                yy_c = yy_meta[(unsigned int) yy_c];
                        }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
                }

        return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
        int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
        char *yy_cp = yyg->yy_c_buf_p;

        YY_CHAR yy_c = 1;
        if ( yy_accept[yy_current_state] )
                {
                yyg->yy_last_accepting_state = yy_current_state;
                yyg->yy_last_accepting_cpos = yy_cp;
                }
        while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
                {
                yy_current_state = (int) yy_def[yy_current_state];
                if ( yy_current_state >= 77 )
                        yy_c = yy_meta[(unsigned int) yy_c];
                }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
        yy_is_jam = (yy_current_state == 76);

        return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
        int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        *yyg->yy_c_buf_p = yyg->yy_hold_char;

        if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
                {
                /* yy_c_buf_p now points to the character we want to return.
                 * If this occurs *before* the EOB characters, then it's a
                 * valid NUL; if not, then we've hit the end of the buffer.
                 */
                if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
                        /* This was really a NUL. */
                        *yyg->yy_c_buf_p = '\0';

                else
                        { /* need more input */
                        int offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
                        ++yyg->yy_c_buf_p;

                        switch ( yy_get_next_buffer( yyscanner ) )
                                {
                                case EOB_ACT_LAST_MATCH:
                                        /* This happens because yy_g_n_b()
                                         * sees that we've accumulated a
                                         * token and flags that we need to
                                         * try matching the token before
                                         * proceeding.  But for input(),
                                         * there's no matching to consider.
                                         * So convert the EOB_ACT_LAST_MATCH
                                         * to EOB_ACT_END_OF_FILE.
                                         */

                                        /* Reset buffer status. */
                                        cmListFileLexer_yyrestart(yyin ,yyscanner);

                                        /*FALLTHROUGH*/

                                case EOB_ACT_END_OF_FILE:
                                        {
                                        if ( cmListFileLexer_yywrap(yyscanner ) )
                                                return EOF;

                                        if ( ! yyg->yy_did_buffer_switch_on_eof )
                                                YY_NEW_FILE;
#ifdef __cplusplus
                                        return yyinput(yyscanner);
#else
                                        return input(yyscanner);
#endif
                                        }

                                case EOB_ACT_CONTINUE_SCAN:
                                        yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
                                        break;
                                }
                        }
                }

        c = *(unsigned char *) yyg->yy_c_buf_p; /* cast for 8-bit char's */
        *yyg->yy_c_buf_p = '\0';        /* preserve yytext */
        yyg->yy_hold_char = *++yyg->yy_c_buf_p;

        if ( c == '\n' )

    do{ yylineno++;
        yycolumn=0;
    }while(0)
;

        return c;
}
#endif  /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void cmListFileLexer_yyrestart  (FILE * input_file , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if ( ! YY_CURRENT_BUFFER ){
        cmListFileLexer_yyensure_buffer_stack (yyscanner);
                YY_CURRENT_BUFFER_LVALUE =
            cmListFileLexer_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
        }

        cmListFileLexer_yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);
        cmListFileLexer_yy_load_buffer_state(yyscanner );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
    void cmListFileLexer_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* TODO. We should be able to replace this entire function body
         * with
         *              cmListFileLexer_yypop_buffer_state();
         *              cmListFileLexer_yypush_buffer_state(new_buffer);
     */
        cmListFileLexer_yyensure_buffer_stack (yyscanner);
        if ( YY_CURRENT_BUFFER == new_buffer )
                return;

        if ( YY_CURRENT_BUFFER )
                {
                /* Flush out information for old buffer. */
                *yyg->yy_c_buf_p = yyg->yy_hold_char;
                YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        YY_CURRENT_BUFFER_LVALUE = new_buffer;
        cmListFileLexer_yy_load_buffer_state(yyscanner );

        /* We don't actually know whether we did this switch during
         * EOF (cmListFileLexer_yywrap()) processing, but the only time this flag
         * is looked at is after cmListFileLexer_yywrap() is called, so it's safe
         * to go ahead and always set it.
         */
        yyg->yy_did_buffer_switch_on_eof = 1;
}

static void cmListFileLexer_yy_load_buffer_state  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
        yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
        yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
        yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE cmListFileLexer_yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_buf_size = size;

        /* yy_ch_buf has to be 2 characters longer than the size given because
         * we need to put in 2 end-of-buffer characters.
         */
        b->yy_ch_buf = (char *) cmListFileLexer_yyalloc(b->yy_buf_size + 2 ,yyscanner );
        if ( ! b->yy_ch_buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );

        b->yy_is_our_buffer = 1;

        cmListFileLexer_yy_init_buffer(b,file ,yyscanner);

        return b;
}

/** Destroy the buffer.
 * @param b a buffer created with cmListFileLexer_yy_create_buffer()
 * @param yyscanner The scanner object.
 */
    void cmListFileLexer_yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if ( ! b )
                return;

        if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
                YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

        if ( b->yy_is_our_buffer )
                cmListFileLexer_yyfree((void *) b->yy_ch_buf ,yyscanner );

        cmListFileLexer_yyfree((void *) b ,yyscanner );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a cmListFileLexer_yyrestart() or at EOF.
 */
    static void cmListFileLexer_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)

{
        int oerrno = errno;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        cmListFileLexer_yy_flush_buffer(b ,yyscanner);

        b->yy_input_file = file;
        b->yy_fill_buffer = 1;

    /* If b is the current buffer, then cmListFileLexer_yy_init_buffer was _probably_
     * called from cmListFileLexer_yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;

        errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
    void cmListFileLexer_yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if ( ! b )
                return;

        b->yy_n_chars = 0;

        /* We always need two end-of-buffer characters.  The first causes
         * a transition to the end-of-buffer state.  The second causes
         * a jam in that state.
         */
        b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
        b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

        b->yy_buf_pos = &b->yy_ch_buf[0];

        b->yy_at_bol = 1;
        b->yy_buffer_status = YY_BUFFER_NEW;

        if ( b == YY_CURRENT_BUFFER )
                cmListFileLexer_yy_load_buffer_state(yyscanner );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void cmListFileLexer_yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (new_buffer == NULL)
                return;

        cmListFileLexer_yyensure_buffer_stack(yyscanner);

        /* This block is copied from cmListFileLexer_yy_switch_to_buffer. */
        if ( YY_CURRENT_BUFFER )
                {
                /* Flush out information for old buffer. */
                *yyg->yy_c_buf_p = yyg->yy_hold_char;
                YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
                YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
                }

        /* Only push if top exists. Otherwise, replace top. */
        if (YY_CURRENT_BUFFER)
                yyg->yy_buffer_stack_top++;
        YY_CURRENT_BUFFER_LVALUE = new_buffer;

        /* copied from cmListFileLexer_yy_switch_to_buffer. */
        cmListFileLexer_yy_load_buffer_state(yyscanner );
        yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void cmListFileLexer_yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
        if (!YY_CURRENT_BUFFER)
                return;

        cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        if (yyg->yy_buffer_stack_top > 0)
                --yyg->yy_buffer_stack_top;

        if (YY_CURRENT_BUFFER) {
                cmListFileLexer_yy_load_buffer_state(yyscanner );
                yyg->yy_did_buffer_switch_on_eof = 1;
        }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void cmListFileLexer_yyensure_buffer_stack (yyscan_t yyscanner)
{
        int num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (!yyg->yy_buffer_stack) {

                /* First allocation is just for 2 elements, since we don't know if this
                 * scanner will even need a stack. We use 2 instead of 1 to avoid an
                 * immediate realloc on the next call.
         */
                num_to_alloc = 1;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyalloc
                                                                (num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

                yyg->yy_buffer_stack_max = num_to_alloc;
                yyg->yy_buffer_stack_top = 0;
                return;
        }

        if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

                /* Increase the buffer to prepare for a possible push. */
                int grow_size = 8 /* arbitrary grow size */;

                num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
                yyg->yy_buffer_stack = (struct yy_buffer_state**)cmListFileLexer_yyrealloc
                                                                (yyg->yy_buffer_stack,
                                                                num_to_alloc * sizeof(struct yy_buffer_state*)
                                                                , yyscanner);
                if ( ! yyg->yy_buffer_stack )
                        YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yyensure_buffer_stack()"" );

                /* zero only the new slots.*/
                memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
                yyg->yy_buffer_stack_max = num_to_alloc;
        }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;

        if ( size < 2 ||
             base[size-2] != YY_END_OF_BUFFER_CHAR ||
             base[size-1] != YY_END_OF_BUFFER_CHAR )
                /* They forgot to leave room for the EOB's. */
                return 0;

        b = (YY_BUFFER_STATE) cmListFileLexer_yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
        if ( ! b )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_buffer()"" );

        b->yy_buf_size = size - 2;      /* ""- 2"" to take care of EOB's */
        b->yy_buf_pos = b->yy_ch_buf = base;
        b->yy_is_our_buffer = 0;
        b->yy_input_file = 0;
        b->yy_n_chars = b->yy_buf_size;
        b->yy_is_interactive = 0;
        b->yy_at_bol = 1;
        b->yy_fill_buffer = 0;
        b->yy_buffer_status = YY_BUFFER_NEW;

        cmListFileLexer_yy_switch_to_buffer(b ,yyscanner );

        return b;
}

/** Setup the input buffer state to scan a string. The next call to cmListFileLexer_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       cmListFileLexer_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
{

        return cmListFileLexer_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to cmListFileLexer_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE cmListFileLexer_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
        YY_BUFFER_STATE b;
        char *buf;
        yy_size_t n;
        int i;

        /* Get memory for full buffer, including space for trailing EOB's. */
        n = _yybytes_len + 2;
        buf = (char *) cmListFileLexer_yyalloc(n ,yyscanner );
        if ( ! buf )
                YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );

        for ( i = 0; i < _yybytes_len; ++i )
                buf[i] = yybytes[i];

        buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

        b = cmListFileLexer_yy_scan_buffer(buf,n ,yyscanner);
        if ( ! b )
                YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );

        /* It's okay to grow etc. this buffer, and we should throw it
         * away when we're done.
         */
        b->yy_is_our_buffer = 1;

        return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
{
        (void)yyscanner;
        (void) fprintf( stderr, ""%s\n"", msg );
        exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
        do \
                { \
                /* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
                yytext[yyleng] = yyg->yy_hold_char; \
                yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
                yyg->yy_hold_char = *yyg->yy_c_buf_p; \
                *yyg->yy_c_buf_p = '\0'; \
                yyleng = yyless_macro_arg; \
                } \
        while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE cmListFileLexer_yyget_extra  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int cmListFileLexer_yyget_lineno  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;

    return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int cmListFileLexer_yyget_column  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;

    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *cmListFileLexer_yyget_in  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *cmListFileLexer_yyget_out  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int cmListFileLexer_yyget_leng  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *cmListFileLexer_yyget_text  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyextra = user_defined ;
}

/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_lineno (int  line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);

    yylineno = line_number;
}

/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */
void cmListFileLexer_yyset_column (int  column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);

    yycolumn = column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see cmListFileLexer_yy_switch_to_buffer
 */
void cmListFileLexer_yyset_in (FILE *  in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = in_str ;
}

void cmListFileLexer_yyset_out (FILE *  out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = out_str ;
}

int cmListFileLexer_yyget_debug  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yy_flex_debug;
}

void cmListFileLexer_yyset_debug (int  bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yy_flex_debug = bdebug ;
}

/* Accessor methods for yylval and yylloc */

/* User-visible API */

/* cmListFileLexer_yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */

int cmListFileLexer_yylex_init(yyscan_t* ptr_yy_globals)

{
    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) cmListFileLexer_yyalloc ( sizeof( struct yyguts_t ), NULL );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals ( *ptr_yy_globals );
}

/* cmListFileLexer_yylex_init_extra has the same functionality as cmListFileLexer_yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to cmListFileLexer_yyalloc in
 * the yyextra field.
 */

int cmListFileLexer_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )

{
    struct yyguts_t dummy_yyguts;

    cmListFileLexer_yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) cmListFileLexer_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    cmListFileLexer_yyset_extra (yy_user_defined, *ptr_yy_globals);

    return yy_init_globals ( *ptr_yy_globals );
}

static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from cmListFileLexer_yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = 0;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = (char *) 0;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * cmListFileLexer_yylex_init()
     */
    return 0;
}

/* cmListFileLexer_yylex_destroy is for both reentrant and non-reentrant scanners. */
int cmListFileLexer_yylex_destroy  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    /* Pop the buffer stack, destroying each element. */
        while(YY_CURRENT_BUFFER){
                cmListFileLexer_yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );
                YY_CURRENT_BUFFER_LVALUE = NULL;
                cmListFileLexer_yypop_buffer_state(yyscanner);
        }

        /* Destroy the stack itself. */
        cmListFileLexer_yyfree(yyg->yy_buffer_stack ,yyscanner);
        yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
        cmListFileLexer_yyfree(yyg->yy_start_stack ,yyscanner );
        yyg->yy_start_stack = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * cmListFileLexer_yylex() is called, initialization will occur. */
    yy_init_globals( yyscanner);

    /* Destroy the main struct (reentrant only). */
    cmListFileLexer_yyfree ( yyscanner , yyscanner );
    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
        int i;
        for ( i = 0; i < n; ++i )
                s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
{
        int n;
        for ( n = 0; s[n]; ++n )
                ;

        return n;
}
#endif

void *cmListFileLexer_yyalloc (yy_size_t  size , yyscan_t yyscanner)
{
        (void)yyscanner;
        return (void *) malloc( size );
}

void *cmListFileLexer_yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
{
        /* The cast to (char *) in the following accommodates both
         * implementations that use char* generic pointers, and those
         * that use void* generic pointers.  It works with the latter
         * because both ANSI C and C++ allow castless assignment from
         * any pointer type to void*, and deal with argument conversions
         * as though doing an assignment.
         */
        (void)yyscanner;
        return (void *) realloc( (char *) ptr, size );
}

void cmListFileLexer_yyfree (void * ptr , yyscan_t yyscanner)
{
        (void)yyscanner;
        free( (char *) ptr );   /* see cmListFileLexer_yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME ""yytables""

#line 282 ""cmListFileLexer.in.l""



/*--------------------------------------------------------------------------*/
static void cmListFileLexerSetToken(cmListFileLexer* lexer, const char* text,
                                    int length)
{
  /* Set the token line and column number.  */
  lexer->token.line = lexer->line;
  lexer->token.column = lexer->column;

  /* Use the same buffer if possible.  */
  if(lexer->token.text)
    {
    if(text && length < lexer->size)
      {
      strcpy(lexer->token.text, text);
      lexer->token.length = length;
      return;
      }
    free(lexer->token.text);
    lexer->token.text = 0;
    lexer->size = 0;
    }

  /* Need to extend the buffer.  */
  if(text)
    {
    lexer->token.text = strdup(text);
    lexer->token.length = length;
    lexer->size = length+1;
    }
  else
    {
    lexer->token.length = 0;
    }
}

/*--------------------------------------------------------------------------*/
static void cmListFileLexerAppend(cmListFileLexer* lexer, const char* text,
                                  int length)
{
  char* temp;
  int newSize;

  /* If the appended text will fit in the buffer, do not reallocate.  */
  newSize = lexer->token.length + length + 1;
  if(lexer->token.text && newSize <= lexer->size)
    {
    strcpy(lexer->token.text+lexer->token.length, text);
    lexer->token.length += length;
    return;
    }

  /* We need to extend the buffer.  */
  temp = malloc(newSize);
  if(lexer->token.text)
    {
    memcpy(temp, lexer->token.text, lexer->token.length);
    free(lexer->token.text);
    }
  memcpy(temp+lexer->token.length, text, length);
  temp[lexer->token.length+length] = 0;
  lexer->token.text = temp;
  lexer->token.length += length;
  lexer->size = newSize;
}

/*--------------------------------------------------------------------------*/
static int cmListFileLexerInput(cmListFileLexer* lexer, char* buffer,
                                size_t bufferSize)
{
  if(lexer)
    {
    if(lexer->file)
      {
      /* Convert CRLF -> LF explicitly.  The C FILE ""t""ext mode
         does not convert newlines on all platforms.  Move any
         trailing CR to the start of the buffer for the next read. */
      size_t cr = lexer->cr;
      size_t n;
      buffer[0] = '\r';
      n = fread(buffer+cr, 1, bufferSize-cr, lexer->file);
      if(n)
        {
        char* o = buffer;
        const char* i = buffer;
        const char* e;
        n += cr;
        cr = (buffer[n-1] == '\r')? 1:0;
        e = buffer + n - cr;
        while(i != e)
          {
          if(i[0] == '\r' && i[1] == '\n')
            {
            ++i;
            }
          *o++ = *i++;
          }
        n = o - buffer;
        }
      else
        {
        n = cr;
        cr = 0;
        }
      lexer->cr = cr;
      return n;
      }
    else if(lexer->string_left)
      {
      int length = lexer->string_left;
      if((int)bufferSize < length) { length = (int)bufferSize; }
      memcpy(buffer, lexer->string_position, length);
      lexer->string_position += length;
      lexer->string_left -= length;
      return length;
      }
    }
  return 0;
}

/*--------------------------------------------------------------------------*/
static void cmListFileLexerInit(cmListFileLexer* lexer)
{
  if(lexer->file || lexer->string_buffer)
    {
    cmListFileLexer_yylex_init(&lexer->scanner);
    cmListFileLexer_yyset_extra(lexer, lexer->scanner);
    }
}

/*--------------------------------------------------------------------------*/
static void cmListFileLexerDestroy(cmListFileLexer* lexer)
{
  cmListFileLexerSetToken(lexer, 0, 0);
  if(lexer->file || lexer->string_buffer)
    {
    cmListFileLexer_yylex_destroy(lexer->scanner);
    if(lexer->file)
      {
      fclose(lexer->file);
      lexer->file = 0;
      }
    if(lexer->string_buffer)
      {
      free(lexer->string_buffer);
      lexer->string_buffer = 0;
      lexer->string_left = 0;
      lexer->string_position = 0;
      }
    }
}

/*--------------------------------------------------------------------------*/
cmListFileLexer* cmListFileLexer_New()
{
  cmListFileLexer* lexer = (cmListFileLexer*)malloc(sizeof(cmListFileLexer));
  if(!lexer)
    {
    return 0;
    }
  memset(lexer, 0, sizeof(*lexer));
  lexer->line = 1;
  lexer->column = 1;
  return lexer;
}

/*--------------------------------------------------------------------------*/
void cmListFileLexer_Delete(cmListFileLexer* lexer)
{
  cmListFileLexer_SetFileName(lexer, 0, 0);
  free(lexer);
}

/*--------------------------------------------------------------------------*/
static cmListFileLexer_BOM cmListFileLexer_ReadBOM(FILE* f)
{
  unsigned char b[2];
  if(fread(b, 1, 2, f) == 2)
    {
    if(b[0] == 0xEF && b[1] == 0xBB)
      {
      if(fread(b, 1, 1, f) == 1 && b[0] == 0xBF)
        {
        return cmListFileLexer_BOM_UTF8;
        }
      }
    else if(b[0] == 0xFE && b[1] == 0xFF)
      {
      /* UTF-16 BE */
      return cmListFileLexer_BOM_UTF16BE;
      }
    else if(b[0] == 0 && b[1] == 0)
      {
      if(fread(b, 1, 2, f) == 2 && b[0] == 0xFE && b[1] == 0xFF)
        {
        return cmListFileLexer_BOM_UTF32BE;
        }
      }
    else if(b[0] == 0xFF && b[1] == 0xFE)
      {
      fpos_t p;
      fgetpos(f, &p);
      if(fread(b, 1, 2, f) == 2 && b[0] == 0 && b[1] == 0)
        {
        return cmListFileLexer_BOM_UTF32LE;
        }
      fsetpos(f, &p);
      return cmListFileLexer_BOM_UTF16LE;
      }
    }
  rewind(f);
  return cmListFileLexer_BOM_None;
}

/*--------------------------------------------------------------------------*/
int cmListFileLexer_SetFileName(cmListFileLexer* lexer, const char* name,
                                cmListFileLexer_BOM* bom)
{
  int result = 1;
  cmListFileLexerDestroy(lexer);
  if(name)
    {
#ifdef _WIN32
    wchar_t* wname = cmsysEncoding_DupToWide(name);
    lexer->file = _wfopen(wname, L""rb"");
    free(wname);
#else
    lexer->file = fopen(name, ""rb"");
#endif
    if(lexer->file)
      {
      if(bom)
        {
        *bom = cmListFileLexer_ReadBOM(lexer->file);
        }
      }
    else
      {
      result = 0;
      }
    }
  cmListFileLexerInit(lexer);
  return result;
}

/*--------------------------------------------------------------------------*/
int cmListFileLexer_SetString(cmListFileLexer* lexer, const char* text)
{
  int result = 1;
  cmListFileLexerDestroy(lexer);
  if(text)
    {
    int length = (int)strlen(text);
    lexer->string_buffer = (char*)malloc(length+1);
    if(lexer->string_buffer)
      {
      strcpy(lexer->string_buffer, text);
      lexer->string_position = lexer->string_buffer;
      lexer->string_left = length;
      }
    else
      {
      result = 0;
      }
    }
  cmListFileLexerInit(lexer);
  return result;
}

/*--------------------------------------------------------------------------*/
cmListFileLexer_Token* cmListFileLexer_Scan(cmListFileLexer* lexer)
{
  if(!lexer->file)
    {
    return 0;
    }
  if(cmListFileLexer_yylex(lexer->scanner, lexer))
    {
    return &lexer->token;
    }
  else
    {
    cmListFileLexer_SetFileName(lexer, 0, 0);
    return 0;
    }
}

/*--------------------------------------------------------------------------*/
long cmListFileLexer_GetCurrentLine(cmListFileLexer* lexer)
{
  if(lexer->file)
    {
    return lexer->line;
    }
  else
    {
    return 0;
    }
}

/*--------------------------------------------------------------------------*/
long cmListFileLexer_GetCurrentColumn(cmListFileLexer* lexer)
{
  if(lexer->file)
    {
    return lexer->column;
    }
  else
    {
    return 0;
    }
}

/*--------------------------------------------------------------------------*/
const char* cmListFileLexer_GetTypeAsString(cmListFileLexer* lexer,
                                            cmListFileLexer_Type type)
{
  (void)lexer;
  switch(type)
    {
    case cmListFileLexer_Token_None: return ""nothing"";
    case cmListFileLexer_Token_Space: return ""space"";
    case cmListFileLexer_Token_Newline: return ""newline"";
    case cmListFileLexer_Token_Identifier: return ""identifier"";
    case cmListFileLexer_Token_ParenLeft: return ""left paren"";
    case cmListFileLexer_Token_ParenRight: return ""right paren"";
    case cmListFileLexer_Token_ArgumentUnquoted: return ""unquoted argument"";
    case cmListFileLexer_Token_ArgumentQuoted: return ""quoted argument"";
    case cmListFileLexer_Token_ArgumentBracket: return ""bracket argument"";
    case cmListFileLexer_Token_CommentBracket: return ""bracket comment"";
    case cmListFileLexer_Token_BadCharacter: return ""bad character"";
    case cmListFileLexer_Token_BadBracket: return ""unterminated bracket"";
    case cmListFileLexer_Token_BadString: return ""unterminated string"";
    }
  return ""unknown token"";
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_289.cpp,"[107, 7, 6, 3, 3, 0, 91, 4, 49, 1, 240, 4, 6, 1, 54, 3253, 1, 0, 137, 319, 50, 53, 67, 1353, 0, 0, 0, 17, 128, 0, 166, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1112, 4, 2192, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 117, 0, 0, 0, 0, 454, 0, 80, 0, 128, 108, 34, 0, 182, 194, 0, 381, 4, 317, 249, 6, 80, 132, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_289.cpp,1542
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_212.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_423.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_423.cpp,2091,2156,2102,2167,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmListFileLexer_yyset_lineno called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_290.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_290.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_290.cpp,6
e4a92dab3fa81a893a52dd1a774db79c4363fda6,"cmListFileLexer: Update to flex 2.6

Revise the documented modifications we need to make to the
flex-generated source file according to the needs of the new version.
Update our own implementation to avoid warnings with flex types.",[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_212.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_212.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_423.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_423.cpp,2091,2156,2117,2182,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmListFileLexer_yyset_column called with no buffer"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_291.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_291.cpp,"yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_291.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_291.cpp,6
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_219.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_219.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_435.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_435.cpp,1939,1939,1942,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_292.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_292.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_292.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_292.cpp,6
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_219.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_219.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_219.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_436.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_436.cpp,1963,1963,1966,1974,"fprintf(stderr, ""unknowntag_end:%s\n"", name);","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_293.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_293.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_293.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_293.cpp,6
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_220.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_220.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_220.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_438.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_438.cpp,843,868,847,878,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");","archive_wstrcat(&s, wp);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_294.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_294.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_294.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_294.cpp,141
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_441.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_441.cpp,231,233,232,234,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_295.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_295.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_295.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_295.cpp,26
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_442.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_442.cpp,242,244,243,245,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_296.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_296.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_296.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_296.cpp,37
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_443.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_443.cpp,334,336,335,337,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_297.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_297.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_297.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_297.cpp,14
e9bc469b2abcd0ad4cb3ad4bfefbc5ef1f559c1b,"Merge branch 'upstream-LibArchive' into update-libarchive

Resolve conflicts in C code by taking their side.  Resolve conflicts in
CMake code by integrating the changes.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_222.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_222.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_444.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_444.cpp,373,375,374,376,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_298.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_298.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_298.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_298.cpp,26
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_228.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_228.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_228.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_452.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_452.cpp,1939,1939,1942,-1,"fprintf(stderr, ""unknowntag_start:%s\n"", name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_299.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_299.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_start:%s\n"", name);
#endif
	tag = malloc(sizeof(*tag));
	if (tag == NULL) {
		archive_set_error(&a->archive, ENOMEM, ""Out of memory"");
		return (ARCHIVE_FATAL);
	}
	tag->next = xar->unknowntags;
	archive_string_init(&(tag->name));
	archive_strcpy(&(tag->name), name);
	if (xar->unknowntags == NULL) {
		xar->xmlsts_unknown = xar->xmlsts;
		xar->xmlsts = UNKNOWN;
	}
	xar->unknowntags = tag;
	return (ARCHIVE_OK);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_299.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 53, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 0, 0, 6, 0, 0, 9, 0, 11, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_299.cpp,6
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_228.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_228.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_228.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_453.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_453.cpp,1963,1963,1966,1974,"fprintf(stderr, ""unknowntag_end:%s\n"", name);","fprintf(stderr, ""UNKNOWNTAG_END:%s\n"", name);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_300.cpp,"{
	struct unknown_tag *tag;

#if DEBUG
	fprintf(stderr, ""unknowntag_end:%s\n"", name);
#endif
	tag = xar->unknowntags;
	if (tag == NULL || name == NULL)
		return;
	if (strcmp(tag->name.s, name) == 0) {
		xar->unknowntags = tag->next;
		archive_string_free(&(tag->name));
		free(tag);
		if (xar->unknowntags == NULL)
			xar->xmlsts = xar->xmlsts_unknown;
	}
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_300.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 6, 0, 7, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_300.cpp,6
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_229.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_229.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_229.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_455.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_455.cpp,843,868,847,878,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");","archive_wstrcat(&s, wp);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_301.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_301.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_301.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_301.cpp,141
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_231.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_458.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_458.cpp,231,233,232,234,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_302.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_302.cpp,"{
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_302.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_302.cpp,26
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_231.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_459.cpp,242,244,243,245,"archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");","archive_set_error(f->archive, EINVAL,
		    ""Can't launch external program: %s"", cmd);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_303.cpp,"{
		close(data->child_stdin);
		data->child_stdin = -1;
		close(data->child_stdout);
		data->child_stdout = -1;
		archive_set_error(f->archive, EINVAL,
		    ""Can't initialise filter"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_303.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_303.cpp,37
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_231.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_460.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_460.cpp,334,336,335,337,"archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");","archive_set_error(f->archive, EIO,
			    ""Can't write to program: %s"", data->program_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_304.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_304.cpp,"{
			archive_set_error(f->archive, EIO,
			    ""Can't write to filter"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_304.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_304.cpp,14
501345e470bb9c5b0cb61aff84bd50ffdd95b92d,"LibArchive 2016-04-30 (167e97be)

Code extracted from:

    https://github.com/libarchive/libarchive.git

at commit 167e97be1d35c1e0947d768adbf94712244aad6b (master).",[],libarchive/archive_write_add_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_231.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_231.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_461.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_461.cpp,373,375,374,376,"archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");","archive_set_error(f->archive, errno,
			    ""Error reading from program: %s"", data->program_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_305.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_305.cpp,"{
			archive_set_error(f->archive, errno,
			    ""Read from filter failed unexpectedly."");
			ret = ARCHIVE_FATAL;
			goto cleanup;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_305.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_305.cpp,26
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,489,-1,"f(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_306.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_306.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_306.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_306.cpp,468
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,492,517,"fprintf(fout, ""add_executable(%s"", targetName.c_str());","(targetType == cmState::EXECUTABLE)
      {
      /* Put the executable at a known location (for COPY_FILE).  */
      fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());
      /* Create the actual executable.  */
      fprintf(fout, ""add_executable(%s"", targetName.c_str());
      };",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_307.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_307.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_307.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_307.cpp,471
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,492,520,,"fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_308.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_308.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_308.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_308.cpp,471
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,492,523,,"fprintf(fout, ""add_executable(%s"", targetName.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_309.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_309.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile);

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmGlobalGenerator* gg = this->Makefile->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        std::ostringstream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n  "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        err << cmJoin(langs, "" "");
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName,""w"");
    if (!fout)
      {
      std::ostringstream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH \""%s\"")\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    switch(this->Makefile->GetPolicyStatus(cmPolicies::CMP0056))
      {
      case cmPolicies::WARN:
        if(this->Makefile->PolicyOptionalWarningEnabled(
             ""CMAKE_POLICY_WARNING_CMP0056""))
          {
          std::ostringstream w;
          w << cmPolicies::GetPolicyWarning(cmPolicies::CMP0056) << ""\n""
            ""For compatibility with older versions of CMake, try_compile ""
            ""is not honoring caller link flags (e.g. CMAKE_EXE_LINKER_FLAGS) ""
            ""in the test project.""
            ;
          this->Makefile->IssueMessage(cmake::AUTHOR_WARNING, w.str());
          }
      case cmPolicies::OLD:
        // OLD behavior is to do nothing.
        break;
      case cmPolicies::REQUIRED_IF_USED:
      case cmPolicies::REQUIRED_ALWAYS:
        this->Makefile->IssueMessage(
          cmake::FATAL_ERROR,
          cmPolicies::GetRequiredPolicyError(cmPolicies::CMP0056)
          );
      case cmPolicies::NEW:
        // NEW behavior is to pass linker flags.
        {
        const char* exeLinkFlags =
          this->Makefile->GetDefinition(""CMAKE_EXE_LINKER_FLAGS"");
        fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS %s)\n"",
                cmOutputConverter::EscapeForCMake(
                    exeLinkFlags ? exeLinkFlags : """").c_str());
        } break;
      }
    fprintf(fout, ""set(CMAKE_EXE_LINKER_FLAGS \""${CMAKE_EXE_LINKER_FLAGS}""
            "" ${EXE_LINKER_FLAGS}\"")\n"");
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (!compileDefs.empty())
      {
      fprintf(fout, ""add_definitions(%s)\n"", cmJoin(compileDefs, "" "").c_str());
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTC_%05x"",
            cmSystemTools::RandomSeed() & 0xFFFFF);
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg(gg, targets, this->Makefile);
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetConfig(this->Makefile->GetSafeDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_START_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_START_STATIC \""%s\"")\n"", lssDef);
      }
    if (const char *lssDef = this->Makefile->GetDefinition(
        ""CMAKE_LINK_SEARCH_END_STATIC""))
      {
      fprintf(fout, ""set(CMAKE_LINK_SEARCH_END_STATIC \""%s\"")\n"", lssDef);
      }

    /* Set the appropriate policy information for ENABLE_EXPORTS */
    fprintf(fout, ""cmake_policy(SET CMP0065 %s)\n"",
       this->Makefile->GetPolicyStatus(cmPolicies::CMP0065) ==
         cmPolicies::NEW ? ""NEW"" : ""OLD"");
    if(const char *ee = this->Makefile->GetDefinition(
        ""CMAKE_ENABLE_EXPORTS""))
      {
      fprintf(fout, ""set(CMAKE_ENABLE_EXPORTS %s)\n"", ee);
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName.c_str());
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_309.cpp,"[25, 0, 4, 0, 2, 0, 3, 1, 5, 0, 34, 0, 0, 0, 13, 679, 0, 0, 27, 44, 1, 0, 39, 101, 0, 0, 0, 0, 15, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 260, 3, 301, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 45, 0, 1, 0, 33, 28, 5, 0, 134, 3, 0, 68, 2, 156, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_309.cpp,471
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,493,528,,"fprintf(fout, ""set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY \""%s\"")\n"",
              this->BinaryDirectory.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_310.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_310.cpp,"r(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_310.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 2, 0, 6, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_310.cpp,472
7f1bd9fe6910f7633d98dec018cc01331a46b87e,"try_compile: Add option to control type of target

Create a `CMAKE_TRY_COMPILE_TARGET_TYPE` option to specify use
of `add_library(... STATIC ...)` for the generated test project.
This will be useful for cross-compiling toolchains that cannot
link a binary without custom flags or scripts.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_233.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_233.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_463.cpp,486,515,493,531,,"fprintf(fout, ""add_library(%s STATIC"", targetName.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_311.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_311.cpp,"r(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_311.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 2, 0, 6, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_311.cpp,472
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_464.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_464.cpp,296,298,300,-1,"fprintf(this->FileOut,""EXPORTS \n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_312.cpp,"{
               this->ImportFlag = false;
               fprintf(this->FileOut,""EXPORTS \n"");
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_312.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_312.cpp,44
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_465.cpp,319,317,321,319,"fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());",this->DataSymbols.insert(symbol);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_313.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_313.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_313.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_313.cpp,65
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_465.cpp,319,317,325,323,"fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());",this->Symbols.insert(symbol);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_314.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_314.cpp,"{
                     fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_314.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_314.cpp,69
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_466.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_466.cpp,340,338,344,-1,"fprintf(this->FileOut,""IMPORTS \n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_315.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_315.cpp,"{
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_315.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_315.cpp,88
1c1ace2db012919f23b6de5400ab192b9277dfc6,"De-duplicate symbols listed in generated module definition files

MS tools have a limit on the number of symbols that can be listed
in a `.def` file.  If multiple `.obj` files provide a symbol then
avoid listing it more than once in the generated `.def` file to
avoid counting toward the limit.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_234.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_234.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_466.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_466.cpp,340,338,346,340,"fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);",this->DataSymbols.insert(symbol);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_316.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_316.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!this->ImportFlag) {
               this->ImportFlag = true;
               fprintf(this->FileOut,""IMPORTS \n"");
            }
            fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_316.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_316.cpp,90
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_235.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_235.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_467.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_467.cpp,2174,2192,2176,2194,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmFortran_yyset_lineno called with no buffer"" );",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_317.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_317.cpp,"yy_fatal_error( ""cmFortran_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_317.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_317.cpp,6
ba819f49df33b546072a5928de3253770c4716b9,"cmFortranParser: Parse #line directives

Teach the lexer to extract the #line directive prefix and line number as
a new token type.  Teach the parser to recognize this token followed by
a string as the file name (plus possibly other content).  Report the
named file as included by the source file.",[],Source/cmFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_235.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_235.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_235.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_468.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_468.cpp,2189,2207,2191,2209,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner);","YY_FATAL_ERROR( ""cmFortran_yyset_column called with no buffer"" );",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_318.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_318.cpp,"yy_fatal_error( ""cmFortran_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_318.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_318.cpp,6
7f8bb857b8ab714b80acfa6a6e2c34195fabff6f,VS6: Port to cmGeneratorTarget.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_236.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_236.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_236.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_469.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_469.cpp,575,570,584,579,"sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target->GetName().c_str(), count);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_319.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_319.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->GetCurrentBinaryDirectory())
                           + target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
    comment = ""<hack>"";
    }

  // Add the rule with the given dependencies and commands.
  std::string no_main_dependency = """";
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment,
       origCommand.GetWorkingDirectory().c_str()))
    {
    cmGeneratorTarget* gt = this->GlobalGenerator->GetGeneratorTarget(&target);
    gt->AddSource(outsf->GetFullPath());
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_319.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 75, 0, 0, 4, 5, 0, 0, 5, 4, 0, 0, 0, 0, 4, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 2, 0, 0, 20, 0, 0, 6, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_319.cpp,9
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_237.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_470.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_470.cpp,843,850,845,852,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_320.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_320.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");
			return (ARCHIVE_RETRY);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_320.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_320.cpp,33
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_237.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_237.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_237.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_471.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_471.cpp,953,975,953,975,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_321.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_321.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_321.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_321.cpp,9
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_238.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_238.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_238.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_474.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_474.cpp,311,318,312,319,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_322.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_322.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_322.cpp,145
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_240.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_240.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_240.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_476.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_476.cpp,1390,1374,1395,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_323.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_323.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_323.cpp,16
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_240.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_240.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_240.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_477.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_477.cpp,1477,1449,1485,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_324.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_324.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_324.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_324.cpp,14
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_241.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_479.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_479.cpp,1175,1177,1218,1219,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_325.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_325.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_325.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_325.cpp,147
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_241.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_241.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_241.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_481.cpp,1583,1589,1608,1619,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_326.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_326.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_326.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_326.cpp,206
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_484.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_484.cpp,248,418,258,428,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_327.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_327.cpp,"{
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);
		offset += 4;
		if (offset + datasize > extra_length)
			break;
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);
#endif
		switch (headerid) {
		case 0x0001:
			/* Zip64 extended information extra field. */
			zip_entry->flags |= LA_USED_ZIP64;
			if (zip_entry->uncompressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->uncompressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->compressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->compressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->local_header_offset == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->local_header_offset =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			/* archive_le32dec(p + offset) gives disk
			 * on which file starts, but we don't handle
			 * multi-volume Zip files. */
			break;
		case 0x5455:
		{
			/* Extended time field ""UT"". */
			int flags = p[offset];
			offset++;
			datasize--;
			/* Flag bits indicate which dates are present. */
			if (flags & 0x01)
			{
#ifdef DEBUG
				fprintf(stderr, ""mtime: %lld -> %d\n"",
				    (long long)zip_entry->mtime,
				    archive_le32dec(p + offset));
#endif
				if (datasize < 4)
					break;
				zip_entry->mtime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x02)
			{
				if (datasize < 4)
					break;
				zip_entry->atime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x04)
			{
				if (datasize < 4)
					break;
				zip_entry->ctime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			break;
		}
		case 0x5855:
		{
			/* Info-ZIP Unix Extra Field (old version) ""UX"". */
			if (datasize >= 8) {
				zip_entry->atime = archive_le32dec(p + offset);
				zip_entry->mtime =
				    archive_le32dec(p + offset + 4);
			}
			if (datasize >= 12) {
				zip_entry->uid =
				    archive_le16dec(p + offset + 8);
				zip_entry->gid =
				    archive_le16dec(p + offset + 10);
			}
			break;
		}
		case 0x6c65:
		{
			/* Experimental 'el' field */
			/*
			 * Introduced Dec 2013 to provide a way to
			 * include external file attributes in local file
			 * header.  This provides file type and permission
			 * information necessary to support full streaming
			 * extraction.  Currently being discussed with
			 * other Zip developers... subject to change.
			 */
			int bitmap, bitmap_last;

			if (datasize < 1)
				break;
			bitmap_last = bitmap = 0xff & p[offset];
			offset += 1;
			datasize -= 1;

			/* We only support first 7 bits of bitmap; skip rest. */
			while ((bitmap_last & 0x80) != 0
			    && datasize >= 1) {
				bitmap_last = p[offset];
				offset += 1;
				datasize -= 1;
			}

			if (bitmap & 1) {
				// 2 byte ""version made by""
				if (datasize < 2)
					break;
				zip_entry->system
				    = archive_le16dec(p + offset) >> 8;
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 2) {
				// 2 byte ""internal file attributes""
				uint32_t internal_attributes;
				if (datasize < 2)
					break;
				internal_attributes
				    = archive_le16dec(p + offset);
				// Not used by libarchive at present.
				(void)internal_attributes; /* UNUSED */
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 4) {
				// 4 byte ""external file attributes""
				uint32_t external_attributes;
				if (datasize < 4)
					break;
				external_attributes
				    = archive_le32dec(p + offset);
				if (zip_entry->system == 3) {
					zip_entry->mode
					    = external_attributes >> 16;
				}
				offset += 4;
				datasize -= 4;
			}
			if (bitmap & 8) {
				// 2 byte comment length + comment
				uint32_t comment_length;
				if (datasize < 2)
					break;
				comment_length
				    = archive_le16dec(p + offset);
				offset += 2;
				datasize -= 2;

				if (datasize < comment_length)
					break;
				// Comment is not supported by libarchive
				offset += comment_length;
				datasize -= comment_length;
			}
			break;
		}
		case 0x7855:
			/* Info-ZIP Unix Extra Field (type 2) ""Ux"". */
#ifdef DEBUG
			fprintf(stderr, ""uid %d gid %d\n"",
			    archive_le16dec(p + offset),
			    archive_le16dec(p + offset + 2));
#endif
			if (datasize >= 2)
				zip_entry->uid = archive_le16dec(p + offset);
			if (datasize >= 4)
				zip_entry->gid =
				    archive_le16dec(p + offset + 2);
			break;
		case 0x7875:
		{
			/* Info-Zip Unix Extra Field (type 3) ""ux"". */
			int uidsize = 0, gidsize = 0;

			/* TODO: support arbitrary uidsize/gidsize. */
			if (datasize >= 1 && p[offset] == 1) {/* version=1 */
				if (datasize >= 4) {
					/* get a uid size. */
					uidsize = p[offset+1];
					if (uidsize == 2)
						zip_entry->uid =
						    archive_le16dec(
						        p + offset + 2);
					else if (uidsize == 4 && datasize >= 6)
						zip_entry->uid =
						    archive_le32dec(
						        p + offset + 2);
				}
				if (datasize >= (2 + uidsize + 3)) {
					/* get a gid size. */
					gidsize = p[offset+2+uidsize];
					if (gidsize == 2)
						zip_entry->gid =
						    archive_le16dec(
						        p+offset+2+uidsize+1);
					else if (gidsize == 4 &&
					    datasize >= (2 + uidsize + 5))
						zip_entry->gid =
						    archive_le32dec(
						        p+offset+2+uidsize+1);
				}
			}
			break;
		}
		default:
			break;
		}
		offset += datasize;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_327.cpp,"[35, 1, 0, 0, 20, 0, 0, 1, 6, 1, 42, 0, 0, 0, 0, 287, 0, 0, 8, 10, 0, 0, 5, 94, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 6, 0, 37, 35, 0, 0, 28, 0, 0, 60, 2, 37, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_327.cpp,13
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_485.cpp,696,927,699,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_328.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_328.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_328.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_328.cpp,207
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_486.cpp,748,980,750,982,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_329.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_329.cpp,"{
	const char *p;
	const void *h;
	const wchar_t *wp;
	const char *cp;
	size_t len, filename_length, extra_length;
	struct archive_string_conv *sconv;
	struct zip_entry *zip_entry = zip->entry;
	struct zip_entry zip_entry_central_dir;
	int ret = ARCHIVE_OK;
	char version;

	/* Save a copy of the original for consistency checks. */
	zip_entry_central_dir = *zip_entry;

	zip->decompress_init = 0;
	zip->end_of_entry = 0;
	zip->entry_uncompressed_bytes_read = 0;
	zip->entry_compressed_bytes_read = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);

	/* Setup default conversion. */
	if (zip->sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_read(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	if (memcmp(p, ""PK\003\004"", 4) != 0) {
		archive_set_error(&a->archive, -1, ""Damaged Zip archive"");
		return ARCHIVE_FATAL;
	}
	version = p[4];
	zip_entry->system = p[5];
	zip_entry->zip_flags = archive_le16dec(p + 6);
	if (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
		zip->has_encrypted_entries = 1;
		archive_entry_set_is_data_encrypted(entry, 1);
		if (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {
			archive_entry_set_is_metadata_encrypted(entry, 1);
			return ARCHIVE_FATAL;
		}
	}
	zip_entry->compression = (char)archive_le16dec(p + 8);
	zip_entry->mtime = zip_time(p + 10);
	zip_entry->crc32 = archive_le32dec(p + 14);
	zip_entry->compressed_size = archive_le32dec(p + 18);
	zip_entry->uncompressed_size = archive_le32dec(p + 22);
	filename_length = archive_le16dec(p + 26);
	extra_length = archive_le16dec(p + 28);

	__archive_read_consume(a, 30);

	/* Read the filename. */
	if ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}
	if (zip_entry->zip_flags & ZIP_UTF8_NAME) {
		/* The filename is stored to be UTF-8. */
		if (zip->sconv_utf8 == NULL) {
			zip->sconv_utf8 =
			    archive_string_conversion_from_charset(
				&a->archive, ""UTF-8"", 1);
			if (zip->sconv_utf8 == NULL)
				return (ARCHIVE_FATAL);
		}
		sconv = zip->sconv_utf8;
	} else if (zip->sconv != NULL)
		sconv = zip->sconv;
	else
		sconv = zip->sconv_default;

	if (archive_entry_copy_pathname_l(entry,
	    h, filename_length, sconv) != 0) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Pathname"");
			return (ARCHIVE_FATAL);
		}
		archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Pathname cannot be converted ""
		    ""from %s to current locale."",
		    archive_string_conversion_charset_name(sconv));
		ret = ARCHIVE_WARN;
	}
	__archive_read_consume(a, filename_length);

	/* Work around a bug in Info-Zip: When reading from a pipe, it
	 * stats the pipe instead of synthesizing a file entry. */
	if ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {
		zip_entry->mode &= ~ AE_IFMT;
		zip_entry->mode |= AE_IFREG;
	}

	if ((zip_entry->mode & AE_IFMT) == 0) {
		/* Especially in streaming mode, we can end up
		   here without having seen proper mode information.
		   Guess from the filename. */
		wp = archive_entry_pathname_w(entry);
		if (wp != NULL) {
			len = wcslen(wp);
			if (len > 0 && wp[len - 1] == L'/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		} else {
			cp = archive_entry_pathname(entry);
			len = (cp != NULL)?strlen(cp):0;
			if (len > 0 && cp[len - 1] == '/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		}
		if (zip_entry->mode == AE_IFDIR) {
			zip_entry->mode |= 0775;
		} else if (zip_entry->mode == AE_IFREG) {
			zip_entry->mode |= 0664;
		}
	}

	/* Read the extra data. */
	if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	process_extra(h, extra_length, zip_entry);
	__archive_read_consume(a, extra_length);

	if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
		/* If this came from the central dir, it's size info
		 * is definitive, so ignore the length-at-end flag. */
		zip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;
		/* If local header is missing a value, use the one from
		   the central directory.  If both have it, warn about
		   mismatches. */
		if (zip_entry->crc32 == 0) {
			zip_entry->crc32 = zip_entry_central_dir.crc32;
		} else if (!zip->ignore_crc32
		    && zip_entry->crc32 != zip_entry_central_dir.crc32) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent CRC32 values"");
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->compressed_size == 0) {
			zip_entry->compressed_size
			    = zip_entry_central_dir.compressed_size;
		} else if (zip_entry->compressed_size
		    != zip_entry_central_dir.compressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent compressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.compressed_size,
			    (intmax_t)zip_entry->compressed_size);
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->uncompressed_size == 0) {
			zip_entry->uncompressed_size
			    = zip_entry_central_dir.uncompressed_size;
		} else if (zip_entry->uncompressed_size
		    != zip_entry_central_dir.uncompressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent uncompressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.uncompressed_size,
			    (intmax_t)zip_entry->uncompressed_size);
			ret = ARCHIVE_WARN;
		}
	}

	/* Populate some additional entry fields: */
	archive_entry_set_mode(entry, zip_entry->mode);
	archive_entry_set_uid(entry, zip_entry->uid);
	archive_entry_set_gid(entry, zip_entry->gid);
	archive_entry_set_mtime(entry, zip_entry->mtime, 0);
	archive_entry_set_ctime(entry, zip_entry->ctime, 0);
	archive_entry_set_atime(entry, zip_entry->atime, 0);

	if ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {
		size_t linkname_length = zip_entry->compressed_size;

		archive_entry_set_size(entry, 0);
		p = __archive_read_ahead(a, linkname_length, NULL);
		if (p == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Truncated Zip file"");
			return ARCHIVE_FATAL;
		}
		if (__archive_read_consume(a, linkname_length) < 0) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}

		sconv = zip->sconv;
		if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
			sconv = zip->sconv_utf8;
		if (sconv == NULL)
			sconv = zip->sconv_default;
		if (archive_entry_copy_symlink_l(entry, p, linkname_length,
		    sconv) != 0) {
			if (errno != ENOMEM && sconv == zip->sconv_utf8 &&
			    (zip->entry->zip_flags & ZIP_UTF8_NAME))
			    archive_entry_copy_symlink_l(entry, p,
				linkname_length, NULL);
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");
				return (ARCHIVE_FATAL);
			}
			/*
			 * Since there is no character-set regulation for
			 * symlink name, do not report the conversion error
			 * in an automatic conversion.
			 */
			if (sconv != zip->sconv_utf8 ||
			    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));
				ret = ARCHIVE_WARN;
			}
		}
		zip_entry->uncompressed_size = zip_entry->compressed_size = 0;
	} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    || zip_entry->uncompressed_size > 0) {
		/* Set the size only if it's meaningful. */
		archive_entry_set_size(entry, zip_entry->uncompressed_size);
	}
	zip->entry_bytes_remaining = zip_entry->compressed_size;

	/* If there's no body, force read_data() to return EOF immediately. */
	if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    && zip->entry_bytes_remaining < 1)
		zip->end_of_entry = 1;

	/* Set up a more descriptive format name. */
	snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));
	a->archive.archive_format_name = zip->format_name;

	return (ret);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_329.cpp,"[38, 0, 0, 0, 0, 0, 11, 0, 0, 0, 43, 0, 0, 0, 4, 605, 0, 0, 11, 13, 0, 0, 3, 75, 0, 0, 0, 0, 6, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 1, 275, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 0, 39, 39, 5, 0, 56, 0, 0, 81, 6, 135, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_329.cpp,258
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_486.cpp,748,980,757,1007,,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Truncated ZIP file data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_330.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_330.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_330.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_330.cpp,0
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_486.cpp,748,980,757,1018,,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""ZIP bad Authentication code"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_331.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_331.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_331.cpp,0
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_243.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_243.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_487.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_487.cpp,1037,1790,1041,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_332.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_332.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_332.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_332.cpp,25
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_244.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_244.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_244.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_491.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_491.cpp,221,223,238,254,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_333.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_333.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_333.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_333.cpp,21
932848f420a738ee07997198fead5b2c2fbf4787,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts by integrating changes from both sides.",[],Utilities/cmlibarchive/libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_245.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_245.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_245.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_492.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_492.cpp,1467,1468,1468,1469,"archive_set_error(&a->archive, 0,
		    ""Write request too large"");","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_334.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_334.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_334.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_334.cpp,18
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_248.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_500.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_500.cpp,843,850,845,852,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_335.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Encountered out-of-order sparse blocks"");
			return (ARCHIVE_RETRY);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_335.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_335.cpp,33
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_248.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_248.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_248.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_501.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_501.cpp,953,975,953,975,"archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format->read_data function registered"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_336.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_336.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,
		    ""Internal error: ""
		    ""No format_read_data_block function registered"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_336.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_336.cpp,9
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_ar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_249.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_249.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_249.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_504.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_504.cpp,311,318,312,319,"archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");","archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for GNU/SVR4 archive entry"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_337.cpp,"{
			archive_set_error(&a->archive, EINVAL,
			    ""Can't find long filename for entry"");
			archive_entry_copy_pathname(entry, filename);
			/* Parse the time, owner, mode, size fields. */
			ar_parse_common_header(ar, entry, h);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_337.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_337.cpp,145
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_251.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_251.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_251.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_506.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_506.cpp,1390,1374,1395,-1,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_338.cpp,"{
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""LHa data CRC error"");
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_338.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_338.cpp,16
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_251.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_251.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_251.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_507.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_507.cpp,1477,1449,1485,-1,"archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_339.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_339.cpp,"{
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for lzh decompression"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_339.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_339.cpp,14
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_252.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_509.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_509.cpp,1175,1177,1218,1219,"archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));","archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""mtree specification has different""
					    "" type for %s"",
					    archive_entry_pathname(entry));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_340.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_340.cpp,"{
							archive_set_error(&a->archive,
									ARCHIVE_ERRNO_MISC,
									""mtree specification has different type for %s"",
									archive_entry_pathname(entry));
							r = ARCHIVE_WARN;
						}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_340.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_340.cpp,147
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_252.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_252.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_252.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_511.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_511.cpp,1583,1589,1608,1619,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);","archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; ""
				    ""assuming \""file\"""", val);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_341.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_341.cpp,"{
			case 'b':
				if (strcmp(val, ""block"") == 0) {
					archive_entry_set_filetype(entry, AE_IFBLK);
					break;
				}
			case 'c':
				if (strcmp(val, ""char"") == 0) {
					archive_entry_set_filetype(entry, AE_IFCHR);
					break;
				}
			case 'd':
				if (strcmp(val, ""dir"") == 0) {
					archive_entry_set_filetype(entry, AE_IFDIR);
					break;
				}
			case 'f':
				if (strcmp(val, ""fifo"") == 0) {
					archive_entry_set_filetype(entry, AE_IFIFO);
					break;
				}
				if (strcmp(val, ""file"") == 0) {
					archive_entry_set_filetype(entry, AE_IFREG);
					break;
				}
			case 'l':
				if (strcmp(val, ""link"") == 0) {
					archive_entry_set_filetype(entry, AE_IFLNK);
					break;
				}
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Unrecognized file type \""%s\""; assuming \""file\"""", val);
				archive_entry_set_filetype(entry, AE_IFREG);
				return (ARCHIVE_WARN);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_341.cpp,"[6, 0, 0, 0, 6, 0, 1, 0, 5, 1, 7, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 14, 0, 0, 8, 0, 30, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_341.cpp,206
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_514.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_514.cpp,244,414,254,424,"fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);","fprintf(stderr, ""Header id 0x%04x, length %d\n"",
		    headerid, datasize);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_342.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_342.cpp,"{
		unsigned short headerid = archive_le16dec(p + offset);
		unsigned short datasize = archive_le16dec(p + offset + 2);
		offset += 4;
		if (offset + datasize > extra_length)
			break;
#ifdef DEBUG
		fprintf(stderr, ""Header id 0x%x, length %d\n"",
		    headerid, datasize);
#endif
		switch (headerid) {
		case 0x0001:
			/* Zip64 extended information extra field. */
			zip_entry->flags |= LA_USED_ZIP64;
			if (zip_entry->uncompressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->uncompressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->compressed_size == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->compressed_size =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			if (zip_entry->local_header_offset == 0xffffffff) {
				if (datasize < 8)
					break;
				zip_entry->local_header_offset =
				    archive_le64dec(p + offset);
				offset += 8;
				datasize -= 8;
			}
			/* archive_le32dec(p + offset) gives disk
			 * on which file starts, but we don't handle
			 * multi-volume Zip files. */
			break;
		case 0x5455:
		{
			/* Extended time field ""UT"". */
			int flags = p[offset];
			offset++;
			datasize--;
			/* Flag bits indicate which dates are present. */
			if (flags & 0x01)
			{
#ifdef DEBUG
				fprintf(stderr, ""mtime: %lld -> %d\n"",
				    (long long)zip_entry->mtime,
				    archive_le32dec(p + offset));
#endif
				if (datasize < 4)
					break;
				zip_entry->mtime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x02)
			{
				if (datasize < 4)
					break;
				zip_entry->atime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			if (flags & 0x04)
			{
				if (datasize < 4)
					break;
				zip_entry->ctime = archive_le32dec(p + offset);
				offset += 4;
				datasize -= 4;
			}
			break;
		}
		case 0x5855:
		{
			/* Info-ZIP Unix Extra Field (old version) ""UX"". */
			if (datasize >= 8) {
				zip_entry->atime = archive_le32dec(p + offset);
				zip_entry->mtime =
				    archive_le32dec(p + offset + 4);
			}
			if (datasize >= 12) {
				zip_entry->uid =
				    archive_le16dec(p + offset + 8);
				zip_entry->gid =
				    archive_le16dec(p + offset + 10);
			}
			break;
		}
		case 0x6c65:
		{
			/* Experimental 'el' field */
			/*
			 * Introduced Dec 2013 to provide a way to
			 * include external file attributes in local file
			 * header.  This provides file type and permission
			 * information necessary to support full streaming
			 * extraction.  Currently being discussed with
			 * other Zip developers... subject to change.
			 */
			int bitmap, bitmap_last;

			if (datasize < 1)
				break;
			bitmap_last = bitmap = 0xff & p[offset];
			offset += 1;
			datasize -= 1;

			/* We only support first 7 bits of bitmap; skip rest. */
			while ((bitmap_last & 0x80) != 0
			    && datasize >= 1) {
				bitmap_last = p[offset];
				offset += 1;
				datasize -= 1;
			}

			if (bitmap & 1) {
				// 2 byte ""version made by""
				if (datasize < 2)
					break;
				zip_entry->system
				    = archive_le16dec(p + offset) >> 8;
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 2) {
				// 2 byte ""internal file attributes""
				uint32_t internal_attributes;
				if (datasize < 2)
					break;
				internal_attributes
				    = archive_le16dec(p + offset);
				// Not used by libarchive at present.
				(void)internal_attributes; /* UNUSED */
				offset += 2;
				datasize -= 2;
			}
			if (bitmap & 4) {
				// 4 byte ""external file attributes""
				uint32_t external_attributes;
				if (datasize < 4)
					break;
				external_attributes
				    = archive_le32dec(p + offset);
				if (zip_entry->system == 3) {
					zip_entry->mode
					    = external_attributes >> 16;
				}
				offset += 4;
				datasize -= 4;
			}
			if (bitmap & 8) {
				// 2 byte comment length + comment
				uint32_t comment_length;
				if (datasize < 2)
					break;
				comment_length
				    = archive_le16dec(p + offset);
				offset += 2;
				datasize -= 2;

				if (datasize < comment_length)
					break;
				// Comment is not supported by libarchive
				offset += comment_length;
				datasize -= comment_length;
			}
			break;
		}
		case 0x7855:
			/* Info-ZIP Unix Extra Field (type 2) ""Ux"". */
#ifdef DEBUG
			fprintf(stderr, ""uid %d gid %d\n"",
			    archive_le16dec(p + offset),
			    archive_le16dec(p + offset + 2));
#endif
			if (datasize >= 2)
				zip_entry->uid = archive_le16dec(p + offset);
			if (datasize >= 4)
				zip_entry->gid =
				    archive_le16dec(p + offset + 2);
			break;
		case 0x7875:
		{
			/* Info-Zip Unix Extra Field (type 3) ""ux"". */
			int uidsize = 0, gidsize = 0;

			/* TODO: support arbitrary uidsize/gidsize. */
			if (datasize >= 1 && p[offset] == 1) {/* version=1 */
				if (datasize >= 4) {
					/* get a uid size. */
					uidsize = p[offset+1];
					if (uidsize == 2)
						zip_entry->uid =
						    archive_le16dec(
						        p + offset + 2);
					else if (uidsize == 4 && datasize >= 6)
						zip_entry->uid =
						    archive_le32dec(
						        p + offset + 2);
				}
				if (datasize >= (2 + uidsize + 3)) {
					/* get a gid size. */
					gidsize = p[offset+2+uidsize];
					if (gidsize == 2)
						zip_entry->gid =
						    archive_le16dec(
						        p+offset+2+uidsize+1);
					else if (gidsize == 4 &&
					    datasize >= (2 + uidsize + 5))
						zip_entry->gid =
						    archive_le32dec(
						        p+offset+2+uidsize+1);
				}
			}
			break;
		}
		default:
			break;
		}
		offset += datasize;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_342.cpp,"[35, 1, 0, 0, 20, 0, 0, 1, 6, 1, 42, 0, 0, 0, 0, 287, 0, 0, 8, 10, 0, 0, 5, 94, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 186, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 6, 0, 37, 35, 0, 0, 28, 0, 0, 60, 2, 37, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_342.cpp,13
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_515.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_515.cpp,692,923,695,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_343.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_343.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_343.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_343.cpp,207
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_516.cpp,744,976,746,978,"snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));","archive_string_sprintf(&zip->format_name, ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_344.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_344.cpp,"{
	const char *p;
	const void *h;
	const wchar_t *wp;
	const char *cp;
	size_t len, filename_length, extra_length;
	struct archive_string_conv *sconv;
	struct zip_entry *zip_entry = zip->entry;
	struct zip_entry zip_entry_central_dir;
	int ret = ARCHIVE_OK;
	char version;

	/* Save a copy of the original for consistency checks. */
	zip_entry_central_dir = *zip_entry;

	zip->decompress_init = 0;
	zip->end_of_entry = 0;
	zip->entry_uncompressed_bytes_read = 0;
	zip->entry_compressed_bytes_read = 0;
	zip->entry_crc32 = zip->crc32func(0, NULL, 0);

	/* Setup default conversion. */
	if (zip->sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_read(&(a->archive));
		zip->init_default_conversion = 1;
	}

	if ((p = __archive_read_ahead(a, 30, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	if (memcmp(p, ""PK\003\004"", 4) != 0) {
		archive_set_error(&a->archive, -1, ""Damaged Zip archive"");
		return ARCHIVE_FATAL;
	}
	version = p[4];
	zip_entry->system = p[5];
	zip_entry->zip_flags = archive_le16dec(p + 6);
	if (zip_entry->zip_flags & (ZIP_ENCRYPTED | ZIP_STRONG_ENCRYPTED)) {
		zip->has_encrypted_entries = 1;
		archive_entry_set_is_data_encrypted(entry, 1);
		if (zip_entry->zip_flags & ZIP_CENTRAL_DIRECTORY_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_ENCRYPTED &&
			zip_entry->zip_flags & ZIP_STRONG_ENCRYPTED) {
			archive_entry_set_is_metadata_encrypted(entry, 1);
			return ARCHIVE_FATAL;
		}
	}
	zip_entry->compression = (char)archive_le16dec(p + 8);
	zip_entry->mtime = zip_time(p + 10);
	zip_entry->crc32 = archive_le32dec(p + 14);
	zip_entry->compressed_size = archive_le32dec(p + 18);
	zip_entry->uncompressed_size = archive_le32dec(p + 22);
	filename_length = archive_le16dec(p + 26);
	extra_length = archive_le16dec(p + 28);

	__archive_read_consume(a, 30);

	/* Read the filename. */
	if ((h = __archive_read_ahead(a, filename_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}
	if (zip_entry->zip_flags & ZIP_UTF8_NAME) {
		/* The filename is stored to be UTF-8. */
		if (zip->sconv_utf8 == NULL) {
			zip->sconv_utf8 =
			    archive_string_conversion_from_charset(
				&a->archive, ""UTF-8"", 1);
			if (zip->sconv_utf8 == NULL)
				return (ARCHIVE_FATAL);
		}
		sconv = zip->sconv_utf8;
	} else if (zip->sconv != NULL)
		sconv = zip->sconv;
	else
		sconv = zip->sconv_default;

	if (archive_entry_copy_pathname_l(entry,
	    h, filename_length, sconv) != 0) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Pathname"");
			return (ARCHIVE_FATAL);
		}
		archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Pathname cannot be converted ""
		    ""from %s to current locale."",
		    archive_string_conversion_charset_name(sconv));
		ret = ARCHIVE_WARN;
	}
	__archive_read_consume(a, filename_length);

	/* Work around a bug in Info-Zip: When reading from a pipe, it
	 * stats the pipe instead of synthesizing a file entry. */
	if ((zip_entry->mode & AE_IFMT) == AE_IFIFO) {
		zip_entry->mode &= ~ AE_IFMT;
		zip_entry->mode |= AE_IFREG;
	}

	if ((zip_entry->mode & AE_IFMT) == 0) {
		/* Especially in streaming mode, we can end up
		   here without having seen proper mode information.
		   Guess from the filename. */
		wp = archive_entry_pathname_w(entry);
		if (wp != NULL) {
			len = wcslen(wp);
			if (len > 0 && wp[len - 1] == L'/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		} else {
			cp = archive_entry_pathname(entry);
			len = (cp != NULL)?strlen(cp):0;
			if (len > 0 && cp[len - 1] == '/')
				zip_entry->mode |= AE_IFDIR;
			else
				zip_entry->mode |= AE_IFREG;
		}
		if (zip_entry->mode == AE_IFDIR) {
			zip_entry->mode |= 0775;
		} else if (zip_entry->mode == AE_IFREG) {
			zip_entry->mode |= 0664;
		}
	}

	/* Read the extra data. */
	if ((h = __archive_read_ahead(a, extra_length, NULL)) == NULL) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated ZIP file header"");
		return (ARCHIVE_FATAL);
	}

	process_extra(h, extra_length, zip_entry);
	__archive_read_consume(a, extra_length);

	if (zip_entry->flags & LA_FROM_CENTRAL_DIRECTORY) {
		/* If this came from the central dir, it's size info
		 * is definitive, so ignore the length-at-end flag. */
		zip_entry->zip_flags &= ~ZIP_LENGTH_AT_END;
		/* If local header is missing a value, use the one from
		   the central directory.  If both have it, warn about
		   mismatches. */
		if (zip_entry->crc32 == 0) {
			zip_entry->crc32 = zip_entry_central_dir.crc32;
		} else if (!zip->ignore_crc32
		    && zip_entry->crc32 != zip_entry_central_dir.crc32) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent CRC32 values"");
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->compressed_size == 0) {
			zip_entry->compressed_size
			    = zip_entry_central_dir.compressed_size;
		} else if (zip_entry->compressed_size
		    != zip_entry_central_dir.compressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent compressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.compressed_size,
			    (intmax_t)zip_entry->compressed_size);
			ret = ARCHIVE_WARN;
		}
		if (zip_entry->uncompressed_size == 0) {
			zip_entry->uncompressed_size
			    = zip_entry_central_dir.uncompressed_size;
		} else if (zip_entry->uncompressed_size
		    != zip_entry_central_dir.uncompressed_size) {
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Inconsistent uncompressed size: ""
			    ""%jd in central directory, %jd in local header"",
			    (intmax_t)zip_entry_central_dir.uncompressed_size,
			    (intmax_t)zip_entry->uncompressed_size);
			ret = ARCHIVE_WARN;
		}
	}

	/* Populate some additional entry fields: */
	archive_entry_set_mode(entry, zip_entry->mode);
	archive_entry_set_uid(entry, zip_entry->uid);
	archive_entry_set_gid(entry, zip_entry->gid);
	archive_entry_set_mtime(entry, zip_entry->mtime, 0);
	archive_entry_set_ctime(entry, zip_entry->ctime, 0);
	archive_entry_set_atime(entry, zip_entry->atime, 0);

	if ((zip->entry->mode & AE_IFMT) == AE_IFLNK) {
		size_t linkname_length = zip_entry->compressed_size;

		archive_entry_set_size(entry, 0);
		p = __archive_read_ahead(a, linkname_length, NULL);
		if (p == NULL) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Truncated Zip file"");
			return ARCHIVE_FATAL;
		}
		if (__archive_read_consume(a, linkname_length) < 0) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Read error skipping symlink target name"");
			return ARCHIVE_FATAL;
		}

		sconv = zip->sconv;
		if (sconv == NULL && (zip->entry->zip_flags & ZIP_UTF8_NAME))
			sconv = zip->sconv_utf8;
		if (sconv == NULL)
			sconv = zip->sconv_default;
		if (archive_entry_copy_symlink_l(entry, p, linkname_length,
		    sconv) != 0) {
			if (errno != ENOMEM && sconv == zip->sconv_utf8 &&
			    (zip->entry->zip_flags & ZIP_UTF8_NAME))
			    archive_entry_copy_symlink_l(entry, p,
				linkname_length, NULL);
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");
				return (ARCHIVE_FATAL);
			}
			/*
			 * Since there is no character-set regulation for
			 * symlink name, do not report the conversion error
			 * in an automatic conversion.
			 */
			if (sconv != zip->sconv_utf8 ||
			    (zip->entry->zip_flags & ZIP_UTF8_NAME) == 0) {
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));
				ret = ARCHIVE_WARN;
			}
		}
		zip_entry->uncompressed_size = zip_entry->compressed_size = 0;
	} else if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    || zip_entry->uncompressed_size > 0) {
		/* Set the size only if it's meaningful. */
		archive_entry_set_size(entry, zip_entry->uncompressed_size);
	}
	zip->entry_bytes_remaining = zip_entry->compressed_size;

	/* If there's no body, force read_data() to return EOF immediately. */
	if (0 == (zip_entry->zip_flags & ZIP_LENGTH_AT_END)
	    && zip->entry_bytes_remaining < 1)
		zip->end_of_entry = 1;

	/* Set up a more descriptive format name. */
	snprintf(zip->format_name, sizeof(zip->format_name), ""ZIP %d.%d (%s)"",
	    version / 10, version % 10,
	    compression_name(zip->entry->compression));
	a->archive.archive_format_name = zip->format_name;

	return (ret);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_344.cpp,"[38, 0, 0, 0, 0, 0, 11, 0, 0, 0, 43, 0, 0, 0, 4, 605, 0, 0, 11, 13, 0, 0, 3, 75, 0, 0, 0, 0, 6, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 326, 1, 275, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 0, 39, 39, 5, 0, 56, 0, 0, 81, 6, 135, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_344.cpp,258
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_516.cpp,744,976,753,1003,,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Truncated ZIP file data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_345.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_345.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_345.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_345.cpp,0
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_516.cpp,744,976,753,1014,,"archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""ZIP bad Authentication code"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_346.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_346.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_346.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_346.cpp,0
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_254.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_517.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_517.cpp,1033,1786,1037,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_347.cpp,"{
		zip->has_encrypted_entries = 1;
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Encrypted file is unsupported"");
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_347.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_347.cpp,25
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_add_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_255.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_255.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_255.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_521.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_521.cpp,221,223,238,254,"archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);","archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary size for lzip: %d"",
			    dict_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_348.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_348.cpp,"{
			archive_set_error(f->archive, ARCHIVE_ERRNO_MISC,
			    ""Unacceptable dictionary dize for lzip: %d"",
			    dict_size);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_348.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_348.cpp,21
1a8c7bc2c649781d1163c1966245a45e0fb829ba,"libarchive 3.1.2-601-g3bfe5f1 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-601-g3bfe5f1 &&
r=3bfe5f1 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_256.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_256.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_256.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_522.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_522.cpp,1467,1468,1468,1469,"archive_set_error(&a->archive, 0,
		    ""Write request too large"");","archive_set_error(&a->archive, 0,
		    ""Too much data: Truncating file at %ju bytes"", (uintmax_t)a->filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_349.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_349.cpp,"{
		archive_set_error(&a->archive, 0,
		    ""Write request too large"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_349.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_349.cpp,18
bbef3c2da83b7a69d1f99b21dc92d5506d98fb35,cmLocalGenerator: Add current binary directory accessor.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_259.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_259.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_259.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_529.cpp,578,578,582,582,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);","sprintf(output,""%s/%s_force_%i"", this->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_350.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_350.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetCurrentBinaryDirectory())
                           + target.GetName().size() + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetCurrentBinaryDirectory(),
          target.GetName().c_str(), count);
  const char* comment = origCommand.GetComment();
  if(!comment && origCommand.GetOutputs().empty())
    {
    comment = ""<hack>"";
    }

  // Add the rule with the given dependencies and commands.
  std::string no_main_dependency = """";
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment,
       origCommand.GetWorkingDirectory().c_str()))
    {
    cmGeneratorTarget* gt = this->GlobalGenerator->GetGeneratorTarget(&target);
    gt->AddSource(outsf->GetFullPath());
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_350.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 77, 0, 0, 4, 5, 0, 0, 5, 4, 0, 0, 0, 0, 4, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 2, 0, 0, 20, 0, 0, 6, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_350.cpp,9
2e6063068c94d4045e699fed51e6d1e9af344bbf,"Merge branch 'improve-variable-help-formatting' into revert-cmake-W-options

Resolve conflicts in

 Help/variable/CMAKE_ERROR_DEPRECATED.rst
 Help/variable/CMAKE_WARN_DEPRECATED.rst

by integrating changes from both sides.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_261.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_261.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_261.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_531.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_531.cpp,1111,1148,1113,1150,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_351.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_351.cpp,"{
  this->FirstTimeProgress = 0.0f;
  this->ClearGeneratorMembers();

  // start with this directory
  cmLocalGenerator *lg = this->MakeLocalGenerator();
  this->LocalGenerators.push_back(lg);

  // set the Start directories
  lg->GetMakefile()->SetCurrentSourceDirectory
    (this->CMakeInstance->GetHomeDirectory());
  lg->GetMakefile()->SetCurrentBinaryDirectory
    (this->CMakeInstance->GetHomeOutputDirectory());

  this->BinaryDirectories.insert(
      this->CMakeInstance->GetHomeOutputDirectory());

  // now do it
  lg->GetMakefile()->Configure();
  lg->GetMakefile()->EnforceDirectoryLevelRules();

  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
  this->CheckLocalGenerators();

  // at this point this->LocalGenerators has been filled,
  // so create the map from project name to vector of local generators
  this->FillProjectMap();

  if ( this->CMakeInstance->GetWorkingMode() == cmake::NORMAL_MODE)
    {
    std::ostringstream msg;
    if(cmSystemTools::GetErrorOccuredFlag())
      {
      msg << ""Configuring incomplete, errors occurred!"";
      const char* logs[] = {""CMakeOutput.log"", ""CMakeError.log"", 0};
      for(const char** log = logs; *log; ++log)
        {
        std::string f = this->CMakeInstance->GetHomeOutputDirectory();
        f += this->CMakeInstance->GetCMakeFilesDirectory();
        f += ""/"";
        f += *log;
        if(cmSystemTools::FileExists(f.c_str()))
          {
          msg << ""\nSee also \"""" << f << ""\""."";
          }
        }
      }
    else
      {
      msg << ""Configuring done"";
      }
    this->CMakeInstance->UpdateProgress(msg.str().c_str(), -1);
    }

  unsigned int i;

  // Put a copy of each global target in every directory.
  cmTargets globalTargets;
  this->CreateDefaultGlobalTargets(&globalTargets);

  for (i = 0; i < this->LocalGenerators.size(); ++i)
    {
    cmMakefile* mf = this->LocalGenerators[i]->GetMakefile();
    cmTargets* targets = &(mf->GetTargets());
    cmTargets::iterator tit;
    for ( tit = globalTargets.begin(); tit != globalTargets.end(); ++ tit )
      {
      (*targets)[tit->first] = tit->second;
      (*targets)[tit->first].SetMakefile(mf);
      }
    }

}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_351.cpp,"[3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 2, 182, 0, 0, 10, 11, 0, 0, 9, 15, 0, 0, 0, 0, 6, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 64, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 5, 0, 6, 3, 1, 0, 39, 0, 0, 22, 0, 18, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_351.cpp,25
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_550.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_550.cpp,1933,1967,1943,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_352.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_352.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_352.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_352.cpp,50
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_550.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_550.cpp,1933,1967,1947,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_353.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_353.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_353.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_353.cpp,54
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_551.cpp,1986,2010,2000,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_354.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_354.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_354.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_354.cpp,107
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_551.cpp,1986,2010,2002,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_355.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_355.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_355.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_355.cpp,109
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_275.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_551.cpp,1986,2010,2006,2020,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_356.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_356.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_356.cpp,113
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_276.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_276.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_276.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_553.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_553.cpp,2153,2198,2157,2201,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_357.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_357.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_357.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_357.cpp,444
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_554.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_554.cpp,26,26,261,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_358.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_358.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_358.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_358.cpp,5
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_555.cpp,352,112,369,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_359.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_359.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_359.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_359.cpp,73
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_555.cpp,352,112,391,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_360.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_360.cpp,"{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
    authp = &data->state.authhost;
  }

  Curl_safefree(*allocuserpwd);

  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
     do the Digest IE-style. Note that the different ways cause different MD5
     sums to get sent.

     Apache servers can be set to do the Digest IE-style automatically using
     the BrowserMatch feature:
     http://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie

     Further details on Digest implementation differences:
     http://www.fngtps.com/2006/09/http-authentication
  */

  if(authp->iestyle && ((tmp = strchr((char *)uripath, '?')) != NULL))
    urilen = tmp - (char *)uripath;
  else
    urilen = strlen((char *)uripath);

  md5this = (unsigned char *)aprintf(""%s:%.*s"", request, urilen, uripath);

  if(d->qop && Curl_raw_equal(d->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    Curl_safefree(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha2);

  if(d->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       d->nc,
                                       d->cnonce,
                                       d->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       ha2);
  }
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(d->qop) {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""cnonce=\""%s\"", ""
               ""nc=%08x, ""
               ""qop=%s, ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               d->cnonce,
               d->nc,
               d->qop,
               request_digest);

    if(Curl_raw_equal(d->qop, ""auth""))
      d->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0 padded
                  which tells to the server how many times you are using the
                  same nonce in the qop=auth mode. */
  }
  else {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               request_digest);
  }
  Curl_safefree(userp_quoted);
  if(!*allocuserpwd)
    return CURLE_OUT_OF_MEMORY;

  /* Add optional fields */
  if(d->opaque) {
    /* append opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", *allocuserpwd, d->opaque);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  if(d->algorithm) {
    /* append algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", *allocuserpwd, d->algorithm);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  /* append CRLF + zero (3 bytes) to the userpwd header */
  userlen = strlen(*allocuserpwd);
  tmp = realloc(*allocuserpwd, userlen + 3);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;
  strcpy(&tmp[userlen], ""\r\n""); /* append the data */
  *allocuserpwd = tmp;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_360.cpp,"[24, 0, 0, 0, 0, 0, 12, 0, 0, 0, 29, 0, 0, 0, 2, 408, 0, 0, 20, 20, 0, 0, 5, 43, 0, 0, 0, 0, 12, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 2, 227, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 22, 0, 6, 0, 26, 26, 6, 0, 47, 2, 0, 59, 0, 115, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_360.cpp,95
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_277.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_555.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_555.cpp,352,112,402,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_361.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_361.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_361.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_361.cpp,106
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_556.cpp,22,22,60,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_362.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_362.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_362.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_362.cpp,13
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_556.cpp,22,22,82,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_363.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_363.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_363.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_363.cpp,10
91e8d35ab8ec2d62478a42eff10af88713497fad,"Merge branch 'curl-upstream' into update-curl

Resolve conflicts by taking upstream side when possible and otherwise
integrating the changes from both sides.  Be carful in CMakeLists.txt
where the OPENSSL code block that we modified previously has moved, and
preserve our previous modifications in the new location.",[],Utilities/cmcurl/lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_278.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_556.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_556.cpp,22,22,92,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_364.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_364.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_364.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_364.cpp,20
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_572.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_572.cpp,1933,1967,1943,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_365.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                     conn->host.name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_365.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_365.cpp,50
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_572.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_572.cpp,1933,1967,1947,-1,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_366.cpp,"snprintf(ftpc->newhost, NEWHOST_BUFSIZE, ""%s"", conn->ip_addr_str)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_366.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_366.cpp,54
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_573.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_573.cpp,1986,2010,2000,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_367.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"", conn->host.name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_367.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_367.cpp,107
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_573.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_573.cpp,1986,2010,2002,-1,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_368.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_368.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost), ""%s"",
                 conn->ip_addr_str)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_368.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_368.cpp,109
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_288.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_288.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_573.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_573.cpp,1986,2010,2006,2020,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);","ftpc->newhost = aprintf(""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_369.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_369.cpp,"snprintf(ftpc->newhost, sizeof(ftpc->newhost),
               ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_369.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_369.cpp,113
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_289.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_289.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_289.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_575.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_575.cpp,2153,2198,2157,2201,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_370.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_370.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"",
                                         data->state.range);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_370.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_370.cpp,444
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_576.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_576.cpp,26,26,261,-1,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_371.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_371.cpp,"snprintf((char *)&dest[i*2], 3, ""%02x"", source[i])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_371.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_371.cpp,5
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_577.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_577.cpp,352,112,369,-1,"snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_372.cpp,"{
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_372.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 23, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 8, 0, 0, 3, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_372.cpp,73
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_577.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_577.cpp,352,112,391,-1,"(""%s:%s:%s"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_373.cpp,"{
  /* We have a Digest setup for this, use it!  Now, to get all the details for
     this sorted out, I must urge you dear friend to read up on the RFC2617
     section 3.2.2, */
  size_t urilen;
  unsigned char md5buf[16]; /* 16 bytes/128 bits */
  unsigned char request_digest[33];
  unsigned char *md5this;
  unsigned char ha1[33];/* 32 digits and 1 zero byte */
  unsigned char ha2[33];/* 32 digits and 1 zero byte */
  char cnoncebuf[33];
  char *cnonce = NULL;
  size_t cnonce_sz = 0;
  char *tmp = NULL;
  char **allocuserpwd;
  size_t userlen;
  const char *userp;
  char *userp_quoted;
  const char *passwdp;
  struct auth *authp;

  struct SessionHandle *data = conn->data;
  struct digestdata *d;
  CURLcode rc;
/* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
   It converts digest text to ASCII so the MD5 will be correct for
   what ultimately goes over the network.
*/
#define CURL_OUTPUT_DIGEST_CONV(a, b) \
  rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
  if(rc != CURLE_OK) { \
    free(b); \
    return rc; \
  }

  if(proxy) {
    d = &data->state.proxydigest;
    allocuserpwd = &conn->allocptr.proxyuserpwd;
    userp = conn->proxyuser;
    passwdp = conn->proxypasswd;
    authp = &data->state.authproxy;
  }
  else {
    d = &data->state.digest;
    allocuserpwd = &conn->allocptr.userpwd;
    userp = conn->user;
    passwdp = conn->passwd;
    authp = &data->state.authhost;
  }

  Curl_safefree(*allocuserpwd);

  /* not set means empty */
  if(!userp)
    userp="""";

  if(!passwdp)
    passwdp="""";

  if(!d->nonce) {
    authp->done = FALSE;
    return CURLE_OK;
  }
  authp->done = TRUE;

  if(!d->nc)
    d->nc = 1;

  if(!d->cnonce) {
    snprintf(cnoncebuf, sizeof(cnoncebuf), ""%08x%08x%08x%08x"",
             Curl_rand(data), Curl_rand(data),
             Curl_rand(data), Curl_rand(data));
    rc = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
                            &cnonce, &cnonce_sz);
    if(rc)
      return rc;
    d->cnonce = cnonce;
  }

  /*
    if the algorithm is ""MD5"" or unspecified (which then defaults to MD5):

    A1 = unq(username-value) "":"" unq(realm-value) "":"" passwd

    if the algorithm is ""MD5-sess"" then:

    A1 = H( unq(username-value) "":"" unq(realm-value) "":"" passwd )
         "":"" unq(nonce-value) "":"" unq(cnonce-value)
  */

  md5this = (unsigned char *)
    aprintf(""%s:%s:%s"", userp, d->realm, passwdp);
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha1);

  if(d->algo == CURLDIGESTALGO_MD5SESS) {
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }

  /*
    If the ""qop"" directive's value is ""auth"" or is unspecified, then A2 is:

      A2       = Method "":"" digest-uri-value

          If the ""qop"" value is ""auth-int"", then A2 is:

      A2       = Method "":"" digest-uri-value "":"" H(entity-body)

    (The ""Method"" value is the HTTP request method as specified in section
    5.1.1 of RFC 2616)
  */

  /* So IE browsers < v7 cut off the URI part at the query part when they
     evaluate the MD5 and some (IIS?) servers work with them so we may need to
     do the Digest IE-style. Note that the different ways cause different MD5
     sums to get sent.

     Apache servers can be set to do the Digest IE-style automatically using
     the BrowserMatch feature:
     http://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie

     Further details on Digest implementation differences:
     http://www.fngtps.com/2006/09/http-authentication
  */

  if(authp->iestyle && ((tmp = strchr((char *)uripath, '?')) != NULL))
    urilen = tmp - (char *)uripath;
  else
    urilen = strlen((char *)uripath);

  md5this = (unsigned char *)aprintf(""%s:%.*s"", request, urilen, uripath);

  if(d->qop && Curl_raw_equal(d->qop, ""auth-int"")) {
    /* We don't support auth-int for PUT or POST at the moment.
       TODO: replace md5 of empty string with entity-body for PUT/POST */
    unsigned char *md5this2 = (unsigned char *)
      aprintf(""%s:%s"", md5this, ""d41d8cd98f00b204e9800998ecf8427e"");
    Curl_safefree(md5this);
    md5this = md5this2;
  }

  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, ha2);

  if(d->qop) {
    md5this = (unsigned char *)aprintf(""%s:%s:%08x:%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       d->nc,
                                       d->cnonce,
                                       d->qop,
                                       ha2);
  }
  else {
    md5this = (unsigned char *)aprintf(""%s:%s:%s"",
                                       ha1,
                                       d->nonce,
                                       ha2);
  }
  if(!md5this)
    return CURLE_OUT_OF_MEMORY;

  CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
  Curl_md5it(md5buf, md5this);
  Curl_safefree(md5this);
  md5_to_ascii(md5buf, request_digest);

  /* for test case 64 (snooped from a Mozilla 1.3a request)

    Authorization: Digest username=""testuser"", realm=""testrealm"", \
    nonce=""1053604145"", uri=""/64"", response=""c55f7f30d83d774a3d2dcacf725abaca""

    Digest parameters are all quoted strings.  Username which is provided by
    the user will need double quotes and backslashes within it escaped.  For
    the other fields, this shouldn't be an issue.  realm, nonce, and opaque
    are copied as is from the server, escapes and all.  cnonce is generated
    with web-safe characters.  uri is already percent encoded.  nc is 8 hex
    characters.  algorithm and qop with standard values only contain web-safe
    chracters.
  */
  userp_quoted = string_quoted(userp);
  if(!userp_quoted)
    return CURLE_OUT_OF_MEMORY;

  if(d->qop) {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""cnonce=\""%s\"", ""
               ""nc=%08x, ""
               ""qop=%s, ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               d->cnonce,
               d->nc,
               d->qop,
               request_digest);

    if(Curl_raw_equal(d->qop, ""auth""))
      d->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0 padded
                  which tells to the server how many times you are using the
                  same nonce in the qop=auth mode. */
  }
  else {
    *allocuserpwd =
      aprintf( ""%sAuthorization: Digest ""
               ""username=\""%s\"", ""
               ""realm=\""%s\"", ""
               ""nonce=\""%s\"", ""
               ""uri=\""%.*s\"", ""
               ""response=\""%s\"""",
               proxy?""Proxy-"":"""",
               userp_quoted,
               d->realm,
               d->nonce,
               urilen, uripath, /* this is the PATH part of the URL */
               request_digest);
  }
  Curl_safefree(userp_quoted);
  if(!*allocuserpwd)
    return CURLE_OUT_OF_MEMORY;

  /* Add optional fields */
  if(d->opaque) {
    /* append opaque */
    tmp = aprintf(""%s, opaque=\""%s\"""", *allocuserpwd, d->opaque);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  if(d->algorithm) {
    /* append algorithm */
    tmp = aprintf(""%s, algorithm=\""%s\"""", *allocuserpwd, d->algorithm);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    free(*allocuserpwd);
    *allocuserpwd = tmp;
  }

  /* append CRLF + zero (3 bytes) to the userpwd header */
  userlen = strlen(*allocuserpwd);
  tmp = realloc(*allocuserpwd, userlen + 3);
  if(!tmp)
    return CURLE_OUT_OF_MEMORY;
  strcpy(&tmp[userlen], ""\r\n""); /* append the data */
  *allocuserpwd = tmp;

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_373.cpp,"[24, 0, 0, 0, 0, 0, 12, 0, 0, 0, 29, 0, 0, 0, 2, 408, 0, 0, 20, 20, 0, 0, 5, 43, 0, 0, 0, 0, 12, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 2, 227, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 22, 0, 6, 0, 26, 26, 6, 0, 47, 2, 0, 59, 0, 115, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_373.cpp,95
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_digest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_290.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_290.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_577.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_577.cpp,352,112,402,-1,"tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_374.cpp,"{
    /* nonce and cnonce are OUTSIDE the hash */
    tmp = aprintf(""%s:%s:%s"", ha1, d->nonce, d->cnonce);
    if(!tmp)
      return CURLE_OUT_OF_MEMORY;
    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* convert on non-ASCII machines */
    Curl_md5it(md5buf, (unsigned char *)tmp);
    Curl_safefree(tmp);
    md5_to_ascii(md5buf, ha1);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_374.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_374.cpp,106
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_291.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_578.cpp,22,22,60,-1,"snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_375.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_375.cpp,"{
  OM_uint32 major_status, minor_status;
  gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
  char name[2048];
  const char* service = ""HTTP"";

  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
                                              conn->host.name) + 1;
  if(token.length + 1 > sizeof(name))
    return EMSGSIZE;

  snprintf(name, sizeof(name), ""%s@%s"", service, proxy ? conn->proxy.name :
           conn->host.name);

  token.value = (void *) name;
  major_status = gss_import_name(&minor_status,
                                 &token,
                                 GSS_C_NT_HOSTBASED_SERVICE,
                                 server);

  return GSS_ERROR(major_status) ? -1 : 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_375.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 1, 57, 0, 0, 4, 5, 0, 0, 2, 8, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 3, 33, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 4, 4, 3, 0, 7, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_375.cpp,13
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_291.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_578.cpp,22,22,82,-1,"snprintf(buf, sizeof(buf), ""%s"", prefix);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_376.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_376.cpp,"{
  OM_uint32 maj_stat, min_stat;
  OM_uint32 msg_ctx = 0;
  gss_buffer_desc status_string;
  char buf[1024];
  size_t len;

  snprintf(buf, sizeof(buf), ""%s"", prefix);
  len = strlen(buf);
  do {
    maj_stat = gss_display_status(&min_stat,
                                  error_status,
                                  GSS_C_MECH_CODE,
                                  GSS_C_NO_OID,
                                  &msg_ctx,
                                  &status_string);
      if(sizeof(buf) > len + status_string.length + 1) {
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }
    gss_release_buffer(&min_stat, &status_string);
  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);

  infof(conn->data, ""%s\n"", buf);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_376.cpp,"[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 56, 0, 0, 5, 6, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 35, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 2, 1, 0, 0, 10, 0, 0, 7, 0, 24, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_376.cpp,10
706542615828488a5ad197d0ef3dd5e42eb739c4,"curl 7.44.0 (reduced)

Extract upstream curl using the following shell code.

url=git://github.com/bagder/curl.git &&
v=7.44.0 &&
r=1a7f66a3 &&
paths=""
  CMake/*
  CMakeLists.txt
  COPYING
  include/curl/*.h
  include/curl/curlbuild.h.cmake
  lib/*.c
  lib/*.h
  lib/CMakeLists.txt
  lib/Makefile.inc
  lib/curl_config.h.cmake
  lib/libcurl.rc
  lib/vtls/*.c
  lib/vtls/*.h
"" &&
mkdir curl-$v-g$r-reduced &&
git clone $url curl-git &&
date=$(cd curl-git && git log -n 1 --format='%cd' $r) &&
(cd curl-git && git checkout $r &&
 git archive --format=tar $r -- $paths) |
(cd curl-$v-g$r-reduced && tar xv &&
 rm lib/config-*.h) &&
echo ""g$r date: $date""",[],lib/http_negotiate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_291.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_291.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_578.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_578.cpp,22,22,92,-1,"snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_377.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_377.cpp,"{
        snprintf(buf + len, sizeof(buf) - len,
                 "": %s"", (char*) status_string.value);
      len += status_string.length;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_377.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 7, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_377.cpp,20
f8be9ba9c258698ed88a7510cf2ba3335491f3da,"cmGlobalGenerator: Base progress on Makefiles, not LocalGenerators.",[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_295.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_295.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_295.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_583.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_583.cpp,1148,1148,1150,1150,"sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->Makefiles.size()));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_378.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_378.cpp,"{
  this->FirstTimeProgress = 0.0f;
  this->ClearGeneratorMembers();

  // start with this directory
  cmLocalGenerator *lg = this->MakeLocalGenerator();
  this->Makefiles.push_back(lg->GetMakefile());
  this->LocalGenerators.push_back(lg);

  // set the Start directories
  lg->GetMakefile()->SetCurrentSourceDirectory
    (this->CMakeInstance->GetHomeDirectory());
  lg->GetMakefile()->SetCurrentBinaryDirectory
    (this->CMakeInstance->GetHomeOutputDirectory());

  this->BinaryDirectories.insert(
      this->CMakeInstance->GetHomeOutputDirectory());

  // now do it
  lg->GetMakefile()->Configure();
  lg->GetMakefile()->EnforceDirectoryLevelRules();

  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmState::INTERNAL);

  // check for link libraries and include directories containing ""NOTFOUND""
  // and for infinite loops
  this->CheckLocalGenerators();

  // at this point this->LocalGenerators has been filled,
  // so create the map from project name to vector of local generators
  this->FillProjectMap();

  if ( this->CMakeInstance->GetWorkingMode() == cmake::NORMAL_MODE)
    {
    std::ostringstream msg;
    if(cmSystemTools::GetErrorOccuredFlag())
      {
      msg << ""Configuring incomplete, errors occurred!"";
      const char* logs[] = {""CMakeOutput.log"", ""CMakeError.log"", 0};
      for(const char** log = logs; *log; ++log)
        {
        std::string f = this->CMakeInstance->GetHomeOutputDirectory();
        f += this->CMakeInstance->GetCMakeFilesDirectory();
        f += ""/"";
        f += *log;
        if(cmSystemTools::FileExists(f.c_str()))
          {
          msg << ""\nSee also \"""" << f << ""\""."";
          }
        }
      }
    else
      {
      msg << ""Configuring done"";
      }
    this->CMakeInstance->UpdateProgress(msg.str().c_str(), -1);
    }

  unsigned int i;

  // Put a copy of each global target in every directory.
  cmTargets globalTargets;
  this->CreateDefaultGlobalTargets(&globalTargets);

  for (i = 0; i < this->LocalGenerators.size(); ++i)
    {
    cmMakefile* mf = this->LocalGenerators[i]->GetMakefile();
    cmTargets* targets = &(mf->GetTargets());
    cmTargets::iterator tit;
    for ( tit = globalTargets.begin(); tit != globalTargets.end(); ++ tit )
      {
      (*targets)[tit->first] = tit->second;
      (*targets)[tit->first].SetMakefile(mf);
      }
    }

}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_378.cpp,"[3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 2, 189, 0, 0, 10, 11, 0, 0, 9, 15, 0, 0, 0, 0, 6, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 91, 0, 66, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 5, 0, 6, 3, 1, 0, 41, 0, 0, 23, 0, 19, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_378.cpp,26
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_296.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_584.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_584.cpp,1886,2007,1899,2017,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_379.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_379.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_379.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_379.cpp,21
d0915bc86f294707411ae525e70fa20965f1aeec,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_296.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_296.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_296.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_584.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_584.cpp,1886,2007,1896,2026,,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_380.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_380.cpp,"f(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_380.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 6, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_380.cpp,18
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl+C.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl+C and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_298.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_298.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_298.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_594.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_594.cpp,1886,2007,1899,2017,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());","_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_381.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_381.cpp,"{
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_381.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_381.cpp,21
1feafc643b1c50fd0fa8171a4170065ca39d4d4c,"KWSys 2015-07-30 (f63febb7)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ f63febb7 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' c9336bcf..f63febb7
Brad King (1):
      83b4a6b8 Process: Fix conversion warning in testProcess.c

James Johnston (7):
      4cd8846c Process: Remove trailing whitespace in ProcessUNIX.c
      b1c44c58 Process: Refactor sleeping code in testProcess.c.
      faff2ab0 Process: Wait for children to terminate on Ctrl+C.
      ef517b19 Process: Added initial support for process groups.
      906c2cae Process: Added test cases for testing Ctrl+C and process groups.
      52874e6a Process: Fix leaked file descriptor in ProcessUNIX
      f63febb7 Process: Fix error message for startup failure on Windows",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_298.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_298.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_298.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_594.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_594.cpp,1886,2007,1896,2026,,"_snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""WideCharToMultiByte failed with error 0x%X"",
                  error, GetLastError());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_382.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_382.cpp,"f(length < 1)
        {
        /* FormatMessage failed.  Use a default message.  */
        _snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
                  ""Process execution failed with error 0x%X.  ""
                  ""FormatMessage failed with error 0x%X"",
                  original, GetLastError());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_382.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 6, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_382.cpp,18
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_604.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_604.cpp,209,288,213,292,"fprintf(fout,""EXPORTS \n"");","fprintf(this->FileOut,""EXPORTS \n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_383.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_383.cpp,"{
               fImportFlag = 0;
               fprintf(fout,""EXPORTS \n"");
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_383.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_383.cpp,43
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_605.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_605.cpp,228,307,233,313,"fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());","fprintf(this->FileOut, ""\t%s \t DATA\n"", symbol.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_384.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_384.cpp,"{
                  // Read only (i.e. constants) must be excluded
                  fprintf(fout, ""\t%s \t DATA\n"", symbol.c_str());
               }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_384.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_384.cpp,63
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_605.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_605.cpp,228,307,237,317,"fprintf(fout, ""\t%s\n"", symbol.c_str());","fprintf(this->FileOut, ""\t%s\n"", symbol.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_385.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_385.cpp,"{
                     fprintf(fout, ""\t%s\n"", symbol.c_str());
                  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_385.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_385.cpp,67
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_606.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_606.cpp,252,332,256,336,"fprintf(fout,""IMPORTS \n"");","fprintf(this->FileOut,""IMPORTS \n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_386.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_386.cpp,"{
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_386.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_386.cpp,86
069aa93b555293679f4b8c07623133ba62a74ee4,"bindexplib: Add support for ""/bigobj"" format objects",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_300.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_606.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_606.cpp,252,332,258,338,"fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1);","fprintf(this->FileOut, ""\t%s DATA \n"", symbol.c_str()+1);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_387.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_387.cpp,"{
            symbol = stringTable + pSymbolTable->N.Name.Long;
            while (isspace(symbol[0]))  symbol.erase(0,1);
            if (symbol[0] == '_') symbol.erase(0,1);
            if (!fImportFlag) {
               fImportFlag = 1;
               fprintf(fout,""IMPORTS \n"");
            }
            fprintf(fout, ""\t%s DATA \n"", symbol.c_str()+1);
         }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_387.cpp,"[2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 2, 0, 0, 6, 0, 0, 6, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_387.cpp,88
de70c922d9c846cf3a6fabfbedd054c02f4b8934,"bindexplib: Teach DumpFile to return errors

This will allow callers to know if it worked.",[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_301.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_301.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_301.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_607.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_607.cpp,309,310,311,312,"fprintf(stderr, ""Couldn't open file with CreateFile()\n"");","fprintf(stderr, ""Couldn't open file '%s' with CreateFile()\n"", filename);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_388.cpp,"{
      fprintf(stderr, ""Couldn't open file with CreateFile()\n"");
      return;
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_388.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_388.cpp,13
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,263,-1,"fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_389.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_389.cpp,"{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i++ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_389.cpp,"[2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 95, 0, 0, 5, 5, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 2, 1, 1, 0, 13, 0, 0, 15, 0, 32, 2, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_389.cpp,9
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,266,-1,"fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_390.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_390.cpp,"{
   unsigned i;
   PSTR stringTable;
   std::string sectionName;
   std::string sectionCharacter;
   int iSectNum;

   fprintf(fout, ""Symbol Table - %X entries  (* = auxillary symbol)\n"",
      cSymbols);

   fprintf(fout,
      ""Indx Name                 Value    Section    cAux  Type    Storage  Character\n""
      ""---- -------------------- -------- ---------- ----- ------- -------- ---------\n"");

   /*
   * The string table apparently starts right after the symbol table
   */
   stringTable = (PSTR)&pSymbolTable[cSymbols];

   for ( i=0; i < cSymbols; i++ ) {
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_390.cpp,"[2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 95, 0, 0, 5, 5, 0, 0, 1, 12, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 53, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 2, 1, 1, 0, 13, 0, 0, 15, 0, 32, 2, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_390.cpp,12
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,276,-1,"fprintf(fout, ""%04X "", i);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_391.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_391.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_391.cpp,22
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,278,-1,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_392.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_392.cpp,"fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_392.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_392.cpp,24
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,280,-1,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_393.cpp,"fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_393.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_393.cpp,26
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,282,-1,"fprintf(fout, "" %08X"", pSymbolTable->Value);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_394.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_394.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_394.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_394.cpp,28
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,286,-1,"fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_395.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_395.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_395.cpp,32
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,293,-1,"fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_396.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_396.cpp,"{
      fprintf(fout, ""%04X "", i);
      if ( pSymbolTable->N.Name.Short != 0 )
         fprintf(fout, ""%-20.8s"", pSymbolTable->N.ShortName);
      else
         fprintf(fout, ""%-20s"", stringTable + pSymbolTable->N.Name.Long);

      fprintf(fout, "" %08X"", pSymbolTable->Value);

      iSectNum = pSymbolTable->SectionNumber;
      GetSectionName(pSymbolTable, sectionName);
      fprintf(fout, "" sect:%s aux:%X type:%02X st:%s"",
         sectionName.c_str(),
         pSymbolTable->NumberOfAuxSymbols,
         pSymbolTable->Type,
         GetSZStorageClass(pSymbolTable->StorageClass) );

      GetSectionCharacteristics(pSectionHeaders,iSectNum,sectionCharacter);
      fprintf(fout,"" hc: %s \n"",sectionCharacter.c_str());
#if 0
      if ( pSymbolTable->NumberOfAuxSymbols )
         DumpAuxSymbols(pSymbolTable);
#endif

      /*
      * Take into account any aux symbols
      */
      i += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable += pSymbolTable->NumberOfAuxSymbols;
      pSymbolTable++;
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_396.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 67, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 11, 0, 0, 12, 0, 27, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_396.cpp,39
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,340,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_397.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_397.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_397.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_397.cpp,24
4ff09893232b26b5c2961fb1e2a31836cad00a35,bindexplib: Drop code that CMake does not need,[],Source/bindexplib.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_303.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_609.cpp,71,71,342,-1,"fprintf(fout, ""\t%s\n"", symbol.c_str()+1);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_398.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_398.cpp,"{
            if (pSymbolTable->N.Name.Short != 0) {
               symbol = """";
               symbol.insert(0, (const char *)(pSymbolTable->N.ShortName), 8);
            } else {
               symbol = stringTable + pSymbolTable->N.Name.Long;
            }
            std::string::size_type posAt = symbol.find('@');
            if (posAt != std::string::npos) symbol.erase(posAt);
#ifndef _MSC_VER
            fprintf(fout, ""\t%s\n"", symbol.c_str());
#else
            fprintf(fout, ""\t%s\n"", symbol.c_str()+1);
#endif
         }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_398.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 49, 0, 0, 1, 1, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 2, 0, 7, 0, 0, 6, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_398.cpp,26
59e21ffa134faf0b089d9a704b3763e7f6f237d5,Port static calls from cmLocalGenerator to cmOutputConverter.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_306.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_306.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_306.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_614.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_614.cpp,322,322,323,323,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmOutputConverter::EscapeForCMake(flags?flags:"""").c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_399.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_399.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_399.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_399.cpp,302
9486769866661e3aa76dd588ca5a7466e2969dc3,Don't use a cmLocalGenerator instance to call static methods.,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_308.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_308.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_308.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_616.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_616.cpp,323,322,324,323,"fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              cmLocalGenerator::EscapeForCMake(flags?flags:"""").c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_400.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_400.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags);
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_400.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 31, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 8, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_400.cpp,303
8521fdf56e4908676c28c6bbdda3f1fb2284d3d7,"Makefile: Fix output during parallel builds (#12991)

Replace use of separate ""cmake -E cmake_progress_report"" and ""cmake -E
cmake_echo_color"" commands to report the progress and message portions
of build output lines with --progress-* options to the latter to print
everything with a single command.  The line buffering of the stdout FILE
stream should cause the whole line to be printed with one atomic write.
This will avoid inter-mixing of line-wise messages from different
processes during a parallel build.",[u'https://gitlab.kitware.com/cmake/cmake/issues/12991'],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_313.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_313.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_313.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_623.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_623.cpp,534,534,567,-1,"fprintf(progFile,""empty"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_401.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_401.cpp,"{
          fprintf(progFile,""empty"");
          fclose(progFile);
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_401.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_401.cpp,426
8521fdf56e4908676c28c6bbdda3f1fb2284d3d7,"Makefile: Fix output during parallel builds (#12991)

Replace use of separate ""cmake -E cmake_progress_report"" and ""cmake -E
cmake_echo_color"" commands to report the progress and message portions
of build output lines with --progress-* options to the latter to print
everything with a single command.  The line buffering of the stdout FILE
stream should cause the whole line to be printed with one atomic write.
This will avoid inter-mixing of line-wise messages from different
processes during a parallel build.",[u'https://gitlab.kitware.com/cmake/cmake/issues/12991'],Source/cmcmd.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_313.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_313.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_313.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_623.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_623.cpp,534,534,576,-1,"fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_402.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_402.cpp,"{
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_402.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_402.cpp,435
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_635.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_635.cpp,112,112,118,118,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_403.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_403.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_403.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_403.cpp,13
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_635.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_635.cpp,112,112,127,127,"sprintf(buf, ""%s\\*"", name);","sprintf(buf, ""%s\\*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_404.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_404.cpp,"{
      sprintf(buf, ""%s\\*"", name);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_404.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_404.cpp,22
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_635.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_635.cpp,112,112,131,131,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_405.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_405.cpp,"{
      sprintf(buf, ""%s/*"", name);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_405.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_405.cpp,26
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_636.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_636.cpp,153,153,167,167,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_406.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_406.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_406.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_406.cpp,12
60c783676c91ff1ded2ed5e6fd50d0f9664032e5,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_322.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_636.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_636.cpp,153,153,172,172,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_407.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_407.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_407.cpp,17
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_637.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_637.cpp,112,112,118,118,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_408.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_408.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_408.cpp,13
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_637.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_637.cpp,112,112,127,127,"sprintf(buf, ""%s\\*"", name);","sprintf(buf, ""%s\\*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_409.cpp,"{
      sprintf(buf, ""%s\\*"", name);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_409.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_409.cpp,22
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_637.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_637.cpp,112,112,131,131,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_410.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_410.cpp,"{
      sprintf(buf, ""%s/*"", name);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_410.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_410.cpp,26
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_638.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_638.cpp,153,153,167,167,"sprintf(buf, ""%s*"", name);","sprintf(buf, ""%s*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_411.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_411.cpp,"{
    buf = new char[n + 1 + 1];
    sprintf(buf, ""%s*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_411.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_411.cpp,12
158c6d1cffe863fde284d4e5eeeb8129d40ce0e9,"KWSys 2014-08-04 (e787837a)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ e787837a | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 65b36ede..e787837a
Ben Boeckel (4):
      9927862c SystemTools: more string replacements
      b3d598b0 strings: remove unnecessary c_str calls
      ffe94132 SystemTools: use char instead of const char*
      f29fec7c Directory: accept strings in methods

Rashad M (1):
      e787837a SharedForward: Cast away const to call execvp on MinGW 64-bit

Change-Id: I96437b332971670cfcd953717c5563e9ba0f2b99",[],Directory.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_323.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_638.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_638.cpp,153,153,172,172,"sprintf(buf, ""%s/*"", name);","sprintf(buf, ""%s/*"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_412.cpp,"{
    buf = new char[n + 2 + 1];
    sprintf(buf, ""%s/*"", name);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_412.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_412.cpp,17
71c981a213a463d05b4bdc73dfb445c80ce2a476,"Encoding: Fix potential encoding issues with libarchive on Windows.

Because the 8bit string encoding in libarchive can be different than
the 8bit string encoding in CMake, change to call the wide version
of libarchive functions.  They are different if CMake is configured
to use UTF-8 as the internal encoding.

Create helper functions for some libarchive calls to use wstring
internally on platforms supporting it.",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_324.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_324.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_324.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_639.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_639.cpp,1581,1606,1583,1608,"fprintf(out, ""%s"", archive_entry_pathname(entry));","fprintf(out, ""%s"", cm_archive_entry_pathname(entry).c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_413.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_413.cpp,"{
  char                   tmp[100];
  size_t                         w;
  const char            *p;
  const char            *fmt;
  time_t                         tim;
  static time_t          now;
  size_t u_width = 6;
  size_t gs_width = 13;

  /*
   * We avoid collecting the entire list in memory at once by
   * listing things as we see them.  However, that also means we can't
   * just pre-compute the field widths.  Instead, we start with guesses
   * and just widen them as necessary.  These numbers are completely
   * arbitrary.
   */
  if (!now)
    {
    time(&now);
    }
  fprintf(out, ""%s %d "",
          archive_entry_strmode(entry),
          archive_entry_nlink(entry));

  /* Use uname if it's present, else uid. */
  p = archive_entry_uname(entry);
  if ((p == NULL) || (*p == '\0'))
    {
    sprintf(tmp, ""%lu "",
            (unsigned long)archive_entry_uid(entry));
    p = tmp;
    }
  w = strlen(p);
  if (w > u_width)
    {
    u_width = w;
    }
  fprintf(out, ""%-*s "", (int)u_width, p);
  /* Use gname if it's present, else gid. */
  p = archive_entry_gname(entry);
  if (p != NULL && p[0] != '\0')
    {
    fprintf(out, ""%s"", p);
    w = strlen(p);
    }
  else
    {
    sprintf(tmp, ""%lu"",
            (unsigned long)archive_entry_gid(entry));
    w = strlen(tmp);
    fprintf(out, ""%s"", tmp);
    }

  /*
   * Print device number or file size, right-aligned so as to make
   * total width of group and devnum/filesize fields be gs_width.
   * If gs_width is too small, grow it.
   */
  if (archive_entry_filetype(entry) == AE_IFCHR
      || archive_entry_filetype(entry) == AE_IFBLK)
    {
    sprintf(tmp, ""%lu,%lu"",
            (unsigned long)archive_entry_rdevmajor(entry),
            (unsigned long)archive_entry_rdevminor(entry));
    }
  else
    {
    /*
     * Note the use of platform-dependent macros to format
     * the filesize here.  We need the format string and the
     * corresponding type for the cast.
     */
    sprintf(tmp, BSDTAR_FILESIZE_PRINTF,
            (BSDTAR_FILESIZE_TYPE)archive_entry_size(entry));
    }
  if (w + strlen(tmp) >= gs_width)
    {
    gs_width = w+strlen(tmp)+1;
    }
  fprintf(out, ""%*s"", (int)(gs_width - w), tmp);

  /* Format the time using 'ls -l' conventions. */
  tim = archive_entry_mtime(entry);
#define HALF_YEAR (time_t)365 * 86400 / 2
#if defined(_WIN32) && !defined(__CYGWIN__)
  /* Windows' strftime function does not support %e format. */
#define DAY_FMT  ""%d""
#else
#define DAY_FMT  ""%e""  /* Day number without leading zeros */
#endif
  if (tim < now - HALF_YEAR || tim > now + HALF_YEAR)
    {
    fmt = DAY_FMT "" %b  %Y"";
    }
  else
    {
    fmt = DAY_FMT "" %b %H:%M"";
    }
  strftime(tmp, sizeof(tmp), fmt, localtime(&tim));
  fprintf(out, "" %s "", tmp);
  fprintf(out, ""%s"", archive_entry_pathname(entry));

  /* Extra information for links. */
  if (archive_entry_hardlink(entry)) /* Hard link */
    {
    fprintf(out, "" link to %s"",
            archive_entry_hardlink(entry));
    }
  else if (archive_entry_symlink(entry)) /* Symbolic link */
    {
    fprintf(out, "" -> %s"", archive_entry_symlink(entry));
    }
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_413.cpp,"[10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 3, 159, 0, 0, 8, 8, 0, 0, 2, 21, 0, 0, 0, 0, 2, 0, 41, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 116, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 2, 0, 9, 9, 4, 0, 43, 0, 0, 26, 1, 76, 6, 0, 3, 3, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_413.cpp,102
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_326.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_641.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_641.cpp,254,255,255,256,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_414.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_414.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_414.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_414.cpp,37
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_326.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_642.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_642.cpp,968,970,970,972,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_415.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_415.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_415.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_415.cpp,2
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_326.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_326.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_642.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_642.cpp,968,970,977,979,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_416.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_416.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_416.cpp,9
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_327.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_643.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_643.cpp,435,435,439,440,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_417.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_417.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_417.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_417.cpp,3
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_327.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_643.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_643.cpp,435,435,445,446,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_418.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_418.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_418.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_418.cpp,9
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_327.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_327.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_643.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_643.cpp,435,435,451,452,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_419.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_419.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_419.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_419.cpp,15
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_328.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_646.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_646.cpp,449,450,451,452,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_420.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_420.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_420.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_420.cpp,430
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_328.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_647.cpp,465,466,466,467,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_421.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_421.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_421.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_421.cpp,445
e4e76f286c2eb5cfa822f89145611d02dc9d39b3,"Merge branch 'master' into osx-CFBundle-info-plist

Resolve conflict in Source/cmOSXBundleGenerator.cxx by taking
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_328.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_328.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_647.cpp,465,466,471,473,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_422.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_422.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_422.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_422.cpp,450
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_330.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_330.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_330.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_649.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_649.cpp,1203,1285,1206,1295,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Crypto codec not supported yet (ID: 0x%lX)"", zip->codec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_423.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_423.cpp,"{
	case _7Z_COPY:
		break;

	case _7Z_LZMA: case _7Z_LZMA2:
#ifdef HAVE_LZMA_H
#if LZMA_VERSION_MAJOR >= 5
/* Effectively disable the limiter. */
#define LZMA_MEMLIMIT   UINT64_MAX
#else
/* NOTE: This needs to check memory size which running system has. */
#define LZMA_MEMLIMIT   (1U << 30)
#endif
	{
		lzma_options_delta delta_opt;
		lzma_filter filters[LZMA_FILTERS_MAX];
#if LZMA_VERSION < 50000030
		lzma_filter *ff;
#endif
		int fi = 0;

		if (zip->lzstream_valid) {
			lzma_end(&(zip->lzstream));
			zip->lzstream_valid = 0;
		}

		/*
		 * NOTE: liblzma incompletely handle the BCJ+LZMA compressed
		 * data made by 7-Zip because 7-Zip does not add End-Of-
		 * Payload Marker(EOPM) at the end of LZMA compressed data,
		 * and so liblzma cannot know the end of the compressed data
		 * without EOPM. So consequently liblzma will not return last
		 * three or four bytes of uncompressed data because
		 * LZMA_FILTER_X86 filter does not handle input data if its
		 * data size is less than five bytes. If liblzma detect EOPM
		 * or know the uncompressed data size, liblzma will flush out
		 * the remaining that three or four bytes of uncompressed
		 * data. That is why we have to use our converting program
		 * for BCJ+LZMA. If we were able to tell the uncompressed
		 * size to liblzma when using lzma_raw_decoder() liblzma
		 * could correctly deal with BCJ+LZMA. But unfortunately
		 * there is no way to do that. 
		 * Discussion about this can be found at XZ Utils forum.
		 */
		if (coder2 != NULL) {
			zip->codec2 = coder2->codec;

			filters[fi].options = NULL;
			switch (zip->codec2) {
			case _7Z_X86:
				if (zip->codec == _7Z_LZMA2) {
					filters[fi].id = LZMA_FILTER_X86;
					fi++;
				} else
					/* Use our filter. */
					x86_Init(zip);
				break;
			case _7Z_X86_BCJ2:
				/* Use our filter. */
				zip->bcj_state = 0;
				break;
			case _7Z_DELTA:
				filters[fi].id = LZMA_FILTER_DELTA;
				memset(&delta_opt, 0, sizeof(delta_opt));
				delta_opt.type = LZMA_DELTA_TYPE_BYTE;
				delta_opt.dist = 1;
				filters[fi].options = &delta_opt;
				fi++;
				break;
			/* Following filters have not been tested yet. */
			case _7Z_POWERPC:
				filters[fi].id = LZMA_FILTER_POWERPC;
				fi++;
				break;
			case _7Z_IA64:
				filters[fi].id = LZMA_FILTER_IA64;
				fi++;
				break;
			case _7Z_ARM:
				filters[fi].id = LZMA_FILTER_ARM;
				fi++;
				break;
			case _7Z_ARMTHUMB:
				filters[fi].id = LZMA_FILTER_ARMTHUMB;
				fi++;
				break;
			case _7Z_SPARC:
				filters[fi].id = LZMA_FILTER_SPARC;
				fi++;
				break;
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Unexpected codec ID: %lX"", zip->codec2);
				return (ARCHIVE_FAILED);
			}
		}

		if (zip->codec == _7Z_LZMA2)
			filters[fi].id = LZMA_FILTER_LZMA2;
		else
			filters[fi].id = LZMA_FILTER_LZMA1;
		filters[fi].options = NULL;
#if LZMA_VERSION < 50000030
		ff = &filters[fi];
#endif
		r = lzma_properties_decode(&filters[fi], NULL,
		    coder1->properties, (size_t)coder1->propertiesSize);
		if (r != LZMA_OK) {
			set_error(a, r);
			return (ARCHIVE_FAILED);
		}
		fi++;

		filters[fi].id = LZMA_VLI_UNKNOWN;
		filters[fi].options = NULL;
		r = lzma_raw_decoder(&(zip->lzstream), filters);
#if LZMA_VERSION < 50000030
		free(ff->options);
#endif
		if (r != LZMA_OK) {
			set_error(a, r);
			return (ARCHIVE_FAILED);
		}
		zip->lzstream_valid = 1;
		zip->lzstream.total_in = 0;
		zip->lzstream.total_out = 0;
		break;
	}
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LZMA codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_BZ2:
#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
		if (zip->bzstream_valid) {
			BZ2_bzDecompressEnd(&(zip->bzstream));
			zip->bzstream_valid = 0;
		}
		r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 0);
		if (r == BZ_MEM_ERROR)
			r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 1);
		if (r != BZ_OK) {
			int err = ARCHIVE_ERRNO_MISC;
			const char *detail = NULL;
			switch (r) {
			case BZ_PARAM_ERROR:
				detail = ""invalid setup parameter"";
				break;
			case BZ_MEM_ERROR:
				err = ENOMEM;
				detail = ""out of memory"";
				break;
			case BZ_CONFIG_ERROR:
				detail = ""mis-compiled library"";
				break;
			}
			archive_set_error(&a->archive, err,
			    ""Internal error initializing decompressor: %s"",
			    detail != NULL ? detail : ""??"");
			zip->bzstream_valid = 0;
			return (ARCHIVE_FAILED);
		}
		zip->bzstream_valid = 1;
		zip->bzstream.total_in_lo32 = 0;
		zip->bzstream.total_in_hi32 = 0;
		zip->bzstream.total_out_lo32 = 0;
		zip->bzstream.total_out_hi32 = 0;
		break;
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""BZ2 codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_DEFLATE:
#ifdef HAVE_ZLIB_H
		if (zip->stream_valid)
			r = inflateReset(&(zip->stream));
		else
			r = inflateInit2(&(zip->stream),
			    -15 /* Don't check for zlib header */);
		if (r != Z_OK) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't initialize zlib stream."");
			return (ARCHIVE_FAILED);
		}
		zip->stream_valid = 1;
		zip->stream.total_in = 0;
		zip->stream.total_out = 0;
		break;
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""DEFLATE codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_PPMD:
	{
		unsigned order;
		uint32_t msize;

		if (zip->ppmd7_valid) {
			__archive_ppmd7_functions.Ppmd7_Free(
			    &zip->ppmd7_context, &g_szalloc);
			zip->ppmd7_valid = 0;
		}

		if (coder1->propertiesSize < 5) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Malformed PPMd parameter"");
			return (ARCHIVE_FAILED);
		}
		order = coder1->properties[0];
		msize = archive_le32dec(&(coder1->properties[1]));
		if (order < PPMD7_MIN_ORDER || order > PPMD7_MAX_ORDER ||
		    msize < PPMD7_MIN_MEM_SIZE || msize > PPMD7_MAX_MEM_SIZE) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Malformed PPMd parameter"");
			return (ARCHIVE_FAILED);
		}
		__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);
		r = __archive_ppmd7_functions.Ppmd7_Alloc(
			&zip->ppmd7_context, msize, &g_szalloc);
		if (r == 0) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Coludn't allocate memory for PPMd"");
			return (ARCHIVE_FATAL);
		}
		__archive_ppmd7_functions.Ppmd7_Init(
			&zip->ppmd7_context, order);
		__archive_ppmd7_functions.Ppmd7z_RangeDec_CreateVTable(
			&zip->range_dec);
		zip->ppmd7_valid = 1;
		zip->ppmd7_stat = 0;
		zip->ppstream.overconsumed = 0;
		zip->ppstream.total_in = 0;
		zip->ppstream.total_out = 0;
		break;
	}
	case _7Z_X86:
	case _7Z_X86_BCJ2:
	case _7Z_POWERPC:
	case _7Z_IA64:
	case _7Z_ARM:
	case _7Z_ARMTHUMB:
	case _7Z_SPARC:
	case _7Z_DELTA:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unexpected codec ID: %lX"", zip->codec);
		return (ARCHIVE_FAILED);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unknown codec ID: %lX"", zip->codec);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_423.cpp,"[20, 0, 0, 0, 16, 0, 13, 2, 25, 2, 23, 0, 0, 0, 1, 467, 0, 0, 8, 8, 0, 0, 3, 52, 0, 0, 0, 0, 2, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 1, 245, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 19, 0, 18, 16, 8, 0, 35, 0, 0, 82, 0, 78, 20, 0, 2, 2, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_423.cpp,284
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_651.cpp,1292,1319,1313,1361,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_424.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_424.cpp,"{
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_424.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_424.cpp,13
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_651.cpp,1292,1319,1322,1368,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Missing number"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_425.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_425.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_425.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_425.cpp,0
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_651.cpp,1292,1319,1322,1374,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_426.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_426.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_426.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_426.cpp,0
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_651.cpp,1292,1319,1322,1380,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Not enough arguments"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_427.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_427.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_427.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_427.cpp,0
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_331.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_651.cpp,1292,1319,1322,1386,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""%s"", error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_428.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_428.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_428.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_428.cpp,0
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_334.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_334.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_334.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_657.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_657.cpp,983,992,985,995,,"archive_string_sprintf(str, "" inode=%jd"", (intmax_t)me->ino);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_429.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_429.cpp,"(me->filetype) {
	case AE_IFLNK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=link"");
		if ((keys & F_SLINK) != 0) {
			archive_strcat(str, "" link="");
			mtree_quote(str, me->symlink.s);
		}
		break;
	case AE_IFSOCK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=socket"");
		break;
	case AE_IFCHR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=char"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFBLK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=block"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFDIR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=dir"");
		break;
	case AE_IFIFO:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=fifo"");
		break;
	case AE_IFREG:
	default:	/* Handle unknown file types as regular files. */
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=file"");
		if ((keys & F_SIZE) != 0)
			archive_string_sprintf(str, "" size=%jd"",
			    (intmax_t)me->size);
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_429.cpp,"[11, 0, 0, 0, 7, 0, 0, 0, 7, 1, 12, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 12, 0, 0, 13, 0, 29, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_429.cpp,73
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_334.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_334.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_334.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_657.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_657.cpp,983,992,985,997,,"archive_string_sprintf(str,
		    "" resdevice=native,%ju,%ju"",
		    (uintmax_t)me->devmajor,
		    (uintmax_t)me->devminor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_430.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_430.cpp,"(me->filetype) {
	case AE_IFLNK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=link"");
		if ((keys & F_SLINK) != 0) {
			archive_strcat(str, "" link="");
			mtree_quote(str, me->symlink.s);
		}
		break;
	case AE_IFSOCK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=socket"");
		break;
	case AE_IFCHR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=char"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFBLK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=block"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFDIR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=dir"");
		break;
	case AE_IFIFO:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=fifo"");
		break;
	case AE_IFREG:
	default:	/* Handle unknown file types as regular files. */
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=file"");
		if ((keys & F_SIZE) != 0)
			archive_string_sprintf(str, "" size=%jd"",
			    (intmax_t)me->size);
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_430.cpp,"[11, 0, 0, 0, 7, 0, 0, 0, 7, 1, 12, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 12, 0, 0, 13, 0, 29, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_430.cpp,73
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_662.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_662.cpp,376,399,442,434,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_431.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_431.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_431.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_431.cpp,67
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_662.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_662.cpp,376,399,402,428,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_432.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_432.cpp,"(zip->opt_sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_write(&(a->archive));
		zip->init_default_conversion = 1;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_432.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_432.cpp,27
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_664.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_664.cpp,663,803,678,815,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_433.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_433.cpp,"{
	case COMPRESSION_STORE:
		ret = __archive_write_output(a, buff, s);
		if (ret != ARCHIVE_OK) return (ret);
		zip->written_bytes += s;
		zip->remaining_data_bytes -= s;
		l->compressed_size += s;
		l->crc32 = crc32(l->crc32, buff, (unsigned)s);
		return (s);
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		zip->stream.next_in = (unsigned char*)(uintptr_t)buff;
		zip->stream.avail_in = (uInt)s;
		do {
			ret = deflate(&zip->stream, Z_NO_FLUSH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			if (zip->stream.avail_out == 0) {
				ret = __archive_write_output(a, zip->buf,
					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_433.cpp,"[5, 0, 0, 1, 0, 0, 6, 0, 2, 1, 6, 0, 0, 0, 0, 125, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 6, 0, 0, 16, 0, 17, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_433.cpp,47
2f1978632b709a9370b3cb1137375c05351d149c,"Merge branch 'libarchive-upstream' into update-libarchive

Resolve conflicts in favor of the upstream side where possible.
Resolve a logical conflict in archive_windows.h where the upstream
port to Watcom was done slightly differently from ours.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_335.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_664.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_664.cpp,663,803,730,897,,"archive_set_error(&a->archive, ENOMEM,
				""Can't allocate zip data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_434.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_434.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_434.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_434.cpp,0
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_337.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_337.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_666.cpp,1203,1285,1206,1295,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Crypto codec not supported yet (ID: 0x%lX)"", zip->codec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_435.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_435.cpp,"{
	case _7Z_COPY:
		break;

	case _7Z_LZMA: case _7Z_LZMA2:
#ifdef HAVE_LZMA_H
#if LZMA_VERSION_MAJOR >= 5
/* Effectively disable the limiter. */
#define LZMA_MEMLIMIT   UINT64_MAX
#else
/* NOTE: This needs to check memory size which running system has. */
#define LZMA_MEMLIMIT   (1U << 30)
#endif
	{
		lzma_options_delta delta_opt;
		lzma_filter filters[LZMA_FILTERS_MAX];
#if LZMA_VERSION < 50000030
		lzma_filter *ff;
#endif
		int fi = 0;

		if (zip->lzstream_valid) {
			lzma_end(&(zip->lzstream));
			zip->lzstream_valid = 0;
		}

		/*
		 * NOTE: liblzma incompletely handle the BCJ+LZMA compressed
		 * data made by 7-Zip because 7-Zip does not add End-Of-
		 * Payload Marker(EOPM) at the end of LZMA compressed data,
		 * and so liblzma cannot know the end of the compressed data
		 * without EOPM. So consequently liblzma will not return last
		 * three or four bytes of uncompressed data because
		 * LZMA_FILTER_X86 filter does not handle input data if its
		 * data size is less than five bytes. If liblzma detect EOPM
		 * or know the uncompressed data size, liblzma will flush out
		 * the remaining that three or four bytes of uncompressed
		 * data. That is why we have to use our converting program
		 * for BCJ+LZMA. If we were able to tell the uncompressed
		 * size to liblzma when using lzma_raw_decoder() liblzma
		 * could correctly deal with BCJ+LZMA. But unfortunately
		 * there is no way to do that. 
		 * Discussion about this can be found at XZ Utils forum.
		 */
		if (coder2 != NULL) {
			zip->codec2 = coder2->codec;

			filters[fi].options = NULL;
			switch (zip->codec2) {
			case _7Z_X86:
				if (zip->codec == _7Z_LZMA2) {
					filters[fi].id = LZMA_FILTER_X86;
					fi++;
				} else
					/* Use our filter. */
					x86_Init(zip);
				break;
			case _7Z_X86_BCJ2:
				/* Use our filter. */
				zip->bcj_state = 0;
				break;
			case _7Z_DELTA:
				filters[fi].id = LZMA_FILTER_DELTA;
				memset(&delta_opt, 0, sizeof(delta_opt));
				delta_opt.type = LZMA_DELTA_TYPE_BYTE;
				delta_opt.dist = 1;
				filters[fi].options = &delta_opt;
				fi++;
				break;
			/* Following filters have not been tested yet. */
			case _7Z_POWERPC:
				filters[fi].id = LZMA_FILTER_POWERPC;
				fi++;
				break;
			case _7Z_IA64:
				filters[fi].id = LZMA_FILTER_IA64;
				fi++;
				break;
			case _7Z_ARM:
				filters[fi].id = LZMA_FILTER_ARM;
				fi++;
				break;
			case _7Z_ARMTHUMB:
				filters[fi].id = LZMA_FILTER_ARMTHUMB;
				fi++;
				break;
			case _7Z_SPARC:
				filters[fi].id = LZMA_FILTER_SPARC;
				fi++;
				break;
			default:
				archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_MISC,
				    ""Unexpected codec ID: %lX"", zip->codec2);
				return (ARCHIVE_FAILED);
			}
		}

		if (zip->codec == _7Z_LZMA2)
			filters[fi].id = LZMA_FILTER_LZMA2;
		else
			filters[fi].id = LZMA_FILTER_LZMA1;
		filters[fi].options = NULL;
#if LZMA_VERSION < 50000030
		ff = &filters[fi];
#endif
		r = lzma_properties_decode(&filters[fi], NULL,
		    coder1->properties, (size_t)coder1->propertiesSize);
		if (r != LZMA_OK) {
			set_error(a, r);
			return (ARCHIVE_FAILED);
		}
		fi++;

		filters[fi].id = LZMA_VLI_UNKNOWN;
		filters[fi].options = NULL;
		r = lzma_raw_decoder(&(zip->lzstream), filters);
#if LZMA_VERSION < 50000030
		free(ff->options);
#endif
		if (r != LZMA_OK) {
			set_error(a, r);
			return (ARCHIVE_FAILED);
		}
		zip->lzstream_valid = 1;
		zip->lzstream.total_in = 0;
		zip->lzstream.total_out = 0;
		break;
	}
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""LZMA codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_BZ2:
#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
		if (zip->bzstream_valid) {
			BZ2_bzDecompressEnd(&(zip->bzstream));
			zip->bzstream_valid = 0;
		}
		r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 0);
		if (r == BZ_MEM_ERROR)
			r = BZ2_bzDecompressInit(&(zip->bzstream), 0, 1);
		if (r != BZ_OK) {
			int err = ARCHIVE_ERRNO_MISC;
			const char *detail = NULL;
			switch (r) {
			case BZ_PARAM_ERROR:
				detail = ""invalid setup parameter"";
				break;
			case BZ_MEM_ERROR:
				err = ENOMEM;
				detail = ""out of memory"";
				break;
			case BZ_CONFIG_ERROR:
				detail = ""mis-compiled library"";
				break;
			}
			archive_set_error(&a->archive, err,
			    ""Internal error initializing decompressor: %s"",
			    detail == NULL ? ""??"" : detail);
			zip->bzstream_valid = 0;
			return (ARCHIVE_FAILED);
		}
		zip->bzstream_valid = 1;
		zip->bzstream.total_in_lo32 = 0;
		zip->bzstream.total_in_hi32 = 0;
		zip->bzstream.total_out_lo32 = 0;
		zip->bzstream.total_out_hi32 = 0;
		break;
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""BZ2 codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_DEFLATE:
#ifdef HAVE_ZLIB_H
		if (zip->stream_valid)
			r = inflateReset(&(zip->stream));
		else
			r = inflateInit2(&(zip->stream),
			    -15 /* Don't check for zlib header */);
		if (r != Z_OK) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Couldn't initialize zlib stream."");
			return (ARCHIVE_FAILED);
		}
		zip->stream_valid = 1;
		zip->stream.total_in = 0;
		zip->stream.total_out = 0;
		break;
#else
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""DEFLATE codec is unsupported"");
		return (ARCHIVE_FAILED);
#endif
	case _7Z_PPMD:
	{
		unsigned order;
		uint32_t msize;

		if (zip->ppmd7_valid) {
			__archive_ppmd7_functions.Ppmd7_Free(
			    &zip->ppmd7_context, &g_szalloc);
			zip->ppmd7_valid = 0;
		}

		if (coder1->propertiesSize < 5) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Malformed PPMd parameter"");
			return (ARCHIVE_FAILED);
		}
		order = coder1->properties[0];
		msize = archive_le32dec(&(coder1->properties[1]));
		if (order < PPMD7_MIN_ORDER || order > PPMD7_MAX_ORDER ||
		    msize < PPMD7_MIN_MEM_SIZE || msize > PPMD7_MAX_MEM_SIZE) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Malformed PPMd parameter"");
			return (ARCHIVE_FAILED);
		}
		__archive_ppmd7_functions.Ppmd7_Construct(&zip->ppmd7_context);
		r = __archive_ppmd7_functions.Ppmd7_Alloc(
			&zip->ppmd7_context, msize, &g_szalloc);
		if (r == 0) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Coludn't allocate memory for PPMd"");
			return (ARCHIVE_FATAL);
		}
		__archive_ppmd7_functions.Ppmd7_Init(
			&zip->ppmd7_context, order);
		__archive_ppmd7_functions.Ppmd7z_RangeDec_CreateVTable(
			&zip->range_dec);
		zip->ppmd7_valid = 1;
		zip->ppmd7_stat = 0;
		zip->ppstream.overconsumed = 0;
		zip->ppstream.total_in = 0;
		zip->ppstream.total_out = 0;
		break;
	}
	case _7Z_X86:
	case _7Z_X86_BCJ2:
	case _7Z_POWERPC:
	case _7Z_IA64:
	case _7Z_ARM:
	case _7Z_ARMTHUMB:
	case _7Z_SPARC:
	case _7Z_DELTA:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unexpected codec ID: %lX"", zip->codec);
		return (ARCHIVE_FAILED);
	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Unknown codec ID: %lX"", zip->codec);
		return (ARCHIVE_FAILED);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_435.cpp,"[20, 0, 0, 0, 16, 0, 13, 2, 25, 2, 23, 0, 0, 0, 1, 467, 0, 0, 8, 8, 0, 0, 3, 52, 0, 0, 0, 0, 2, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 248, 1, 245, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 19, 0, 18, 16, 8, 0, 35, 0, 0, 82, 0, 78, 20, 0, 2, 2, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_435.cpp,284
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_668.cpp,1292,1319,1313,1361,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");","archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Unknown format `%s'"", val);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_436.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_436.cpp,"{
		archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Malformed device attribute"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_436.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_436.cpp,13
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_668.cpp,1292,1319,1322,1368,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Missing number"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_437.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_437.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_437.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_437.cpp,0
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_668.cpp,1292,1319,1322,1374,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_438.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_438.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_438.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_438.cpp,0
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_668.cpp,1292,1319,1322,1380,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Not enough arguments"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_439.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_439.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_439.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_439.cpp,0
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_338.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_668.cpp,1292,1319,1322,1386,,"archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""%s"", error);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_440.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_440.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_440.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_440.cpp,0
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_341.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_341.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_341.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_674.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_674.cpp,983,992,985,995,,"archive_string_sprintf(str, "" inode=%jd"", (intmax_t)me->ino);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_441.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_441.cpp,"(me->filetype) {
	case AE_IFLNK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=link"");
		if ((keys & F_SLINK) != 0) {
			archive_strcat(str, "" link="");
			mtree_quote(str, me->symlink.s);
		}
		break;
	case AE_IFSOCK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=socket"");
		break;
	case AE_IFCHR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=char"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFBLK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=block"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFDIR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=dir"");
		break;
	case AE_IFIFO:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=fifo"");
		break;
	case AE_IFREG:
	default:	/* Handle unknown file types as regular files. */
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=file"");
		if ((keys & F_SIZE) != 0)
			archive_string_sprintf(str, "" size=%jd"",
			    (intmax_t)me->size);
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_441.cpp,"[11, 0, 0, 0, 7, 0, 0, 0, 7, 1, 12, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 12, 0, 0, 13, 0, 29, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_441.cpp,73
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_mtree.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_341.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_341.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_341.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_674.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_674.cpp,983,992,985,997,,"archive_string_sprintf(str,
		    "" resdevice=native,%ju,%ju"",
		    (uintmax_t)me->devmajor,
		    (uintmax_t)me->devminor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_442.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_442.cpp,"(me->filetype) {
	case AE_IFLNK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=link"");
		if ((keys & F_SLINK) != 0) {
			archive_strcat(str, "" link="");
			mtree_quote(str, me->symlink.s);
		}
		break;
	case AE_IFSOCK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=socket"");
		break;
	case AE_IFCHR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=char"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFBLK:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=block"");
		if ((keys & F_DEV) != 0) {
			archive_string_sprintf(str,
			    "" device=native,%ju,%ju"",
			    (uintmax_t)me->rdevmajor,
			    (uintmax_t)me->rdevminor);
		}
		break;
	case AE_IFDIR:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=dir"");
		break;
	case AE_IFIFO:
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=fifo"");
		break;
	case AE_IFREG:
	default:	/* Handle unknown file types as regular files. */
		if ((keys & F_TYPE) != 0)
			archive_strcat(str, "" type=file"");
		if ((keys & F_SIZE) != 0)
			archive_string_sprintf(str, "" size=%jd"",
			    (intmax_t)me->size);
		break;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_442.cpp,"[11, 0, 0, 0, 7, 0, 0, 0, 7, 1, 12, 0, 0, 0, 0, 80, 0, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 11, 0, 0, 12, 0, 0, 13, 0, 29, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_442.cpp,73
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_342.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_679.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_679.cpp,376,399,442,434,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Archives > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_443.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_443.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate zip header data"");
		free(l);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_443.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_443.cpp,67
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_342.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_679.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_679.cpp,376,399,402,428,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Files > 4GB require Zip64 extensions"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_444.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_444.cpp,"(zip->opt_sconv == NULL && !zip->init_default_conversion) {
		zip->sconv_default =
		    archive_string_default_conversion_for_write(&(a->archive));
		zip->init_default_conversion = 1;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_444.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_444.cpp,27
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_342.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_681.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_681.cpp,663,803,678,815,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_445.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_445.cpp,"{
	case COMPRESSION_STORE:
		ret = __archive_write_output(a, buff, s);
		if (ret != ARCHIVE_OK) return (ret);
		zip->written_bytes += s;
		zip->remaining_data_bytes -= s;
		l->compressed_size += s;
		l->crc32 = crc32(l->crc32, buff, (unsigned)s);
		return (s);
#if HAVE_ZLIB_H
	case COMPRESSION_DEFLATE:
		zip->stream.next_in = (unsigned char*)(uintptr_t)buff;
		zip->stream.avail_in = (uInt)s;
		do {
			ret = deflate(&zip->stream, Z_NO_FLUSH);
			if (ret == Z_STREAM_ERROR)
				return (ARCHIVE_FATAL);
			if (zip->stream.avail_out == 0) {
				ret = __archive_write_output(a, zip->buf,
					zip->len_buf);
				if (ret != ARCHIVE_OK)
					return (ret);
				l->compressed_size += zip->len_buf;
				zip->written_bytes += zip->len_buf;
				zip->stream.next_out = zip->buf;
				zip->stream.avail_out = (uInt)zip->len_buf;
			}
		} while (zip->stream.avail_in != 0);
		zip->remaining_data_bytes -= s;
		/* If we have it, use zlib's fast crc32() */
		l->crc32 = crc32(l->crc32, buff, (uInt)s);
		return (s);
#endif

	default:
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Invalid ZIP compression type"");
		return ARCHIVE_FATAL;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_445.cpp,"[5, 0, 0, 1, 0, 0, 6, 0, 2, 1, 6, 0, 0, 0, 0, 125, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 0, 0, 6, 0, 0, 16, 0, 17, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_445.cpp,47
64713ae3ffddf6fbbfa7ea762c3d756cb245a066,"libarchive 3.1.2-218-g00f4bd83 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2-218-g00f4bd83 &&
r=00f4bd83 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_write_set_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_342.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_342.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_681.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_681.cpp,663,803,730,897,,"archive_set_error(&a->archive, ENOMEM,
				""Can't allocate zip data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_446.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_446.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_446.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_446.cpp,0
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_343.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_682.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_682.cpp,254,255,255,256,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_447.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_447.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_447.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_447.cpp,37
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_343.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_683.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_683.cpp,968,970,970,972,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_448.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_448.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_448.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_448.cpp,2
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_343.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_343.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_683.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_683.cpp,968,970,977,979,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_449.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_449.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_449.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_449.cpp,9
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_344.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_684.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_684.cpp,434,435,438,440,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_450.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_450.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_450.cpp,3
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_344.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_684.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_684.cpp,434,435,444,446,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_451.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_451.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_451.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_451.cpp,9
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_344.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_344.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_684.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_684.cpp,434,435,450,452,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_452.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_452.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_452.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_452.cpp,15
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_345.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_687.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_687.cpp,449,450,451,452,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_453.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_453.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_453.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_453.cpp,430
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_345.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_688.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_688.cpp,465,466,466,467,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_454.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_454.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_454.cpp,445
8018fcca6e055a0f12a17fc8324128080a9ec568,Merge branch 'master' into revise-compiler-id-policies,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_345.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_345.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_688.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_688.cpp,465,466,471,473,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_455.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_455.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_455.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_455.cpp,450
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_346.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_689.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_689.cpp,254,255,255,256,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->HasConfig?this->Config.c_str():""noconfig"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_456.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_456.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_456.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_456.cpp,37
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_346.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_690.cpp,968,970,970,972,"fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());","fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_457.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_457.cpp,"{
  fprintf(stderr, ""target [%s] links to:\n"", this->Target->GetName());
  for(std::vector<LinkEntry>::const_iterator lei =
        this->FinalLinkEntries.begin();
      lei != this->FinalLinkEntries.end(); ++lei)
    {
    if(lei->Target)
      {
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }
    else
      {
      fprintf(stderr, ""  item [%s]\n"", lei->Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_457.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 40, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 1, 1, 0, 10, 0, 0, 4, 0, 12, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_457.cpp,2
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_346.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_346.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_690.cpp,968,970,977,979,"fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());","fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_458.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_458.cpp,"{
      fprintf(stderr, ""  target [%s]\n"", lei->Target->GetName());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_458.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_458.cpp,9
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_691.cpp,434,434,438,439,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_459.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_459.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_459.cpp,3
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_691.cpp,434,434,444,445,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_460.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_460.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_460.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_460.cpp,9
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_347.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_691.cpp,434,434,450,451,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_461.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_461.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_461.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_461.cpp,15
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_348.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_694.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_694.cpp,449,450,451,452,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_462.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_462.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_462.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 10, 593, 0, 0, 26, 40, 0, 0, 40, 83, 0, 0, 0, 0, 13, 0, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 1, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 122, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_462.cpp,430
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_348.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_695.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_695.cpp,465,466,466,467,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_463.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_463.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_463.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_463.cpp,445
6e466c6f2ee5160202aaa76a9d643d34bd7d908a,Merge branch 'master' into CONFIG-LOCATION-CMP0026,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_348.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_348.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_695.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_695.cpp,465,466,471,473,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_464.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_464.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_464.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_464.cpp,450
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_355.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_355.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_355.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_704.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_704.cpp,254,254,255,255,"fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");","fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName().c_str(),
            this->Config?this->Config:""noconfig"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_465.cpp,"{
    fprintf(stderr,
            ""---------------------------------------""
            ""---------------------------------------\n"");
    fprintf(stderr, ""Link dependency analysis for target %s, config %s\n"",
            this->Target->GetName(), this->Config?this->Config:""noconfig"");
    this->DisplayConstraintGraph();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_465.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_465.cpp,37
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_705.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_705.cpp,434,434,438,439,"fprintf(stderr, ""The %s target dependency graph is:\n"", name);","fprintf(stderr, ""The %s target dependency graph is:\n"", name.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_466.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_466.cpp,"{
  fprintf(stderr, ""The %s target dependency graph is:\n"", name);
  int n = static_cast<int>(graph.size());
  for(int depender_index = 0; depender_index < n; ++depender_index)
    {
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_466.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 63, 0, 0, 5, 7, 0, 0, 9, 7, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 1, 37, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 3, 1, 1, 0, 12, 0, 0, 4, 0, 16, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_466.cpp,3
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_705.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_705.cpp,434,434,444,445,"fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());","fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName().c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_467.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_467.cpp,"{
    EdgeList const& nl = graph[depender_index];
    cmTarget const* depender = this->Targets[depender_index];
    fprintf(stderr, ""target %d is [%s]\n"",
            depender_index, depender->GetName());
    for(EdgeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_467.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 47, 0, 0, 4, 5, 0, 0, 6, 4, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 1, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 3, 0, 2, 1, 1, 0, 7, 0, 0, 2, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_467.cpp,9
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_356.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_705.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_705.cpp,434,434,450,451,"fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName().c_str(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_468.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_468.cpp,"{
      int dependee_index = *ni;
      cmTarget const* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_468.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 18, 0, 0, 2, 2, 0, 0, 2, 3, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_468.cpp,15
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_357.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_706.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_706.cpp,450,450,452,452,"fprintf(fout, ""add_executable(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_469.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_469.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      std::string lang = gg->GetLanguageFromExtension(ext.c_str());
      if(!lang.empty())
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = cmsys::SystemTools::Fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""add_definitions( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURES to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURES first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if (const char *cxxDef
              = this->Makefile->GetDefinition(""CMAKE_CXX_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_TARGET="";
      flag += cxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *cDef
                = this->Makefile->GetDefinition(""CMAKE_C_COMPILER_TARGET""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_TARGET="";
      flag += cDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcxxDef = this->Makefile->GetDefinition(
                                  ""CMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcxxDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *tcDef = this->Makefile->GetDefinition(
                                    ""CMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN""))
      {
      std::string flag=""-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN="";
      flag += tcDef;
      cmakeFlags.push_back(flag);
      }
    if (const char *rootDef
              = this->Makefile->GetDefinition(""CMAKE_SYSROOT""))
      {
      std::string flag=""-DCMAKE_SYSROOT="";
      flag += rootDef;
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""add_executable(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_469.cpp,"[21, 0, 6, 0, 0, 0, 3, 0, 0, 0, 30, 0, 0, 0, 9, 598, 0, 0, 27, 40, 0, 0, 40, 83, 0, 0, 0, 0, 12, 0, 116, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 233, 1, 257, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 2, 0, 28, 22, 3, 0, 123, 0, 0, 62, 2, 127, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_469.cpp,431
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_357.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_707.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_707.cpp,466,466,467,467,"fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);","fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",
              targetName.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_470.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_470.cpp,"{
      fprintf(fout,
              ""target_link_libraries(%s ${LINK_LIBRARIES})\n"",targetName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_470.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_470.cpp,446
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_357.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_357.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_707.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_707.cpp,466,466,472,473,"fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());","fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName.c_str(),
              libsToLink.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_471.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_471.cpp,"{
      fprintf(fout, ""target_link_libraries(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_471.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_471.cpp,451
fabf1fbabb4fc67844d5b2210e70a9829a59ff23,stringapi: Use strings in target name,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_358.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_358.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_358.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_708.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_708.cpp,572,572,575,575,"sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);","sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName().c_str(), count);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_472.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(this->Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);
  std::string comment = this->ConstructComment(origCommand, ""<hack>"");

  // Add the rule with the given dependencies and commands.
  const char* no_main_dependency = 0;
  if(cmSourceFile* outsf =
     this->Makefile->AddCustomCommandToOutput(
       output, depends, no_main_dependency,
       origCommand.GetCommandLines(), comment.c_str(),
       origCommand.GetWorkingDirectory()))
    {
    target.AddSourceFile(outsf);
    }

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_472.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 63, 0, 0, 3, 4, 0, 0, 4, 4, 0, 0, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 15, 0, 0, 5, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_472.cpp,9
f668112039798f5ebc955e127f9c3e4e7cdb5cc4,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_362.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_362.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_362.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_714.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_714.cpp,2222,2242,2224,2244,"sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);","_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_473.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_473.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt""); break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)""); break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero""); break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)""); break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation""); break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow""); break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed""); break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow""); break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)""); break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)""); break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero""); break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow""); break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment""); break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation""); break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error""); break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde""); break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception""); break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition""); break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded""); break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow""); break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction""); break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction""); break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_473.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 47, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_473.cpp,59
704ab3d24827cfe5754a00028086f21503c2e08b,"KWSys 2013-11-21 (1010d0e3)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 1010d0e3 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 6eab64c3..1010d0e3
Brad King (2):
      ace1364c Encoding: Remove unused include
      1010d0e3 SystemTools: Avoid unused function warnings

Clinton Stimpson (4):
      0c2ff1f7 Encoding: Add Encoding module.
      8abbad82 FStream: Add FStream module.
      0a98de97 KWSys: Port to use wide character Windows APIs throughout.
      2b0c683d Encoding: Default to ANSI code page on Windows

David Cole (1):
      f67bb2ba SystemTools: Move typedef mode_t inside the SystemTools class

Sean McBride (1):
      a40b9263 SystemInformation: Work around gcc -Wliteral-suffix warning

Change-Id: Ie52df972331cc7377c236d410ead86024e9d15ab",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_364.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_364.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_364.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_717.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_717.cpp,2222,2242,2224,2244,"sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);","_snprintf(cp->ExitExceptionString, KWSYSPE_PIPE_BUFFER_SIZE, ""Exit code 0x%x\n"", code);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_474.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_474.cpp,"{
    case STATUS_CONTROL_C_EXIT:
      KWSYSPE_CASE(Interrupt, ""User interrupt""); break;

    case STATUS_FLOAT_DENORMAL_OPERAND:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (denormal operand)""); break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Divide-by-zero""); break;
    case STATUS_FLOAT_INEXACT_RESULT:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (inexact result)""); break;
    case STATUS_FLOAT_INVALID_OPERATION:
      KWSYSPE_CASE(Numerical, ""Invalid floating-point operation""); break;
    case STATUS_FLOAT_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point overflow""); break;
    case STATUS_FLOAT_STACK_CHECK:
      KWSYSPE_CASE(Numerical, ""Floating-point stack check failed""); break;
    case STATUS_FLOAT_UNDERFLOW:
      KWSYSPE_CASE(Numerical, ""Floating-point underflow""); break;
#ifdef STATUS_FLOAT_MULTIPLE_FAULTS
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple faults)""); break;
#endif
#ifdef STATUS_FLOAT_MULTIPLE_TRAPS
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      KWSYSPE_CASE(Numerical, ""Floating-point exception (multiple traps)""); break;
#endif
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      KWSYSPE_CASE(Numerical, ""Integer divide-by-zero""); break;
    case STATUS_INTEGER_OVERFLOW:
      KWSYSPE_CASE(Numerical, ""Integer overflow""); break;

    case STATUS_DATATYPE_MISALIGNMENT:
      KWSYSPE_CASE(Fault, ""Datatype misalignment""); break;
    case STATUS_ACCESS_VIOLATION:
      KWSYSPE_CASE(Fault, ""Access violation""); break;
    case STATUS_IN_PAGE_ERROR:
      KWSYSPE_CASE(Fault, ""In-page error""); break;
    case STATUS_INVALID_HANDLE:
      KWSYSPE_CASE(Fault, ""Invalid hanlde""); break;
    case STATUS_NONCONTINUABLE_EXCEPTION:
      KWSYSPE_CASE(Fault, ""Noncontinuable exception""); break;
    case STATUS_INVALID_DISPOSITION:
      KWSYSPE_CASE(Fault, ""Invalid disposition""); break;
    case STATUS_ARRAY_BOUNDS_EXCEEDED:
      KWSYSPE_CASE(Fault, ""Array bounds exceeded""); break;
    case STATUS_STACK_OVERFLOW:
      KWSYSPE_CASE(Fault, ""Stack overflow""); break;

    case STATUS_ILLEGAL_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Illegal instruction""); break;
    case STATUS_PRIVILEGED_INSTRUCTION:
      KWSYSPE_CASE(Illegal, ""Privileged instruction""); break;

    case STATUS_NO_MEMORY:
    default:
      cp->ExitException = kwsysProcess_Exception_Other;
      sprintf(cp->ExitExceptionString, ""Exit code 0x%x\n"", code);
      break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_474.cpp,"[0, 0, 0, 0, 23, 0, 0, 0, 23, 1, 1, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 0, 24, 0, 47, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_474.cpp,59
c04995b46eb93d39f97ee12ab63a5479c0b79b41,"cmake: Split -E command implementation into separate source file

Move the cmake::ExecuteCMakeCommand static method and all the static
methods it calls out of the 'cmake' class to a separate 'cmcmd' class.
Build the latter as part of the main cmake executable with cmakemain.cxx
and not in CMakeLib.  Drop unused header includes from ""cmake.cxx"".

By moving this implementation out of cmake.cxx we avoid carrying it
around in all the executables that use class 'cmake'.  It is needed only
for the main ""cmake -E"" functionality.",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_718.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_718.cpp,1128,1112,1503,-1,"fprintf(progFile,""%i\n"",count);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_475.cpp,"{
          fprintf(progFile,""%i\n"",count);
          fclose(progFile);
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_475.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_475.cpp,309
c04995b46eb93d39f97ee12ab63a5479c0b79b41,"cmake: Split -E command implementation into separate source file

Move the cmake::ExecuteCMakeCommand static method and all the static
methods it calls out of the 'cmake' class to a separate 'cmcmd' class.
Build the latter as part of the main cmake executable with cmakemain.cxx
and not in CMakeLib.  Drop unused header includes from ""cmake.cxx"".

By moving this implementation out of cmake.cxx we avoid carrying it
around in all the executables that use class 'cmake'.  It is needed only
for the main ""cmake -E"" functionality.",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_718.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_718.cpp,1128,1112,1544,-1,"fprintf(progFile,""empty"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_476.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_476.cpp,"{
          fprintf(progFile,""empty"");
          fclose(progFile);
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_476.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_476.cpp,350
c04995b46eb93d39f97ee12ab63a5479c0b79b41,"cmake: Split -E command implementation into separate source file

Move the cmake::ExecuteCMakeCommand static method and all the static
methods it calls out of the 'cmake' class to a separate 'cmcmd' class.
Build the latter as part of the main cmake executable with cmakemain.cxx
and not in CMakeLib.  Drop unused header includes from ""cmake.cxx"".

By moving this implementation out of cmake.cxx we avoid carrying it
around in all the executables that use class 'cmake'.  It is needed only
for the main ""cmake -E"" functionality.",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_365.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_365.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_718.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_718.cpp,1128,1112,1553,-1,"fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_477.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_477.cpp,"{
        // print the progress
        fprintf(stdout,""[%3i%%] "",((fileNum-3)*100)/count);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_477.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_477.cpp,359
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_719.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_719.cpp,294,294,296,296,"fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);","fprintf(fout, ""set(CMAKE_MODULE_PATH %s)\n"", def);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_478.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_478.cpp,"{
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_478.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_478.cpp,275
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,309,309,"fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);","fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_479.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_479.cpp,"{
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_479.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_479.cpp,288
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,315,315,"fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);","fprintf(fout, ""set(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_480.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_480.cpp,"{
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_480.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_480.cpp,294
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,319,319,"f(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());","f(fout, ""project(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_481.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_481.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_481.cpp,298
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,320,320,"fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");","fprintf(fout, ""set(CMAKE_VERBOSE_MAKEFILE 1)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_482.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_482.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_482.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_482.cpp,299
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,326,326,"fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_483.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_483.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_483.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 33, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 9, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_483.cpp,305
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,328,328,"fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());","fprintf(fout, ""set(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_484.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_484.cpp,"{
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_484.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 33, 0, 0, 2, 2, 0, 0, 2, 6, 0, 0, 0, 0, 1, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 1, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 9, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_484.cpp,307
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,331,331,"fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");","fprintf(fout, ""include_directories(${INCLUDE_DIRECTORIES})\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_485.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_485.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_485.cpp,310
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,332,332,"fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");","fprintf(fout, ""set(CMAKE_SUPPRESS_REGENERATION 1)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_486.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_486.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_486.cpp,311
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,333,333,"fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");","fprintf(fout, ""link_directories(${LINK_DIRECTORIES})\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_487.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_487.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_487.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_487.cpp,312
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_720.cpp,307,307,337,337,"fprintf(fout, ""ADD_DEFINITIONS( "");","fprintf(fout, ""add_definitions( "");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_488.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_488.cpp,"{
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_488.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 0, 1, 0, 0, 2, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 5, 0, 0, 3, 0, 7, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_488.cpp,316
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_721.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_721.cpp,406,406,408,408,"fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");","fprintf(fout, ""set(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_489.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_489.cpp,"{
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_489.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_489.cpp,387
33055c405ed3b0e1df52c186f0d8a3e878aa88a8,"Generate modern-style cmake code.

The commits 9db31162 (Remove CMake-language block-end command
arguments, 2012-08-13) and 77543bde (Convert CMake-language
commands to lower case, 2012-08-13) changed most cmake code
to use lowercase commands and no parameters in termination
commands. However, those changes excluded cmake code generated
in c++ by cmake.

Make a similar style change to code generated by cmake.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_366.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_721.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_721.cpp,406,406,415,415,"fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);","fprintf(fout, ""add_executable(%s"", targetName);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_490.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_490.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // Choose sources.
    if(!useSources)
      {
      sources.push_back(argv[2]);
      }

    // Detect languages to enable.
    cmLocalGenerator* lg = this->Makefile->GetLocalGenerator();
    cmGlobalGenerator* gg = lg->GetGlobalGenerator();
    std::set<std::string> testLangs;
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      std::string ext = cmSystemTools::GetFilenameLastExtension(*si);
      if(const char* lang = gg->GetLanguageFromExtension(ext.c_str()))
        {
        testLangs.insert(lang);
        }
      else
        {
        cmOStringStream err;
        err << ""Unknown extension \"""" << ext << ""\"" for file\n""
            << ""  "" << *si << ""\n""
            << ""try_compile() works only for enabled languages.  ""
            << ""Currently these are:\n "";
        std::vector<std::string> langs;
        gg->GetEnabledLanguages(langs);
        for(std::vector<std::string>::iterator l = langs.begin();
            l != langs.end(); ++l)
          {
          err << "" "" << *l;
          }
        err << ""\nSee project() command to enable other languages."";
        this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
        return -1;
        }
      }

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    std::string projectLangs;
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      projectLangs += "" "" + *li;
      std::string rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
      std::string rulesOverrideLang = rulesOverrideBase + ""_"" + *li;
      if(const char* rulesOverridePath =
         this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideLang.c_str(), rulesOverridePath);
        }
      else if(const char* rulesOverridePath2 =
              this->Makefile->GetDefinition(rulesOverrideBase.c_str()))
        {
        fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);
        }
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    for(std::set<std::string>::iterator li = testLangs.begin();
        li != testLangs.end(); ++li)
      {
      std::string langFlags = ""CMAKE_"" + *li + ""_FLAGS"";
      const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS %s)\n"", li->c_str(),
              lg->EscapeForCMake(flags?flags:"""").c_str());
      fprintf(fout, ""SET(CMAKE_%s_FLAGS \""${CMAKE_%s_FLAGS}""
              "" ${COMPILE_DEFINITIONS}\"")\n"", li->c_str(), li->c_str());
      }
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);
    for(std::vector<std::string>::iterator si = sources.begin();
        si != sources.end(); ++si)
      {
      fprintf(fout, "" \""%s\"""", si->c_str());

      // Add dependencies on any non-temporary sources.
      if(si->find(""CMakeTmp"") == si->npos)
        {
        this->Makefile->AddCMakeDependFile(*si);
        }
      }
    fprintf(fout, "")\n"");
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_490.cpp,"[16, 0, 6, 0, 0, 0, 3, 0, 0, 0, 25, 0, 0, 0, 5, 510, 0, 0, 21, 30, 0, 0, 30, 73, 0, 0, 0, 0, 8, 0, 105, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 203, 1, 226, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 2, 0, 23, 17, 3, 0, 112, 0, 0, 52, 2, 117, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_490.cpp,394
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_369.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_369.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_369.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_724.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_724.cpp,1130,1326,1131,1327,"archive_set_error(
							&filter->archive->archive,
							ENOMEM,
						    ""Unable to allocate copy buffer"");","archive_set_error(
						    &filter->archive->archive,
						    ENOMEM,
						    ""Unable to allocate copy""
						    "" buffer"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_491.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_491.cpp,"{ /* Integer overflow! */
						archive_set_error(
							&filter->archive->archive,
							ENOMEM,
						    ""Unable to allocate copy buffer"");
						filter->fatal = 1;
						if (avail != NULL)
							*avail = ARCHIVE_FATAL;
						return (NULL);
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_491.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_491.cpp,107
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_370.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_725.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_725.cpp,213,223,215,231,,"archive_set_error(&a->archive, errno,
				    ""Couldn't read link data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_492.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_492.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_492.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_492.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_370.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_729.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_729.cpp,856,1070,866,-1,"archive_set_error(&a->archive, errno,
				    ""FIEMAP failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_493.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_493.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""FIEMAP failed"");
				exit_sts = ARCHIVE_FAILED;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_493.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_493.cpp,50
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_370.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_370.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_730.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_730.cpp,926,1130,943,1164,,"archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_494.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_494.cpp,"(fd < 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_494.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_494.cpp,31
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_371.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_371.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_371.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_731.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_731.cpp,1028,1241,1034,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_495.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_495.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_495.cpp,10
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_371.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_371.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_371.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_732.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_732.cpp,1079,1290,1080,1293,,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_496.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_496.cpp,"(archive_string_append_from_wcs(&path, pathname,
	    wcslen(pathname)) != 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't convert a path to a char string"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		ret = ARCHIVE_FATAL;
	} else
		ret = _archive_read_disk_open(_a, path.s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_496.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 9, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_496.cpp,15
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_737.cpp,557,549,608,591,"archive_set_error(&a->archive, errno, ""Seek error"");","archive_set_error(&a->archive, errno,
			    ""CreateEvent failed"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_497.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_497.cpp,"{
			DWORD lasterr;

			lasterr = GetLastError();
			if (lasterr == ERROR_ACCESS_DENIED)
				errno = EBADF;
			else
				la_dosmaperr(lasterr);
			archive_set_error(&a->archive, errno, ""Seek error"");
			r = ARCHIVE_FATAL;
			a->archive.state = ARCHIVE_STATE_FATAL;
			goto abort_read_data;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_497.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 23, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 6, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_497.cpp,49
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_737.cpp,557,549,559,632,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Reading file truncated"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_498.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_498.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_498.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_498.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_737.cpp,557,549,559,704,,"archive_set_error(&a->archive, errno,
		    ""GetOverlappedResult failed"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_499.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_499.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_499.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_499.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_737.cpp,557,549,559,714,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Reading file truncated"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_500.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_500.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_500.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_500.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_738.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_738.cpp,701,768,703,770,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));","archive_set_error(&a->archive, t->tree_errno,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_501.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_501.cpp,"{
		case TREE_ERROR_FATAL:
			archive_set_error(&a->archive, t->tree_errno,
			    ""%ls: Unable to continue traversing directory tree"",
			    tree_current_path(t));
			a->archive.state = ARCHIVE_STATE_FATAL;
			return (ARCHIVE_FATAL);
		case TREE_ERROR_DIR:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));
			return (ARCHIVE_FAILED);
		case 0:
			return (ARCHIVE_EOF);
		case TREE_POSTDESCENT:
		case TREE_POSTASCENT:
			break;
		case TREE_REGULAR:
			lst = tree_current_lstat(t);
			if (lst == NULL) {
				archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));
				return (ARCHIVE_FAILED);
			}
			break;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_501.cpp,"[1, 0, 0, 0, 2, 0, 4, 0, 6, 0, 2, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 5, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_501.cpp,30
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_739.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_739.cpp,713,780,715,782,"archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));","archive_set_error(&a->archive, t->tree_errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_502.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_502.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_502.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_502.cpp,42
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_740.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_740.cpp,759,846,774,871,,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_503.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_503.cpp,"(name != NULL)
		archive_entry_copy_uname(entry, name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_503.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_503.cpp,101
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_740.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_740.cpp,759,846,781,897,,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_504.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_504.cpp,"(archive_entry_filetype(entry) == AE_IFREG &&
	    archive_entry_size(entry) > 0) {
		t->entry_fh = CreateFileW(tree_current_access_path(t),
		    GENERIC_READ, 0, NULL, OPEN_EXISTING,
		    FILE_FLAG_SEQUENTIAL_SCAN, NULL);
		if (t->entry_fh == INVALID_HANDLE_VALUE) {
			archive_set_error(&a->archive, errno,
			    ""Couldn't open %ls"", tree_current_path(a->tree));
			return (ARCHIVE_FAILED);
		}

		/* Find sparse data from the disk. */
		if (archive_entry_hardlink(entry) == NULL &&
		    (st->dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0)
			r = setup_sparse_from_disk(a, entry, t->entry_fh);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_504.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 8, 0, 0, 4, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_504.cpp,108
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_741.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_741.cpp,878,1129,884,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_505.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_505.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_505.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_505.cpp,10
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_742.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_742.cpp,920,1169,921,1172,,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_506.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_506.cpp,"(archive_wstring_append_from_mbs(&wpath, pathname,
	    strlen(pathname)) != 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't convert a path to a wchar_t string"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		ret = ARCHIVE_FATAL;
	} else
		ret = _archive_read_disk_open_w(_a, wpath.s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_506.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 9, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_506.cpp,15
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_746.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_746.cpp,1775,2084,1777,2087,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
				    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_507.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_507.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't GetFileInformationByHandle"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_507.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_507.cpp,32
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_747.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_747.cpp,1785,2095,1788,2099,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't FindFirstFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't FindFirstFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_508.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_508.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't FindFirstFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_508.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_508.cpp,43
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_748.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_748.cpp,1807,2118,1809,2121,"archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't CreateFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't CreateFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_509.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_509.cpp,"{
				archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't CreateFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_509.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_509.cpp,64
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_748.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_748.cpp,1807,2118,1816,2128,"archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
				    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_510.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_510.cpp,"{
				archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't GetFileInformationByHandle"");
				CloseHandle(h);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_510.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_510.cpp,71
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_749.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_749.cpp,1854,2165,1856,2168,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't CreateFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't CreateFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_511.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_511.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't CreateFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_511.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_511.cpp,111
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_749.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_749.cpp,1854,2165,1863,2176,"archive_set_error(&a->archive, GetLastError(),
			    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
			    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_512.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_512.cpp,"{
			archive_set_error(&a->archive, GetLastError(),
			    ""Can't GetFileInformationByHandle"");
			if (h != INVALID_HANDLE_VALUE && fd < 0)
				CloseHandle(h);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_512.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_512.cpp,118
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_750.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_750.cpp,1909,2222,1911,2224,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			""Couldn't allocate memory"");","archive_set_error(&a->archive, ENOMEM,
			""Couldn't allocate memory"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_513.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			""Couldn't allocate memory"");
		exit_sts = ARCHIVE_FATAL;
		goto exit_setup_sparse;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_513.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_513.cpp,14
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_372.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_372.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_751.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_751.cpp,1923,2236,1932,2245,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Couldn't allocate memory"");","archive_set_error(&a->archive, ENOMEM,
					    ""Couldn't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_514.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_514.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Couldn't allocate memory"");
					exit_sts = ARCHIVE_FATAL;
					goto exit_setup_sparse;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_514.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_514.cpp,35
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_753.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_753.cpp,98,103,132,190,"archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");","archive_set_error(a, EINVAL,
				    ""Failed to convert a wide-character""
				    "" filename to a multi-byte filename"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_515.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_515.cpp,"{
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_515.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_515.cpp,23
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_753.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_753.cpp,98,103,108,151,,"archive_set_error(a, ENOMEM, ""No memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_516.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_516.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_516.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_753.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_753.cpp,98,103,115,163,,"archive_set_error(a, ENOMEM, ""No memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_517.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_517.cpp,"(wfilename == NULL || wfilename[0] == L'\0') {
		filename_type = FNT_STDIN;
	} else {
#if defined(_WIN32) && !defined(__CYGWIN__)
		filename_type = FNT_WCS;
#else
		/*
		 * POSIX system does not support a wchar_t interface for
		 * open() system call, so we have to translate a whcar_t
		 * filename to multi-byte one and use it.
		 */
		struct archive_string fn;
		int r;

		archive_string_init(&fn);
		if (archive_string_append_from_wcs(&fn, wfilename,
		    wcslen(wfilename)) != 0) {
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}
		r = file_open_filename(a, FNT_MBS, fn.s, block_size);
		archive_string_free(&fn);
		return (r);
#endif
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_517.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 42, 0, 0, 2, 2, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 2, 0, 9, 0, 0, 7, 0, 16, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_517.cpp,6
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_374.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_753.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_753.cpp,98,103,131,187,,"archive_set_error(a, errno,
				    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_518.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_518.cpp,"(archive_string_append_from_wcs(&fn, wfilename,
		    wcslen(wfilename)) != 0) {
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_518.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_518.cpp,22
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_bzip2.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_375.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_375.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_375.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_757.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_757.cpp,102,103,103,104,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bunzip2 program"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bzip2 program"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_519.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_519.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *reader;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_bzip2"");

	if (__archive_read_get_bidder(a, &reader) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	reader->data = NULL;
	reader->bid = bzip2_reader_bid;
	reader->init = bzip2_reader_init;
	reader->options = NULL;
	reader->free = bzip2_reader_free;
#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bunzip2 program"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_519.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 5, 0, 0, 7, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_519.cpp,20
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_gzip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_376.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_376.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_376.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_758.cpp,109,110,110,111,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gunzip program"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gzip program"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_520.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_520.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_gzip"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = gzip_bidder_bid;
	bidder->init = gzip_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL; /* No data, so no cleanup necessary. */
	/* Signal the extent of gzip support with the return value here. */
#if HAVE_ZLIB_H
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gunzip program"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_520.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 45, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_520.cpp,21
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_377.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_759.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_759.cpp,79,82,99,-1,"archive_set_error(_a, -1,
	    ""External compression programs not supported on this platform"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_521.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_521.cpp,"{
	(void)_a; /* UNUSED */
	(void)cmd; /* UNUSED */
	(void)signature; /* UNUSED */
	(void)signature_len; /* UNUSED */

	archive_set_error(_a, -1,
	    ""External compression programs not supported on this platform"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_521.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 5, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_521.cpp,9
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_377.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_759.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_759.cpp,79,82,110,-1,"archive_set_error(&self->archive->archive, -1,
	    ""External compression programs not supported on this platform"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_522.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_522.cpp,"{
	(void)self; /* UNUSED */
	(void)cmd; /* UNUSED */

	archive_set_error(&self->archive->archive, -1,
	    ""External compression programs not supported on this platform"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_522.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_522.cpp,6
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_377.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_377.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_760.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_760.cpp,376,399,412,444,,"archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
		    cmd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_523.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_523.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_523.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_523.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_uu.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_378.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_378.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_378.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_761.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_761.cpp,485,491,493,501,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",uudecode->state = ST_IGNORE;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_524.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_524.cpp,"{
			/* Non-ascii character is found. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_524.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_524.cpp,46
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_379.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_379.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_379.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_763.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_763.cpp,144,145,145,146,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unxz program for xz decompression"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external xz program for xz decompression"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_525.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_525.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_xz"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = xz_bidder_bid;
	bidder->init = xz_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unxz program for xz decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_525.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 46, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_525.cpp,20
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_379.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_379.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_379.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_764.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_764.cpp,180,182,181,183,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unlzma program for lzma decompression"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_526.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_526.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unlzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_526.cpp,"[2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 49, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_526.cpp,22
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_cab.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_381.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_381.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_381.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_773.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_773.cpp,478,481,481,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cab: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_527.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_527.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cab: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_527.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_527.cpp,21
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_382.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_382.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_382.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_776.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_776.cpp,339,340,342,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cpio: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_528.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_528.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cpio: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_528.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_528.cpp,26
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_383.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_383.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_383.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_782.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_782.cpp,1286,1310,1309,1329,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
		    (intmax_t)file->number,
		    iso9660->pathname.s,
		    (intmax_t)file->offset,
		    (intmax_t)iso9660->current_position);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
			    (intmax_t)file->number,
			    iso9660->pathname.s,
			    (intmax_t)file->offset,
			    (intmax_t)iso9660->current_position);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_529.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
		    (intmax_t)file->number,
		    iso9660->pathname.s,
		    (intmax_t)file->offset,
		    (intmax_t)iso9660->current_position);
		iso9660->entry_bytes_remaining = 0;
		iso9660->entry_sparse_offset = 0;
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_529.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_529.cpp,248
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_383.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_383.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_383.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_786.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_786.cpp,2882,2888,2883,2889,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of""
	    ""Rockridge extensions"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of ""
	    ""Rockridge extensions: current position = %jd, CL offset = %jd"",
	    (intmax_t)iso9660->current_position, (intmax_t)file->cl_offset);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_530.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_530.cpp,"{
	struct file_info *file;
	struct {
		struct file_info	*first;
		struct file_info	**last;
	}	empty_files;
	int64_t number;
	int count;

	file = cache_get_entry(iso9660);
	if (file != NULL) {
		*pfile = file;
		return (ARCHIVE_OK);
	}

	for (;;) {
		struct file_info *re, *d;

		*pfile = file = next_entry(iso9660);
		if (file == NULL) {
			/*
			 * If directory entries all which are descendant of
			 * rr_moved are stil remaning, expose their. 
			 */
			if (iso9660->re_files.first != NULL && 
			    iso9660->rr_moved != NULL &&
			    iso9660->rr_moved->rr_moved_has_re_only)
				/* Expose ""rr_moved"" entry. */
				cache_add_entry(iso9660, iso9660->rr_moved);
			while ((re = re_get_entry(iso9660)) != NULL) {
				/* Expose its descendant dirs. */
				while ((d = rede_get_entry(re)) != NULL)
					cache_add_entry(iso9660, d);
			}
			if (iso9660->cache_files.first != NULL)
				return (next_cache_entry(a, iso9660, pfile));
			return (ARCHIVE_EOF);
		}

		if (file->cl_offset) {
			struct file_info *first_re = NULL;
			int nexted_re = 0;

			/*
			 * Find ""RE"" dir for the current file, which
			 * has ""CL"" flag.
			 */
			while ((re = re_get_entry(iso9660))
			    != first_re) {
				if (first_re == NULL)
					first_re = re;
				if (re->offset == file->cl_offset) {
					re->parent->subdirs--;
					re->parent = file->parent;
					re->re = 0;
					if (re->parent->re_descendant) {
						nexted_re = 1;
						re->re_descendant = 1;
						if (rede_add_entry(re) < 0)
							goto fatal_rr;
						/* Move a list of descendants
						 * to a new ancestor. */
						while ((d = rede_get_entry(
						    re)) != NULL)
							if (rede_add_entry(d)
							    < 0)
								goto fatal_rr;
						break;
					}
					/* Replace the current file
					 * with ""RE"" dir */
					*pfile = file = re;
					/* Expose its descendant */
					while ((d = rede_get_entry(
					    file)) != NULL)
						cache_add_entry(
						    iso9660, d);
					break;
				} else
					re_add_entry(iso9660, re);
			}
			if (nexted_re) {
				/*
				 * Do not expose this at this time
				 * because we have not gotten its full-path
				 * name yet.
				 */
				continue;
			}
		} else if ((file->mode & AE_IFMT) == AE_IFDIR) {
			int r;

			/* Read file entries in this dir. */
			r = read_children(a, file);
			if (r != ARCHIVE_OK)
				return (r);

			/*
			 * Handle a special dir of Rockridge extensions,
			 * ""rr_moved"".
			 */
			if (file->rr_moved) {
				/*
				 * If this has only the subdirectories which
				 * have ""RE"" flags, do not expose at this time.
				 */
				if (file->rr_moved_has_re_only)
					continue;
				/* Otherwise expose ""rr_moved"" entry. */
			} else if (file->re) {
				/*
				 * Do not expose this at this time
				 * because we have not gotten its full-path
				 * name yet.
				 */
				re_add_entry(iso9660, file);
				continue;
			} else if (file->re_descendant) {
				/*
				 * If the top level ""RE"" entry of this entry
				 * is not exposed, we, accordingly, should not
				 * expose this entry at this time because
				 * we cannot make its proper full-path name.
				 */
				if (rede_add_entry(file) == 0)
					continue;
				/* Otherwise we can expose this entry because
				 * it seems its top level ""RE"" has already been
				 * exposed. */
			}
		}
		break;
	}

	if ((file->mode & AE_IFMT) != AE_IFREG || file->number == -1)
		return (ARCHIVE_OK);

	count = 0;
	number = file->number;
	iso9660->cache_files.first = NULL;
	iso9660->cache_files.last = &(iso9660->cache_files.first);
	empty_files.first = NULL;
	empty_files.last = &empty_files.first;
	/* Collect files which has the same file serial number.
	 * Peek pending_files so that file which number is different
	 * is not put bak. */
	while (iso9660->pending_files.used > 0 &&
	    (iso9660->pending_files.files[0]->number == -1 ||
	     iso9660->pending_files.files[0]->number == number)) {
		if (file->number == -1) {
			/* This file has the same offset
			 * but it's wrong offset which empty files
			 * and symlink files have.
			 * NOTE: This wrong offse was recorded by
			 * old mkisofs utility. If ISO images is
			 * created by latest mkisofs, this does not
			 * happen.
			 */
			file->next = NULL;
			*empty_files.last = file;
			empty_files.last = &(file->next);
		} else {
			count++;
			cache_add_entry(iso9660, file);
		}
		file = next_entry(iso9660);
	}

	if (count == 0) {
		*pfile = file;
		return ((file == NULL)?ARCHIVE_EOF:ARCHIVE_OK);
	}
	if (file->number == -1) {
		file->next = NULL;
		*empty_files.last = file;
		empty_files.last = &(file->next);
	} else {
		count++;
		cache_add_entry(iso9660, file);
	}

	if (count > 1) {
		/* The count is the same as number of hardlink,
		 * so much so that each nlinks of files in cache_file
		 * is overwritten by value of the count.
		 */
		for (file = iso9660->cache_files.first;
		    file != NULL; file = file->next)
			file->nlinks = count;
	}
	/* If there are empty files, that files are added
	 * to the tail of the cache_files. */
	if (empty_files.first != NULL) {
		*iso9660->cache_files.last = empty_files.first;
		iso9660->cache_files.last = empty_files.last;
	}
	*pfile = cache_get_entry(iso9660);
	return ((*pfile == NULL)?ARCHIVE_EOF:ARCHIVE_OK);

fatal_rr:
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of""
	    ""Rockridge extensions"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_530.cpp,"[24, 6, 2, 0, 3, 4, 8, 0, 0, 0, 37, 1, 2, 0, 0, 327, 0, 0, 9, 11, 0, 0, 4, 19, 0, 0, 0, 0, 7, 0, 22, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 203, 2, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 2, 0, 34, 26, 5, 0, 22, 0, 0, 39, 3, 34, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_530.cpp,203
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_384.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_384.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_384.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_787.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_787.cpp,445,446,448,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""lha: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_531.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_531.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""lha: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_531.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_531.cpp,22
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_386.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_791.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_791.cpp,757,770,760,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
        ""rar: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_532.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_532.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
        ""rar: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_532.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_532.cpp,22
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_386.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_792.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_792.cpp,842,857,847,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR volume support unavailable."");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_533.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_533.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR volume support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_533.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_533.cpp,81
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_386.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_792.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_792.cpp,842,857,853,859,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");","(rar->main_flags & MHD_PASSWORD)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      };",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_534.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_534.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_534.cpp,87
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_386.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_386.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_792.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_792.cpp,842,857,853,861,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_535.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_535.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_535.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_535.cpp,87
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_387.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_387.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_387.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_802.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_802.cpp,383,384,386,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""tar: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_536.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_536.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""tar: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_536.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_536.cpp,27
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_806.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_806.cpp,373,750,379,764,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Symlink"");","archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_537.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_537.cpp,"{
			/* NOTE: If the last argument is NULL, this will
			 * fail only by memeory allocation failure. */
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Symlink"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_537.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_537.cpp,49
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_806.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_806.cpp,373,750,388,775,,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_538.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_538.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_538.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_538.cpp,0
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_808.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_808.cpp,439,850,442,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""zip: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_539.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_539.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""zip: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_539.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_539.cpp,27
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_811.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_811.cpp,781,1222,788,1231,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size ""
			    ""(read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_540.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_540.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_540.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_540.cpp,56
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_812.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_812.cpp,797,1241,798,1242,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size ""
			    ""(read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_541.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_541.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_541.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_541.cpp,66
102071f80cf4ad7aa97bf8a1618cfc6ee6689ab6,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive.h
	Utilities/cmlibarchive/libarchive/archive_entry.h
	Utilities/cmlibarchive/libarchive/archive_read_disk_posix.c
	Utilities/cmlibarchive/libarchive/archive_read_support_format_iso9660.c
	Utilities/cmlibarchive/libarchive/archive_windows.h
	Utilities/cmlibarchive/libarchive/archive_write_set_format_iso9660.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_388.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_815.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_815.cpp,940,1419,950,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Can't initialize ZIP decompression."");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_542.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_542.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Can't initialize ZIP decompression."");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_542.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_542.cpp,31
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_390.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_390.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_390.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_819.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_819.cpp,1130,1326,1131,1327,"archive_set_error(
							&filter->archive->archive,
							ENOMEM,
						    ""Unable to allocate copy buffer"");","archive_set_error(
						    &filter->archive->archive,
						    ENOMEM,
						    ""Unable to allocate copy""
						    "" buffer"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_543.cpp,"{ /* Integer overflow! */
						archive_set_error(
							&filter->archive->archive,
							ENOMEM,
						    ""Unable to allocate copy buffer"");
						filter->fatal = 1;
						if (avail != NULL)
							*avail = ARCHIVE_FATAL;
						return (NULL);
					}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_543.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_543.cpp,107
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_820.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_820.cpp,210,223,212,231,,"archive_set_error(&a->archive, errno,
				    ""Couldn't read link data"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_544.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_544.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_544.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_544.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_824.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_824.cpp,853,1070,863,-1,"archive_set_error(&a->archive, errno,
				    ""FIEMAP failed"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_545.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_545.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""FIEMAP failed"");
				exit_sts = ARCHIVE_FAILED;
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_545.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_545.cpp,50
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_entry_from_file.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_391.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_825.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_825.cpp,923,1130,940,1164,,"archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_546.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_546.cpp,"(fd < 0) {
			archive_set_error(&a->archive, errno,
			    ""Can't open `%s'"", path);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_546.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_546.cpp,31
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_392.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_392.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_392.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_826.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_826.cpp,1028,1241,1034,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_547.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_547.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_547.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_547.cpp,10
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_posix.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_392.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_392.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_392.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_827.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_827.cpp,1079,1290,1080,1293,,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_548.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_548.cpp,"(archive_string_append_from_wcs(&path, pathname,
	    wcslen(pathname)) != 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't convert a path to a char string"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		ret = ARCHIVE_FATAL;
	} else
		ret = _archive_read_disk_open(_a, path.s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_548.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 9, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_548.cpp,15
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_832.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_832.cpp,557,549,608,591,"archive_set_error(&a->archive, errno, ""Seek error"");","archive_set_error(&a->archive, errno,
			    ""CreateEvent failed"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_549.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_549.cpp,"{
			DWORD lasterr;

			lasterr = GetLastError();
			if (lasterr == ERROR_ACCESS_DENIED)
				errno = EBADF;
			else
				la_dosmaperr(lasterr);
			archive_set_error(&a->archive, errno, ""Seek error"");
			r = ARCHIVE_FATAL;
			a->archive.state = ARCHIVE_STATE_FATAL;
			goto abort_read_data;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_549.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 23, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 6, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_549.cpp,49
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_832.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_832.cpp,557,549,559,632,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Reading file truncated"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_550.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_550.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_550.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_550.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_832.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_832.cpp,557,549,559,704,,"archive_set_error(&a->archive, errno,
		    ""GetOverlappedResult failed"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_551.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_551.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_551.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_832.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_832.cpp,557,549,559,714,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Reading file truncated"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_552.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_552.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_552.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_552.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_833.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_833.cpp,701,768,703,770,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));","archive_set_error(&a->archive, t->tree_errno,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_553.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_553.cpp,"{
		case TREE_ERROR_FATAL:
			archive_set_error(&a->archive, t->tree_errno,
			    ""%ls: Unable to continue traversing directory tree"",
			    tree_current_path(t));
			a->archive.state = ARCHIVE_STATE_FATAL;
			return (ARCHIVE_FATAL);
		case TREE_ERROR_DIR:
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""%ls: Couldn't visit directory"",
			    tree_current_path(t));
			return (ARCHIVE_FAILED);
		case 0:
			return (ARCHIVE_EOF);
		case TREE_POSTDESCENT:
		case TREE_POSTASCENT:
			break;
		case TREE_REGULAR:
			lst = tree_current_lstat(t);
			if (lst == NULL) {
				archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));
				return (ARCHIVE_FAILED);
			}
			break;
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_553.cpp,"[1, 0, 0, 0, 2, 0, 4, 0, 6, 0, 2, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 7, 0, 0, 5, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_553.cpp,30
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_834.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_834.cpp,713,780,715,782,"archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));","archive_set_error(&a->archive, t->tree_errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_554.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_554.cpp,"{
				archive_set_error(&a->archive, errno,
				    ""%ls: Cannot stat"",
				    tree_current_path(t));
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_554.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_554.cpp,42
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_835.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_835.cpp,759,846,774,871,,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_555.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_555.cpp,"(name != NULL)
		archive_entry_copy_uname(entry, name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_555.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_555.cpp,101
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_835.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_835.cpp,759,846,781,897,,"archive_set_error(&(a->archive), errno,
			    ""Faild : %s"", archive_error_string(a->matching));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_556.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_556.cpp,"(archive_entry_filetype(entry) == AE_IFREG &&
	    archive_entry_size(entry) > 0) {
		t->entry_fh = CreateFileW(tree_current_access_path(t),
		    GENERIC_READ, 0, NULL, OPEN_EXISTING,
		    FILE_FLAG_SEQUENTIAL_SCAN, NULL);
		if (t->entry_fh == INVALID_HANDLE_VALUE) {
			archive_set_error(&a->archive, errno,
			    ""Couldn't open %ls"", tree_current_path(a->tree));
			return (ARCHIVE_FAILED);
		}

		/* Find sparse data from the disk. */
		if (archive_entry_hardlink(entry) == NULL &&
		    (st->dwFileAttributes & FILE_ATTRIBUTE_SPARSE_FILE) != 0)
			r = setup_sparse_from_disk(a, entry, t->entry_fh);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_556.cpp,"[2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 8, 0, 0, 4, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_556.cpp,108
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_836.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_836.cpp,878,1129,884,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_557.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_557.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignored the request descending the current object"");
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_557.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_557.cpp,10
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_837.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_837.cpp,920,1169,921,1172,,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_558.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_558.cpp,"(archive_wstring_append_from_mbs(&wpath, pathname,
	    strlen(pathname)) != 0) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Can't convert a path to a wchar_t string"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		ret = ARCHIVE_FATAL;
	} else
		ret = _archive_read_disk_open_w(_a, wpath.s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_558.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 9, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_558.cpp,15
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_838.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_838.cpp,955,1208,956,1209,"archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate direcotry traversal data"");","archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate directory traversal data"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_559.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_559.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""Can't allocate direcotry traversal data"");
		a->archive.state = ARCHIVE_STATE_FATAL;
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_559.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_559.cpp,10
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_842.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_842.cpp,1775,2084,1777,2087,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
				    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_560.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_560.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't GetFileInformationByHandle"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_560.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_560.cpp,32
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_843.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_843.cpp,1785,2095,1788,2099,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't FindFirstFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't FindFirstFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_561.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_561.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't FindFirstFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_561.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_561.cpp,43
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_844.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_844.cpp,1807,2118,1809,2121,"archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't CreateFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't CreateFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_562.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_562.cpp,"{
				archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't CreateFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_562.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_562.cpp,64
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_844.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_844.cpp,1807,2118,1816,2128,"archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
				    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_563.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_563.cpp,"{
				archive_set_error(&a->archive,
				    GetLastError(),
				    ""Can't GetFileInformationByHandle"");
				CloseHandle(h);
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_563.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_563.cpp,71
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_845.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_845.cpp,1854,2165,1856,2168,"archive_set_error(&a->archive, GetLastError(),
				    ""Can't CreateFileW"");","archive_set_error(&a->archive, errno,
				    ""Can't CreateFileW"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_564.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_564.cpp,"{
				archive_set_error(&a->archive, GetLastError(),
				    ""Can't CreateFileW"");
				return (ARCHIVE_FAILED);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_564.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_564.cpp,111
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_845.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_845.cpp,1854,2165,1863,2176,"archive_set_error(&a->archive, GetLastError(),
			    ""Can't GetFileInformationByHandle"");","archive_set_error(&a->archive, errno,
			    ""Can't GetFileInformationByHandle"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_565.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_565.cpp,"{
			archive_set_error(&a->archive, GetLastError(),
			    ""Can't GetFileInformationByHandle"");
			if (h != INVALID_HANDLE_VALUE && fd < 0)
				CloseHandle(h);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_565.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_565.cpp,118
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_846.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_846.cpp,1909,2222,1911,2224,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			""Couldn't allocate memory"");","archive_set_error(&a->archive, ENOMEM,
			""Couldn't allocate memory"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_566.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_566.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			""Couldn't allocate memory"");
		exit_sts = ARCHIVE_FATAL;
		goto exit_setup_sparse;
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_566.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_566.cpp,14
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_disk_windows.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_393.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_393.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_847.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_847.cpp,1923,2236,1932,2245,"archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Couldn't allocate memory"");","archive_set_error(&a->archive, ENOMEM,
					    ""Couldn't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_567.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_567.cpp,"{
					archive_set_error(&a->archive,
					    ARCHIVE_ERRNO_MISC,
					    ""Couldn't allocate memory"");
					exit_sts = ARCHIVE_FATAL;
					goto exit_setup_sparse;
				}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_567.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_567.cpp,35
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_849.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_849.cpp,98,103,132,190,"archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");","archive_set_error(a, EINVAL,
				    ""Failed to convert a wide-character""
				    "" filename to a multi-byte filename"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_568.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_568.cpp,"{
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_568.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_568.cpp,23
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_849.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_849.cpp,98,103,108,151,,"archive_set_error(a, ENOMEM, ""No memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_569.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_569.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_569.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_849.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_849.cpp,98,103,115,163,,"archive_set_error(a, ENOMEM, ""No memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_570.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_570.cpp,"(wfilename == NULL || wfilename[0] == L'\0') {
		filename_type = FNT_STDIN;
	} else {
#if defined(_WIN32) && !defined(__CYGWIN__)
		filename_type = FNT_WCS;
#else
		/*
		 * POSIX system does not support a wchar_t interface for
		 * open() system call, so we have to translate a whcar_t
		 * filename to multi-byte one and use it.
		 */
		struct archive_string fn;
		int r;

		archive_string_init(&fn);
		if (archive_string_append_from_wcs(&fn, wfilename,
		    wcslen(wfilename)) != 0) {
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}
		r = file_open_filename(a, FNT_MBS, fn.s, block_size);
		archive_string_free(&fn);
		return (r);
#endif
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_570.cpp,"[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 42, 0, 0, 2, 2, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 2, 0, 9, 0, 0, 7, 0, 16, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_570.cpp,6
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_open_filename.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_395.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_849.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_849.cpp,98,103,131,187,,"archive_set_error(a, errno,
				    ""Can't allocate memory"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_571.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_571.cpp,"(archive_string_append_from_wcs(&fn, wfilename,
		    wcslen(wfilename)) != 0) {
			archive_set_error(a, EINVAL,
			    ""Failed to convert a wide-character filename to""
			    "" a multi-byte filename"");
			archive_string_free(&fn);
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_571.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_571.cpp,22
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_bzip2.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_396.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_396.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_396.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_853.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_853.cpp,102,103,103,104,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bunzip2 program"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bzip2 program"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_572.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_572.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *reader;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_bzip2"");

	if (__archive_read_get_bidder(a, &reader) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	reader->data = NULL;
	reader->bid = bzip2_reader_bid;
	reader->init = bzip2_reader_init;
	reader->options = NULL;
	reader->free = bzip2_reader_free;
#if defined(HAVE_BZLIB_H) && defined(BZ_CONFIG_ERROR)
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external bunzip2 program"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_572.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 5, 0, 0, 7, 0, 11, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_572.cpp,20
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_gzip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_397.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_397.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_397.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_854.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_854.cpp,109,110,110,111,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gunzip program"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gzip program"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_573.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_573.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_gzip"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = gzip_bidder_bid;
	bidder->init = gzip_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL; /* No data, so no cleanup necessary. */
	/* Signal the extent of gzip support with the return value here. */
#if HAVE_ZLIB_H
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external gunzip program"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_573.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 45, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_573.cpp,21
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_398.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_855.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_855.cpp,79,82,99,-1,"archive_set_error(_a, -1,
	    ""External compression programs not supported on this platform"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_574.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_574.cpp,"{
	(void)_a; /* UNUSED */
	(void)cmd; /* UNUSED */
	(void)signature; /* UNUSED */
	(void)signature_len; /* UNUSED */

	archive_set_error(_a, -1,
	    ""External compression programs not supported on this platform"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_574.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 5, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_574.cpp,9
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_398.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_855.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_855.cpp,79,82,110,-1,"archive_set_error(&self->archive->archive, -1,
	    ""External compression programs not supported on this platform"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_575.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_575.cpp,"{
	(void)self; /* UNUSED */
	(void)cmd; /* UNUSED */

	archive_set_error(&self->archive->archive, -1,
	    ""External compression programs not supported on this platform"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_575.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_575.cpp,6
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_program.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_398.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_398.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_856.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_856.cpp,376,399,412,444,,"archive_set_error(&self->archive->archive, EINVAL,
		    ""Can't initialize filter; unable to run program \""%s\"""",
		    cmd);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_576.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_576.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_576.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_576.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_uu.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_399.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_399.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_399.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_857.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_857.cpp,485,491,493,501,"archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");",uudecode->state = ST_IGNORE;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_577.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_577.cpp,"{
			/* Non-ascii character is found. */
			archive_set_error(&self->archive->archive,
			    ARCHIVE_ERRNO_MISC,
			    ""Insufficient compressed data"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_577.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_577.cpp,46
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_400.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_400.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_400.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_859.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_859.cpp,144,145,145,146,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unxz program for xz decompression"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external xz program for xz decompression"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_578.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_578.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_xz"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = xz_bidder_bid;
	bidder->init = xz_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unxz program for xz decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_578.cpp,"[2, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 46, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_578.cpp,20
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_filter_xz.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_400.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_400.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_400.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_860.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_860.cpp,180,182,181,183,"archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unlzma program for lzma decompression"");","archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external lzma program for lzma decompression"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_579.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_579.cpp,"{
	struct archive_read *a = (struct archive_read *)_a;
	struct archive_read_filter_bidder *bidder;

	archive_check_magic(_a, ARCHIVE_READ_MAGIC,
	    ARCHIVE_STATE_NEW, ""archive_read_support_filter_lzma"");

	if (__archive_read_get_bidder(a, &bidder) != ARCHIVE_OK)
		return (ARCHIVE_FATAL);

	bidder->data = NULL;
	bidder->bid = lzma_bidder_bid;
	bidder->init = lzma_bidder_init;
	bidder->options = NULL;
	bidder->free = NULL;
#if HAVE_LZMA_H && HAVE_LIBLZMA
	return (ARCHIVE_OK);
#elif HAVE_LZMADEC_H && HAVE_LIBLZMADEC
	return (ARCHIVE_OK);
#else
	archive_set_error(_a, ARCHIVE_ERRNO_MISC,
	    ""Using external unlzma program for lzma decompression"");
	return (ARCHIVE_WARN);
#endif
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_579.cpp,"[2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 49, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 7, 0, 9, 4, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_579.cpp,22
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_cab.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_402.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_402.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_402.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_869.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_869.cpp,478,481,481,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cab: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_580.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_580.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cab: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_580.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_580.cpp,21
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_cpio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_403.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_403.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_403.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_872.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_872.cpp,339,340,342,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cpio: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_581.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_581.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""cpio: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_581.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_581.cpp,26
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_404.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_404.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_404.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_878.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_878.cpp,1286,1310,1309,1329,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
		    (intmax_t)file->number,
		    iso9660->pathname.s,
		    (intmax_t)file->offset,
		    (intmax_t)iso9660->current_position);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
			    (intmax_t)file->number,
			    iso9660->pathname.s,
			    (intmax_t)file->offset,
			    (intmax_t)iso9660->current_position);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_582.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_582.cpp,"{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""Ignoring out-of-order file @%jx (%s) %jd < %jd"",
		    (intmax_t)file->number,
		    iso9660->pathname.s,
		    (intmax_t)file->offset,
		    (intmax_t)iso9660->current_position);
		iso9660->entry_bytes_remaining = 0;
		iso9660->entry_sparse_offset = 0;
		return (ARCHIVE_WARN);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_582.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_582.cpp,248
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_iso9660.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_404.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_404.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_404.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_882.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_882.cpp,2882,2888,2883,2889,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of""
	    ""Rockridge extensions"");","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of ""
	    ""Rockridge extensions: current position = %jd, CL offset = %jd"",
	    (intmax_t)iso9660->current_position, (intmax_t)file->cl_offset);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_583.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_583.cpp,"{
	struct file_info *file;
	struct {
		struct file_info	*first;
		struct file_info	**last;
	}	empty_files;
	int64_t number;
	int count;

	file = cache_get_entry(iso9660);
	if (file != NULL) {
		*pfile = file;
		return (ARCHIVE_OK);
	}

	for (;;) {
		struct file_info *re, *d;

		*pfile = file = next_entry(iso9660);
		if (file == NULL) {
			/*
			 * If directory entries all which are descendant of
			 * rr_moved are stil remaning, expose their. 
			 */
			if (iso9660->re_files.first != NULL && 
			    iso9660->rr_moved != NULL &&
			    iso9660->rr_moved->rr_moved_has_re_only)
				/* Expose ""rr_moved"" entry. */
				cache_add_entry(iso9660, iso9660->rr_moved);
			while ((re = re_get_entry(iso9660)) != NULL) {
				/* Expose its descendant dirs. */
				while ((d = rede_get_entry(re)) != NULL)
					cache_add_entry(iso9660, d);
			}
			if (iso9660->cache_files.first != NULL)
				return (next_cache_entry(a, iso9660, pfile));
			return (ARCHIVE_EOF);
		}

		if (file->cl_offset) {
			struct file_info *first_re = NULL;
			int nexted_re = 0;

			/*
			 * Find ""RE"" dir for the current file, which
			 * has ""CL"" flag.
			 */
			while ((re = re_get_entry(iso9660))
			    != first_re) {
				if (first_re == NULL)
					first_re = re;
				if (re->offset == file->cl_offset) {
					re->parent->subdirs--;
					re->parent = file->parent;
					re->re = 0;
					if (re->parent->re_descendant) {
						nexted_re = 1;
						re->re_descendant = 1;
						if (rede_add_entry(re) < 0)
							goto fatal_rr;
						/* Move a list of descendants
						 * to a new ancestor. */
						while ((d = rede_get_entry(
						    re)) != NULL)
							if (rede_add_entry(d)
							    < 0)
								goto fatal_rr;
						break;
					}
					/* Replace the current file
					 * with ""RE"" dir */
					*pfile = file = re;
					/* Expose its descendant */
					while ((d = rede_get_entry(
					    file)) != NULL)
						cache_add_entry(
						    iso9660, d);
					break;
				} else
					re_add_entry(iso9660, re);
			}
			if (nexted_re) {
				/*
				 * Do not expose this at this time
				 * because we have not gotten its full-path
				 * name yet.
				 */
				continue;
			}
		} else if ((file->mode & AE_IFMT) == AE_IFDIR) {
			int r;

			/* Read file entries in this dir. */
			r = read_children(a, file);
			if (r != ARCHIVE_OK)
				return (r);

			/*
			 * Handle a special dir of Rockridge extensions,
			 * ""rr_moved"".
			 */
			if (file->rr_moved) {
				/*
				 * If this has only the subdirectories which
				 * have ""RE"" flags, do not expose at this time.
				 */
				if (file->rr_moved_has_re_only)
					continue;
				/* Otherwise expose ""rr_moved"" entry. */
			} else if (file->re) {
				/*
				 * Do not expose this at this time
				 * because we have not gotten its full-path
				 * name yet.
				 */
				re_add_entry(iso9660, file);
				continue;
			} else if (file->re_descendant) {
				/*
				 * If the top level ""RE"" entry of this entry
				 * is not exposed, we, accordingly, should not
				 * expose this entry at this time because
				 * we cannot make its proper full-path name.
				 */
				if (rede_add_entry(file) == 0)
					continue;
				/* Otherwise we can expose this entry because
				 * it seems its top level ""RE"" has already been
				 * exposed. */
			}
		}
		break;
	}

	if ((file->mode & AE_IFMT) != AE_IFREG || file->number == -1)
		return (ARCHIVE_OK);

	count = 0;
	number = file->number;
	iso9660->cache_files.first = NULL;
	iso9660->cache_files.last = &(iso9660->cache_files.first);
	empty_files.first = NULL;
	empty_files.last = &empty_files.first;
	/* Collect files which has the same file serial number.
	 * Peek pending_files so that file which number is different
	 * is not put bak. */
	while (iso9660->pending_files.used > 0 &&
	    (iso9660->pending_files.files[0]->number == -1 ||
	     iso9660->pending_files.files[0]->number == number)) {
		if (file->number == -1) {
			/* This file has the same offset
			 * but it's wrong offset which empty files
			 * and symlink files have.
			 * NOTE: This wrong offse was recorded by
			 * old mkisofs utility. If ISO images is
			 * created by latest mkisofs, this does not
			 * happen.
			 */
			file->next = NULL;
			*empty_files.last = file;
			empty_files.last = &(file->next);
		} else {
			count++;
			cache_add_entry(iso9660, file);
		}
		file = next_entry(iso9660);
	}

	if (count == 0) {
		*pfile = file;
		return ((file == NULL)?ARCHIVE_EOF:ARCHIVE_OK);
	}
	if (file->number == -1) {
		file->next = NULL;
		*empty_files.last = file;
		empty_files.last = &(file->next);
	} else {
		count++;
		cache_add_entry(iso9660, file);
	}

	if (count > 1) {
		/* The count is the same as number of hardlink,
		 * so much so that each nlinks of files in cache_file
		 * is overwritten by value of the count.
		 */
		for (file = iso9660->cache_files.first;
		    file != NULL; file = file->next)
			file->nlinks = count;
	}
	/* If there are empty files, that files are added
	 * to the tail of the cache_files. */
	if (empty_files.first != NULL) {
		*iso9660->cache_files.last = empty_files.first;
		iso9660->cache_files.last = empty_files.last;
	}
	*pfile = cache_get_entry(iso9660);
	return ((*pfile == NULL)?ARCHIVE_EOF:ARCHIVE_OK);

fatal_rr:
	archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
	    ""Failed to connect 'CL' pointer to 'RE' rr_moved pointer of""
	    ""Rockridge extensions"");
	return (ARCHIVE_FATAL);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_583.cpp,"[24, 6, 2, 0, 3, 4, 8, 0, 0, 0, 37, 1, 2, 0, 0, 327, 0, 0, 9, 11, 0, 0, 4, 19, 0, 0, 0, 0, 7, 0, 22, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 203, 2, 124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 2, 0, 34, 26, 5, 0, 22, 0, 0, 39, 3, 34, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_583.cpp,203
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_lha.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_405.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_405.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_405.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_883.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_883.cpp,445,446,448,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""lha: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_584.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_584.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""lha: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_584.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_584.cpp,22
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_887.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_887.cpp,757,770,760,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
        ""rar: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_585.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_585.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
        ""rar: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_585.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_585.cpp,22
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_888.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_888.cpp,842,857,847,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR volume support unavailable."");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_586.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_586.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR volume support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_586.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_586.cpp,81
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_888.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_888.cpp,842,857,853,859,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");","(rar->main_flags & MHD_PASSWORD)
      {
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      };",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_587.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_587.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_587.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_587.cpp,87
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_rar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_407.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_888.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_888.cpp,842,857,853,861,,"archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_588.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_588.cpp,"{
        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
                          ""RAR encryption support unavailable."");
        return (ARCHIVE_FATAL);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_588.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_588.cpp,87
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_tar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_408.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_408.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_898.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_898.cpp,383,384,386,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""tar: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_589.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_589.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""tar: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_589.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_589.cpp,27
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_902.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_902.cpp,373,750,379,764,"archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Symlink"");","archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Symlink"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_590.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_590.cpp,"{
			/* NOTE: If the last argument is NULL, this will
			 * fail only by memeory allocation failure. */
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Symlink"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_590.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_590.cpp,49
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_902.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_902.cpp,373,750,388,775,,"archive_set_error(&a->archive,
				    ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Symlink cannot be converted ""
				    ""from %s to current locale."",
				    archive_string_conversion_charset_name(
					sconv));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_591.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_591.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_591.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_591.cpp,0
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_904.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_904.cpp,439,850,442,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""zip: unknown keyword ``%s''"", key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_592.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_592.cpp,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
		    ""zip: unknown keyword ``%s''"", key)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_592.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_592.cpp,27
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_907.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_907.cpp,781,1222,788,1231,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size ""
			    ""(read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_593.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_593.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP compressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_compressed_bytes_read,
			    (intmax_t)zip->entry->compressed_size);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_593.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_593.cpp,56
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_908.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_908.cpp,797,1241,798,1242,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);","archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size ""
			    ""(read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_594.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_594.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""ZIP uncompressed data is wrong size (read %jd, expected %jd)"",
			    (intmax_t)zip->entry_uncompressed_bytes_read,
			    (intmax_t)zip->entry->uncompressed_size);
			return (ARCHIVE_WARN);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_594.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_594.cpp,66
35df7c8ba8854e97bd6994c4d1143f57535ed6f2,"libarchive 3.1.2 (reduced)

Extract upstream libarchive using the following shell code.

url=git://github.com/libarchive/libarchive.git &&
v=3.1.2 &&
r=19f23e19 &&
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
"" &&
mkdir libarchive-$v-g$r-reduced &&
git clone $url libarchive-git &&
date=$(cd libarchive-git && git log -n 1 --format='%cd' $r) &&
(cd libarchive-git && git archive --format=tar $r -- $paths) |
(cd libarchive-$v-g$r-reduced && tar xv) &&
fromdos libarchive-$v-g$r-reduced/build/cmake/Find*.cmake &&
echo ""g$r date: $date""",[],libarchive/archive_read_support_format_zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_409.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_409.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_911.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_911.cpp,940,1419,950,-1,"archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Can't initialize ZIP decompression."");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_595.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_595.cpp,"{
			archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
			    ""Can't initialize ZIP decompression."");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_595.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_595.cpp,31
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,256,288,"fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);","fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_596.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_596.cpp,"{
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_596.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_596.cpp,236
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,262,-1,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_597.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_597.cpp,"{
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_597.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_597.cpp,242
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,288,297,"fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);","fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", li->c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_598.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_598.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_598.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 410, 0, 0, 19, 22, 0, 0, 20, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 164, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_598.cpp,268
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,294,303,"fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");","fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_599.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_599.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_599.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 410, 0, 0, 19, 22, 0, 0, 20, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 164, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_599.cpp,274
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,304,314,"fprintf(fout,""%s "",compileFlags[i].c_str());","fprintf(fout,""%s "",compileDefs[i].c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_600.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_600.cpp,"{
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_600.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_600.cpp,284
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_918.cpp,242,270,247,292,,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_601.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_601.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_601.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_601.cpp,0
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_919.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_919.cpp,377,387,379,389,"fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());","fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_602.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_602.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_602.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 410, 0, 0, 19, 22, 0, 0, 20, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 164, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_602.cpp,359
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_919.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_919.cpp,377,387,380,393,,"fprintf(fout, "" \""%s\"""", si->c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_603.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_603.cpp,"(useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_603.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_603.cpp,360
4e5cb398ae392079031ae6a880569349c29770a6,"Merge branch 'master' into vs12-generator

Resolve conflicts in Tests/Preprocess/CMakeLists.txt by keeping
the side from 'master'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_412.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_919.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_919.cpp,377,387,380,401,,"fprintf(fout, "")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_604.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_604.cpp,"(useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_604.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_604.cpp,360
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_925.cpp,222,270,236,288,"fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);","fprintf(fout, ""SET(%s \""%s\"")\n"",
                rulesOverrideBase.c_str(), rulesOverridePath2);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_605.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_605.cpp,"{
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_605.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_605.cpp,216
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_925.cpp,222,270,242,-1,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_606.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_606.cpp,"{
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_606.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_606.cpp,222
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_925.cpp,222,270,268,297,"fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);","fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", li->c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_607.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_607.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_607.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 411, 0, 0, 19, 23, 0, 0, 21, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_607.cpp,248
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_925.cpp,222,270,274,303,"fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");","fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_608.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_608.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_608.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 411, 0, 0, 19, 23, 0, 0, 21, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_608.cpp,254
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_925.cpp,222,270,227,292,,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE%s)\n"", projectLangs.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_609.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_609.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_609.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_609.cpp,0
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_926.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_926.cpp,357,387,359,389,"fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());","fprintf(fout, ""ADD_EXECUTABLE(%s"", targetName);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_610.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_610.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());

    // we need to create a directory and CMakeLists file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeLists.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmOStringStream e;
      e << ""Failed to open\n""
        << ""  "" << outFileName.c_str() << ""\n""
        << cmSystemTools::GetLastSystemError();
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, e.str());
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameLastExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      fclose(fout);
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file\n""
          << ""  "" << source << ""\n""
          << ""try_compile() works only for enabled languages.  ""
          << ""Currently these are:\n "";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee project() command to enable other languages."";
      this->Makefile->IssueMessage(cmake::FATAL_ERROR, err.str());
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str());
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileDefs.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (size_t i = 0; i < compileDefs.size(); ++i)
        {
        fprintf(fout,""%s "",compileDefs[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* Use a random file name to avoid rapid creation and deletion
       of the same executable name (some filesystems fail on that).  */
    sprintf(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());
    targetName = targetNameBuf;

    if (!targets.empty())
      {
      std::string fname = ""/"" + std::string(targetName) + ""Targets.cmake"";
      cmExportTryCompileFileGenerator tcfg;
      tcfg.SetExportFile((this->BinaryDirectory + fname).c_str());
      tcfg.SetExports(targets);
      tcfg.SetConfig(this->Makefile->GetDefinition(
                                          ""CMAKE_TRY_COMPILE_CONFIGURATION""));

      if(!tcfg.GenerateImportFile())
        {
        this->Makefile->IssueMessage(cmake::FATAL_ERROR,
                                     ""could not write export file."");
        fclose(fout);
        return -1;
        }
      fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since
      cmLocalGenerator doesn't allow building for ""the other""
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }
    if(this->Makefile->GetDefinition(""CMAKE_POSITION_INDEPENDENT_CODE"")!=0)
      {
      fprintf(fout, ""SET(CMAKE_POSITION_INDEPENDENT_CODE \""ON\"")\n"");
      }

    /* Put the executable at a known location (for COPY_FILE).  */
    fprintf(fout, ""SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY \""%s\"")\n"",
            this->BinaryDirectory.c_str());
    /* Create the actual executable.  */
    fprintf(fout, ""ADD_EXECUTABLE(%s \""%s\"")\n"", targetName, source.c_str());
    if (useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    // if the source is not in CMakeTmp
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }

    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_610.cpp,"[16, 0, 2, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 6, 411, 0, 0, 19, 23, 0, 0, 21, 70, 0, 0, 0, 0, 7, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 1, 204, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 2, 0, 19, 17, 3, 0, 94, 0, 0, 51, 2, 108, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_610.cpp,339
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_926.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_926.cpp,357,387,360,393,,"fprintf(fout, "" \""%s\"""", si->c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_611.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_611.cpp,"(useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_611.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_611.cpp,340
482f1122ad5db4c51b26a6e943b4bb5ef3d800cc,"try_compile: Add signature to allow multiple SOURCES

Extend the signature

 try_compile(RESULT_VAR <bindir> <srcfile> ...)

to allow multiple sources as

 try_compile(RESULT_VAR <bindir> SOURCES <srcfile>... ...)

Process the sources to generate a CMakeLists.txt that enables all needed
languages.

Teach the TryCompile test to try cases with two sources of the same
language and of mixed languages.  Teach RunCMake.try_compile to cover
error cases for the signature.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_416.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_926.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_926.cpp,357,387,360,401,,"fprintf(fout, "")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_612.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_612.cpp,"(useOldLinkLibs)
      {
      fprintf(fout,
              ""TARGET_LINK_LIBRARIES(%s ${LINK_LIBRARIES})\n"",targetName);
      }
    else
      {
      fprintf(fout, ""TARGET_LINK_LIBRARIES(%s %s)\n"",
              targetName,
              libsToLink.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_612.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_612.cpp,340
d06db7ebe80636876d9701064b16cec9d3e2e3cb,"try_compile: Refactor argument processing

Process all arguments in a single loop using a simple state machine.
While at it, fix some error message typos.  Also allow LINK_LIBRARIES
with no actual libraries to disable use of the -DLINK_LIBRARIES=...
from the CMAKE_FLAGS.  This was already possible in the old logic if
LINK_LIBRARIES was immediately followed by another keyword argument
instead of the end of the argument list, so allow it in general.
Update the RunCMake.try_compile test cases accordingly.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_419.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_419.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_419.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_930.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_930.cpp,297,277,304,284,"fprintf(fout,""%s "",compileFlags[i].c_str());","fprintf(fout,""%s "",compileDefs[i].c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_613.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_613.cpp,"{
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_613.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_613.cpp,284
ddac8d3d2d027dd50d729918078f57628855a568,Fix spelling and typos (affecting binary data / module messages),[],Utilities/cmlibarchive/libarchive/archive_write_set_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_422.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_422.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_422.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_934.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_934.cpp,414,414,414,414,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unkonwn checksum name: `%s'"",
			    value);","archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unknown checksum name: `%s'"",
			    value);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_614.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_614.cpp,"{
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unkonwn checksum name: `%s'"",
			    value);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_614.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_614.cpp,15
ddac8d3d2d027dd50d729918078f57628855a568,Fix spelling and typos (affecting binary data / module messages),[],Utilities/cmlibarchive/libarchive/archive_write_set_format_xar.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_422.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_422.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_422.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_935.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_935.cpp,448,448,448,448,"archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unkonwn compression name: `%s'"",
			    value);","archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unknown compression name: `%s'"",
			    value);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_615.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_615.cpp,"{
			archive_set_error(&(a->archive),
			    ARCHIVE_ERRNO_MISC,
			    ""Unkonwn compression name: `%s'"",
			    value);
			return (ARCHIVE_FAILED);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_615.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_615.cpp,49
236133e79e2d047810eeba90915e38d9861e2a22,"Handle targets in the LINK_LIBRARIES of try_compile.

Imported targets are re-exported so that they can be used by the
try_compile generated code with target_link_libraries.

This makes the use of the cmake_expand_imported_targets macro
obsolete. The macro is not able to expand the generator expressions
which may appear in the IMPORTED_LINK_INTERFACE_LIBRARIES content.
Instead it just sees them as 'not a target'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_423.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_423.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_423.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_936.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_936.cpp,247,307,249,311,,"f(targetNameBuf, ""cmTryCompileExec%u"",
            cmSystemTools::RandomSeed());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_616.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_616.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_616.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_616.cpp,0
236133e79e2d047810eeba90915e38d9861e2a22,"Handle targets in the LINK_LIBRARIES of try_compile.

Imported targets are re-exported so that they can be used by the
try_compile generated code with target_link_libraries.

This makes the use of the cmake_expand_imported_targets macro
obsolete. The macro is not able to expand the generator expressions
which may appear in the IMPORTED_LINK_INTERFACE_LIBRARIES content.
Instead it just sees them as 'not a target'.",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_423.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_423.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_423.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_936.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_936.cpp,247,307,249,330,,"fprintf(fout,
              ""\ninclude(\""${CMAKE_CURRENT_LIST_DIR}/%s\"")\n\n"",
              fname.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_617.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_617.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_617.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_617.cpp,0
badb40d0f841dcfc4d098e59c5c570e73767cf68,"Merge branch 'master' into sublime-text-2-generator

Resolve conflict in Source/cmDocumentVariables.cxx by adding both
variables.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_424.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_937.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_937.cpp,365,335,379,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_618.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_618.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_618.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_618.cpp,47
badb40d0f841dcfc4d098e59c5c570e73767cf68,"Merge branch 'master' into sublime-text-2-generator

Resolve conflict in Source/cmDocumentVariables.cxx by adding both
variables.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_424.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_937.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_937.cpp,365,335,395,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_619.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_619.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_619.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_619.cpp,63
badb40d0f841dcfc4d098e59c5c570e73767cf68,"Merge branch 'master' into sublime-text-2-generator

Resolve conflict in Source/cmDocumentVariables.cxx by adding both
variables.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_424.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_424.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_938.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_938.cpp,1815,1653,1847,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_620.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_620.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_620.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_620.cpp,161
95a9c80cacea50e2b5d52d67d0a7f5c9b50192dd,"Merge topic 'LINK_LIBRARIES-property' into rpath-use-implicit-link-dirs

Resolve a logical conflict in the signature of cmTarget::GetLinkClosure.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_425.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_939.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_939.cpp,365,335,379,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_621.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_621.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_621.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_621.cpp,47
95a9c80cacea50e2b5d52d67d0a7f5c9b50192dd,"Merge topic 'LINK_LIBRARIES-property' into rpath-use-implicit-link-dirs

Resolve a logical conflict in the signature of cmTarget::GetLinkClosure.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_425.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_939.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_939.cpp,365,335,395,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_622.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_622.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_622.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_622.cpp,63
95a9c80cacea50e2b5d52d67d0a7f5c9b50192dd,"Merge topic 'LINK_LIBRARIES-property' into rpath-use-implicit-link-dirs

Resolve a logical conflict in the signature of cmTarget::GetLinkClosure.",[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_425.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_425.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_940.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_940.cpp,1815,1653,1847,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_623.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_623.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_623.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_623.cpp,161
7df291fb6e6971f60cc7b338bcaa81069ed11757,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_427.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_427.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_427.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_944.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_944.cpp,196,196,201,-1,"fprintf(stderr, ""No current working directory.\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_624.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_624.cpp,"{
    fprintf(stderr, ""No current working directory.\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_624.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_624.cpp,5
7df291fb6e6971f60cc7b338bcaa81069ed11757,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_427.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_427.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_427.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_945.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_945.cpp,245,243,250,-1,"fprintf(stderr, ""No current working directory\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_625.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_625.cpp,"{
    fprintf(stderr, ""No current working directory\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_625.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_625.cpp,5
9d66f74335a09019644c7b82af0860da439fce87,"KWSys 2013-02-05 (5c34ed2e)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 5c34ed2e | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 5b0d1bd9..5c34ed2e
Brad King (1):
      5c34ed2e SystemTools: Do not abort with no current directory

Change-Id: Id054017eac2bf10c71ca721df48298cdff2bea82",[],SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_428.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_428.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_428.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_946.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_946.cpp,196,196,201,-1,"fprintf(stderr, ""No current working directory.\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_626.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_626.cpp,"{
    fprintf(stderr, ""No current working directory.\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_626.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_626.cpp,5
9d66f74335a09019644c7b82af0860da439fce87,"KWSys 2013-02-05 (5c34ed2e)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 5c34ed2e | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 5b0d1bd9..5c34ed2e
Brad King (1):
      5c34ed2e SystemTools: Do not abort with no current directory

Change-Id: Id054017eac2bf10c71ca721df48298cdff2bea82",[],SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_428.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_428.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_428.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_947.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_947.cpp,245,243,250,-1,"fprintf(stderr, ""No current working directory\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_627.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_627.cpp,"{
    fprintf(stderr, ""No current working directory\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_627.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_627.cpp,5
118c32f8f211b0bb9a096fbb0711cacf2b68f057,Merge branch 'xcode-duplicate-flags-13354' into generator-toolset,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_431.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_954.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_954.cpp,365,335,379,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_628.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_628.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_628.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_628.cpp,47
118c32f8f211b0bb9a096fbb0711cacf2b68f057,Merge branch 'xcode-duplicate-flags-13354' into generator-toolset,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_431.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_954.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_954.cpp,365,335,395,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_629.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_629.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_629.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_629.cpp,63
118c32f8f211b0bb9a096fbb0711cacf2b68f057,Merge branch 'xcode-duplicate-flags-13354' into generator-toolset,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_431.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_431.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_955.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_955.cpp,1815,1653,1847,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_630.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_630.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_630.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_630.cpp,161
e33fa5b67880e47fb350d5545a5ba04b8d6f3eb3,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_432.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_956.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_956.cpp,365,335,379,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_631.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_631.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_631.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_631.cpp,47
e33fa5b67880e47fb350d5545a5ba04b8d6f3eb3,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_432.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_956.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_956.cpp,365,335,395,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_632.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_632.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_632.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_632.cpp,63
e33fa5b67880e47fb350d5545a5ba04b8d6f3eb3,Merge branch 'upstream-kwsys' into update-kwsys,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_432.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_432.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_957.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_957.cpp,1815,1653,1847,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_633.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_633.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_633.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_633.cpp,161
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_433.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_958.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_958.cpp,365,335,379,-1,"sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_634.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_634.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%ld_%p.exe"",
            GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Get a handle to the file that will delete it when closed.  */
      cp->Win9xHandle = CreateFile(win9x, GENERIC_READ, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);
      if(cp->Win9xHandle == INVALID_HANDLE_VALUE)
        {
        /* We were not able to get a read handle for the forwarding
           executable.  It will not be deleted properly.  Give up.  */
        _unlink(win9x);
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_634.cpp,"[5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 4, 15, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 5, 1, 0, 16, 0, 0, 11, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_634.cpp,47
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_433.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_958.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_958.cpp,365,335,395,-1,"sprintf(win9x, ""%s%s"", tempDir, fwdName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_635.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_635.cpp,"{
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_635.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_635.cpp,63
a0f91f1daa7765066a784e4479da7e231374a065,"KWSys 2012-12-19 (933eb822)

Extract upstream KWSys using the following shell commands.

$ git archive --prefix=upstream-kwsys/ 933eb822 | tar x
$ git shortlog --no-merges --abbrev=8 --format='%h %s' 3b17de34..933eb822
Brad King (2):
      fea37696 Process: Remove support for Windows 98
      01e15c22 Remove KWSys Registry

Rolf Eike Beer (7):
      f376ec32 SystemInformation: fix typos
      bfee5174 SystemInformation: sum up all caches found in /proc/cpuinfo
      5690d711 SystemInformation: fix value extraction from /proc/cpuinfo
      36295981 SystemInformation: PA-RISC chips are from HP
      72e9d02e SystemInformation: try harder to find a useful processor name
      b39de34c SystemInformation: try harder to find the CPU family
      933eb822 SystemInformation: extract CPU stepping information from /proc/cpuinfo, too

Sean McBride (2):
      5e17bfde Process: Dereference NULL++ instead of NULL to force crash
      86a78cb7 SystemTools: Add check for empty strings to prevent integer underflow

Change-Id: Id7194f434fe67be81e6ee9e96d705010a1171a06",[],ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_433.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_433.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_959.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_959.cpp,1815,1653,1847,-1,"sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_636.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_636.cpp,"{
    /* Create an error reporting pipe for the forwarding executable.
       Neither end is directly inherited.  */
    if(!CreatePipe(&si->ErrorPipeRead, &si->ErrorPipeWrite, 0, 0))
      {
      return 0;
      }

    /* Create an inherited duplicate of the write end.  This also closes
       the non-inherited version. */
    if(!DuplicateHandle(GetCurrentProcess(), si->ErrorPipeWrite,
                        GetCurrentProcess(), &si->ErrorPipeWrite,
                        0, TRUE, (DUPLICATE_CLOSE_SOURCE |
                                  DUPLICATE_SAME_ACCESS)))
      {
      return 0;
      }

    /* The forwarding executable is given a handle to the error pipe
       and resume and kill events.  */
    realCommand = (char*)malloc(strlen(cp->Win9x)+strlen(cp->Commands[index])+100);
    if(!realCommand)
      {
      return 0;
      }
    sprintf(realCommand, ""%s %p %p %p %d %s"", cp->Win9x,
            si->ErrorPipeWrite, cp->Win9xResumeEvent, cp->Win9xKillEvent,
            cp->HideWindow, cp->Commands[index]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_636.cpp,"[3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 53, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 3, 0, 0, 8, 0, 0, 2, 0, 22, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_636.cpp,161
5f12424ebc9f810ef279d09f1e660e20558dd535,"Remove process execution code from cmcldeps and have it use cmake code.

This simplifies the code in cmcldeps and avoids having yet another
set of process execution code.",[],Source/cmcldeps.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_439.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_439.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_439.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_965.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_965.cpp,132,35,221,-1,"snprintf(pipe_name, sizeof(pipe_name),
           ""\\\\.\\pipe\\ninja_pid%u_sp%p"", GetCurrentProcessId(), this);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_637.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_637.cpp,"{
  char pipe_name[100];
  snprintf(pipe_name, sizeof(pipe_name),
           ""\\\\.\\pipe\\ninja_pid%u_sp%p"", GetCurrentProcessId(), this);

  pipe_ = ::CreateNamedPipeA(pipe_name,
                             PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
                             PIPE_TYPE_BYTE,
                             PIPE_UNLIMITED_INSTANCES,
                             0, 0, INFINITE, NULL);
  if (pipe_ == INVALID_HANDLE_VALUE)
    Win32Fatal(""CreateNamedPipe"");

  if (!CreateIoCompletionPort(pipe_, ioport, (cmULONG_PTR)this, 0))
    Win32Fatal(""CreateIoCompletionPort"");

  memset(&overlapped_, 0, sizeof(overlapped_));
  if (!ConnectNamedPipe(pipe_, &overlapped_) &&
      GetLastError() != ERROR_IO_PENDING) {
    Win32Fatal(""ConnectNamedPipe"");
  }

  // Get the write end of the pipe as a handle inheritable across processes.
  HANDLE output_write_handle = CreateFile(pipe_name, GENERIC_WRITE, 0,
                                          NULL, OPEN_EXISTING, 0, NULL);
  HANDLE output_write_child;
  if (!DuplicateHandle(GetCurrentProcess(), output_write_handle,
                       GetCurrentProcess(), &output_write_child,
                       0, TRUE, DUPLICATE_SAME_ACCESS)) {
    Win32Fatal(""DuplicateHandle"");
  }
  CloseHandle(output_write_handle);

  return output_write_child;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_637.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 57, 0, 0, 3, 3, 0, 0, 1, 13, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 58, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 4, 4, 0, 0, 18, 0, 0, 8, 0, 43, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_637.cpp,2
1a38a5d65fa33f8ff06104b23f9bd38110387ddc,Ninja: allow spaces in cldeps's .d file,[],Source/cmcldeps.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_447.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_447.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_447.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_975.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_975.cpp,560,560,562,564,"fprintf(out, ""%s: \\\n"", objfile.c_str());","fprintf(out, ""%s: \\\n"", tmp.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_638.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_638.cpp,"{

  // strip duplicates
  sort(incs.begin(), incs.end());
  incs.erase(unique(incs.begin(), incs.end()), incs.end());

  FILE* out = fopen(dfile.c_str(), ""wb"");

  // FIXME should this be fatal or not? delete obj? delete d?
  if (!out)
    return;

  fprintf(out, ""%s: \\\n"", objfile.c_str());
  for (vector<string>::iterator i(incs.begin()); i != incs.end(); ++i) {
    string tmp = *i;
    doEscape(tmp, ""\\"", ""\\\\"");
    doEscape(tmp, "" "", ""\\ "");
    //doEscape(tmp, ""("", ""(""); // TODO ninja cant read ( and )
    //doEscape(tmp, "")"", "")"");
    fprintf(out, ""%s \\\n"", tmp.c_str());
  }

  fprintf(out, ""\n"");
  fclose(out);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_638.cpp,"[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 62, 0, 0, 2, 3, 0, 0, 3, 8, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 0, 0, 22, 0, 0, 8, 0, 25, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_638.cpp,13
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_979.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_979.cpp,2686,2629,2703,-1,"archive_set_error(&a->archive, ENOMEM,
		    ""No memory for 7-Zip decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_639.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_639.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""No memory for 7-Zip decompression"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_639.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_639.cpp,48
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_979.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_979.cpp,2686,2629,2735,2658,"archive_set_error(&a->archive, -1,
				    ""Malformed 7-Zip archive file"");",zip->header_bytes_remaining -= bytes;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_640.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_640.cpp,"{
				archive_set_error(&a->archive, -1,
				    ""Malformed 7-Zip archive file"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_640.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_640.cpp,80
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_979.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_979.cpp,2686,2629,2756,-1,"archive_set_error(&a->archive, -1, ""Header CRC error"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_641.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_641.cpp,"{
			archive_set_error(&a->archive, -1, ""Header CRC error"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_641.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_641.cpp,101
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_980.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_980.cpp,2810,2712,2827,2731,,"archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated 7-Zip file body"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_642.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_642.cpp,"(p[0]) {
	case kEncodedHeader:
		p++;
		len--;

		/*
		 * The archive has an encoded header and we have to decode it
		 * in order to parse the header correctly.
		 */
		image_bytes =
		    decode_header_image(a, zip, &(zip->si), p, len, &image);
		free_StreamsInfo(&(zip->si));
		memset(&(zip->si), 0, sizeof(zip->si));
		if (image_bytes < 0)
			return (ARCHIVE_FATAL);
		p = image;
		len = image_bytes;
		/* FALL THROUGH */
	case kHeader:
		/*
		 * Parse the header.
		 */
		errno = 0;
		r = read_Header(zip, header, p, len);
		if (r < 0) {
			if (errno == ENOMEM)
				archive_set_error(&a->archive, -1,
				    ""Couldn't allocate memory"");
			else
				archive_set_error(&a->archive, -1,
				    ""Damaged 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}
		if (len - r == 0 || p[r] != kEnd) {
			archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}
		break;
	default:
		archive_set_error(&a->archive, -1,
		    ""Unexpected Property ID = %X"", p[0]);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_642.cpp,"[4, 0, 0, 0, 1, 0, 4, 0, 2, 1, 6, 0, 0, 0, 0, 70, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 54, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 4, 1, 0, 9, 0, 0, 8, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_642.cpp,64
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_981.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_981.cpp,2858,2786,2860,2800,,"archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_643.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_643.cpp,"(len - r == 0 || p[r] != kEnd) {
			archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_643.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_643.cpp,97
156cb3bbf257f747672eac945fa2e19d33fc3a63,"Merge branch 'libarchive-upstream' into update-libarchive

Conflicts:
	Utilities/cmlibarchive/CMakeLists.txt
	Utilities/cmlibarchive/libarchive/archive_windows.c",[],Utilities/cmlibarchive/libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_450.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_983.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_983.cpp,2961,2908,2962,2947,,"archive_set_error(&a->archive, ENOMEM,
				    ""No memory for 7-Zip decompression"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_644.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_644.cpp,"(zip->uncompressed_buffer == NULL) {
		zip->uncompressed_buffer_size = 64 * 1024;
		zip->uncompressed_buffer =
		    malloc(zip->uncompressed_buffer_size);
		if (zip->uncompressed_buffer == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for 7-Zip decompression"");
			return (ARCHIVE_FATAL);
		}
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_644.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_644.cpp,26
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_991.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_991.cpp,2686,2629,2703,-1,"archive_set_error(&a->archive, ENOMEM,
		    ""No memory for 7-Zip decompression"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_645.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_645.cpp,"{
		archive_set_error(&a->archive, ENOMEM,
		    ""No memory for 7-Zip decompression"");
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_645.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_645.cpp,48
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_991.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_991.cpp,2686,2629,2735,2658,"archive_set_error(&a->archive, -1,
				    ""Malformed 7-Zip archive file"");",zip->header_bytes_remaining -= bytes;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_646.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_646.cpp,"{
				archive_set_error(&a->archive, -1,
				    ""Malformed 7-Zip archive file"");
				return (ARCHIVE_FATAL);
			}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_646.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_646.cpp,80
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_991.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_991.cpp,2686,2629,2756,-1,"archive_set_error(&a->archive, -1, ""Header CRC error"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_647.cpp,"{
			archive_set_error(&a->archive, -1, ""Header CRC error"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_647.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_647.cpp,101
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_992.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_992.cpp,2810,2712,2827,2731,,"archive_set_error(&a->archive,
		    ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Truncated 7-Zip file body"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_648.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_648.cpp,"(p[0]) {
	case kEncodedHeader:
		p++;
		len--;

		/*
		 * The archive has an encoded header and we have to decode it
		 * in order to parse the header correctly.
		 */
		image_bytes =
		    decode_header_image(a, zip, &(zip->si), p, len, &image);
		free_StreamsInfo(&(zip->si));
		memset(&(zip->si), 0, sizeof(zip->si));
		if (image_bytes < 0)
			return (ARCHIVE_FATAL);
		p = image;
		len = image_bytes;
		/* FALL THROUGH */
	case kHeader:
		/*
		 * Parse the header.
		 */
		errno = 0;
		r = read_Header(zip, header, p, len);
		if (r < 0) {
			if (errno == ENOMEM)
				archive_set_error(&a->archive, -1,
				    ""Couldn't allocate memory"");
			else
				archive_set_error(&a->archive, -1,
				    ""Damaged 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}
		if (len - r == 0 || p[r] != kEnd) {
			archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}
		break;
	default:
		archive_set_error(&a->archive, -1,
		    ""Unexpected Property ID = %X"", p[0]);
		return (ARCHIVE_FATAL);
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_648.cpp,"[4, 0, 0, 0, 1, 0, 4, 0, 2, 1, 6, 0, 0, 0, 0, 70, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 54, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 4, 1, 0, 9, 0, 0, 8, 0, 28, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_648.cpp,64
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_993.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_993.cpp,2858,2786,2860,2800,,"archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_649.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_649.cpp,"(len - r == 0 || p[r] != kEnd) {
			archive_set_error(&a->archive, -1,
			    ""Malformed 7-Zip archive"");
			return (ARCHIVE_FATAL);
		}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_649.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_649.cpp,97
4f4fe6e50bb3dbe59f9bc3cc848cbd07dead324d,"libarchive 3.0.2-r4051 (reduced)

Extract upstream libarchive using the following shell code.

url=https://libarchive.googlecode.com/svn/release/3.0
v=3.0.2
r=4051
paths=""
  CMakeLists.txt
  COPYING
  CTestConfig.cmake
  build/cmake
  build/pkgconfig
  build/utils
  build/version
  libarchive/*.*
""
date=$(svn log -q -c$r $url |
       sed -n ""/^r/ {s/[^|]*|[^|]*|//;p;}"")
svn export -r$r $url libarchive-$v-r$r &&
mkdir libarchive-$v-r$r-reduced &&
(cd libarchive-$v-r$r && tar c $paths) |
(cd libarchive-$v-r$r-reduced && tar x)
echo ""r$r date: $date""",[],libarchive/archive_read_support_format_7zip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_454.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_454.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_995.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_995.cpp,2961,2908,2962,2947,,"archive_set_error(&a->archive, ENOMEM,
				    ""No memory for 7-Zip decompression"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_650.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_650.cpp,"(zip->uncompressed_buffer == NULL) {
		zip->uncompressed_buffer_size = 64 * 1024;
		zip->uncompressed_buffer =
		    malloc(zip->uncompressed_buffer_size);
		if (zip->uncompressed_buffer == NULL) {
			archive_set_error(&a->archive, ENOMEM,
			    ""No memory for 7-Zip decompression"");
			return (ARCHIVE_FATAL);
		}
	}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_650.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_650.cpp,26
fd63219557c4acc6e474263302ab9c78985f6d91,"ccmake: Align 'g' and 'q' key instructions.

They were miss-aligned with the 'enter' key instruction.

Before:
----
Press [enter] to edit option           CMake Version 2.8.3.20110107-g4b05a-dirty
Press [c] to configure
Press [h] for help         Press [q] to quit without generating
----

After:
----
Press [enter] to edit option           CMake Version 2.8.3.20110107-g4b05a-dirty
Press [c] to configure
Press [h] for help           Press [q] to quit without generating
----",[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_459.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_459.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1003.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1003.cpp,421,421,422,422,"sprintf(firstLine,
              ""Press [c] to configure     Press [g] to generate and exit"");","sprintf(firstLine,
              ""Press [c] to configure       Press [g] to generate and exit"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_651.cpp,"{
      sprintf(firstLine,
              ""Press [c] to configure     Press [g] to generate and exit"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_651.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_651.cpp,44
58b7fe65453f1d4b25537950de2277af2951fd85,"Use cout instead of printf()

Alex",[],Source/cmQtAutomoc.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_465.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_465.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1018.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1018.cpp,405,405,407,407,"printf(""Checking -%s-\n"", absFilename.c_str());","std::cout << ""AUTOMOC: Checking "" << absFilename << std::endl;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_652.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_652.cpp,"{
      printf(""Checking -%s-\n"", absFilename.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_652.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_652.cpp,32
58b7fe65453f1d4b25537950de2277af2951fd85,"Use cout instead of printf()

Alex",[],Source/cmQtAutomoc.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_465.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_465.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1019.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1019.cpp,419,419,421,421,"printf(""Checking -%s-\n"", absFilename.c_str());","std::cout << ""AUTOMOC: Checking "" << absFilename << std::endl;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_653.cpp,"{
      printf(""Checking -%s-\n"", absFilename.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_653.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_653.cpp,46
dd2f81491e6e17681dd18882a8ccfa01fa32a3f7,"Merge branch 'dev/add_test-working-directory' into dev/strict-mode

Conflicts:
	Tests/CMakeLists.txt",[],Source/cmCoreTryCompile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_469.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_469.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_469.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1024.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1024.cpp,169,169,171,171,"fprintf(fout, ""cmake_minimum_required(VERSION %u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion());","fprintf(fout, ""cmake_minimum_required(VERSION %u.%u.%u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion(),
            cmVersion::GetPatchVersion(), cmVersion::GetTweakVersion());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_654.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_654.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = this->BinaryDirectory + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = this->BinaryDirectory.c_str();

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      cmSystemTools::ReportLastSystemError("""");
      return -1;
      }

    std::string source = argv[2];
    std::string ext = cmSystemTools::GetFilenameExtension(source);
    const char* lang =(this->Makefile->GetCMakeInstance()->GetGlobalGenerator()
                        ->GetLanguageFromExtension(ext.c_str()));
    const char* def = this->Makefile->GetDefinition(""CMAKE_MODULE_PATH"");
    fprintf(fout, ""cmake_minimum_required(VERSION %u.%u)\n"",
            cmVersion::GetMajorVersion(), cmVersion::GetMinorVersion());
    if(def)
      {
      fprintf(fout, ""SET(CMAKE_MODULE_PATH %s)\n"", def);
      }

    const char* rulesOverrideBase = ""CMAKE_USER_MAKE_RULES_OVERRIDE"";
    std::string rulesOverrideLang =
      rulesOverrideBase + (lang ? std::string(""_"") + lang : std::string(""""));
    if(const char* rulesOverridePath =
       this->Makefile->GetDefinition(rulesOverrideLang.c_str()))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideLang.c_str(), rulesOverridePath);
      }
    else if(const char* rulesOverridePath2 =
            this->Makefile->GetDefinition(rulesOverrideBase))
      {
      fprintf(fout, ""SET(%s \""%s\"")\n"",
              rulesOverrideBase, rulesOverridePath2);
      }

    if(lang)
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE %s)\n"", lang);
      }
    else
      {
      cmOStringStream err;
      err << ""Unknown extension \"""" << ext << ""\"" for file \""""
          << source << ""\"".  TRY_COMPILE only works for enabled languages.\n""
          << ""Currently enabled languages are:"";
      std::vector<std::string> langs;
      this->Makefile->GetCMakeInstance()->GetGlobalGenerator()->
        GetEnabledLanguages(langs);
      for(std::vector<std::string>::iterator l = langs.begin();
          l != langs.end(); ++l)
        {
        err << "" "" << *l;
        }
      err << ""\nSee PROJECT command for help enabling other languages."";
      cmSystemTools::Error(err.str().c_str());
      fclose(fout);
      return -1;
      }
    std::string langFlags = ""CMAKE_"";
    langFlags +=  lang;
    langFlags += ""_FLAGS"";
    fprintf(fout, ""SET(CMAKE_VERBOSE_MAKEFILE 1)\n"");
    fprintf(fout, ""SET(CMAKE_%s_FLAGS \"""", lang);
    const char* flags = this->Makefile->GetDefinition(langFlags.c_str()); 
    if(flags)
      {
      fprintf(fout, "" %s "", flags);
      }
    fprintf(fout, "" ${COMPILE_DEFINITIONS}\"")\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""SET(CMAKE_SUPPRESS_REGENERATION 1)\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }

    /* for the TRY_COMPILEs we want to be able to specify the architecture.
      So the user can set CMAKE_OSX_ARCHITECTURE to i386;ppc and then set 
      CMAKE_TRY_COMPILE_OSX_ARCHITECTURE first to i386 and then to ppc to
      have the tests run for each specific architecture. Since 
      cmLocalGenerator doesn't allow building for ""the other"" 
      architecture only via CMAKE_OSX_ARCHITECTURES.
      */
    if(this->Makefile->GetDefinition(""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(
                                        ""CMAKE_TRY_COMPILE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    else if (this->Makefile->GetDefinition(""CMAKE_OSX_ARCHITECTURES"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_ARCHITECTURES="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_ARCHITECTURES"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_SYSROOT to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_SYSROOT"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_SYSROOT="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_SYSROOT"");
      cmakeFlags.push_back(flag);
      }
    /* on APPLE also pass CMAKE_OSX_DEPLOYMENT_TARGET to the try_compile */
    if(this->Makefile->GetDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"")!=0)
      {
      std::string flag=""-DCMAKE_OSX_DEPLOYMENT_TARGET="";
      flag += this->Makefile->GetSafeDefinition(""CMAKE_OSX_DEPLOYMENT_TARGET"");
      cmakeFlags.push_back(flag);
      }

    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",source.c_str());
    fprintf(fout, 
            ""TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})\n"");
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    // if the source is not in CMakeTmp 
    if(source.find(""CMakeTmp"") == source.npos)
      {
      this->Makefile->AddCMakeDependFile(source.c_str());
      }
    
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_654.cpp,"[12, 0, 2, 0, 0, 0, 2, 0, 0, 0, 16, 0, 0, 0, 6, 315, 0, 0, 16, 19, 0, 0, 19, 56, 0, 0, 0, 0, 7, 0, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 1, 160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 2, 0, 15, 13, 2, 0, 72, 0, 0, 41, 2, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_654.cpp,154
aeb6cd8a8920c398b923d3ce383c06ed4643727f,"Merge branch 'honor-explicit-zero-timeout' into resolve/mingw-cross-compile-resources/honor-explicit-zero-timeout

Conflicts:
	Tests/CMakeLists.txt",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_470.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1025.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1025.cpp,503,503,511,-1,"sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_655.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_655.cpp,"{
      Person author;
      this->ParsePerson(this->Line.c_str()+7, author);
      this->Rev.Author = author.Name;
      this->Rev.EMail = author.EMail;

      // Convert the time to a human-readable format that is also easy
      // to machine-parse: ""CCYY-MM-DD hh:mm:ss"".
      time_t seconds = static_cast<time_t>(author.Time);
      struct tm* t = gmtime(&seconds);
      char dt[1024];
      sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);
      this->Rev.Date = dt;

      // Add the time-zone field ""+zone"" or ""-zone"".
      char tz[32];
      if(author.TimeZone >= 0)
        {
        sprintf(tz, "" +%04ld"", author.TimeZone);
        }
      else
        {
        sprintf(tz, "" -%04ld"", -author.TimeZone);
        }
      this->Rev.Date += tz;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_655.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 85, 0, 0, 5, 5, 0, 0, 2, 9, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 1, 1, 1, 0, 8, 0, 0, 8, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_655.cpp,19
aeb6cd8a8920c398b923d3ce383c06ed4643727f,"Merge branch 'honor-explicit-zero-timeout' into resolve/mingw-cross-compile-resources/honor-explicit-zero-timeout

Conflicts:
	Tests/CMakeLists.txt",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_470.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1025.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1025.cpp,503,503,520,-1,"sprintf(tz, "" +%04ld"", author.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_656.cpp,"{
        sprintf(tz, "" +%04ld"", author.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_656.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_656.cpp,28
aeb6cd8a8920c398b923d3ce383c06ed4643727f,"Merge branch 'honor-explicit-zero-timeout' into resolve/mingw-cross-compile-resources/honor-explicit-zero-timeout

Conflicts:
	Tests/CMakeLists.txt",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_470.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_470.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1025.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1025.cpp,503,503,524,-1,"sprintf(tz, "" -%04ld"", -author.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_657.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_657.cpp,"{
        sprintf(tz, "" -%04ld"", -author.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_657.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_657.cpp,32
4c88a8622dd25bc3d630f2d35e3a4acca9a7a5a2,"KWSys: Avoid buffer overflow in SystemInformation (#11018)

Use std::string instead of fixed-size char arrays.

Author: Ben Boeckel <ben.boeckel@kitware.com>",[u'https://gitlab.kitware.com/cmake/cmake/issues/11018'],Source/kwsys/SystemInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_471.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_471.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_471.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1026.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1026.cpp,3175,3166,3181,3172,"sprintf(this->ChipID.ProcessorName,""%s"",this->ParseValueFromKStat(""-s cpu_type"").c_str());","this->ChipID.ProcessorName = this->ParseValueFromKStat(""-s cpu_type"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_658.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_658.cpp,"{
  // Parse values
  this->NumberOfPhysicalCPU = static_cast<unsigned int>(
    atoi(this->ParseValueFromKStat(""-n syste_misc -s ncpus"").c_str()));
  this->NumberOfLogicalCPU = this->NumberOfPhysicalCPU;
  
  if(this->NumberOfPhysicalCPU!=0)
    {
    this->NumberOfLogicalCPU /= this->NumberOfPhysicalCPU;
    }

  this->CPUSpeedInMHz = static_cast<float>(atoi(this->ParseValueFromKStat(""-s clock_MHz"").c_str()));

  // Chip family
  this->ChipID.Family = 0; 
 
  // Chip Vendor
  strcpy(this->ChipID.Vendor,""Sun"");
  this->FindManufacturer();
  
  // Chip Model
  sprintf(this->ChipID.ProcessorName,""%s"",this->ParseValueFromKStat(""-s cpu_type"").c_str());
  this->ChipID.Model = 0;

  // Cache size
  this->Features.L1CacheSize = 0; 
  this->Features.L2CacheSize = 0;  

  char* tail;
  unsigned long totalMemory =
       strtoul(this->ParseValueFromKStat(""-s physmem"").c_str(),&tail,0);
  this->TotalPhysicalMemory = totalMemory/1024;
  this->TotalPhysicalMemory *= 8192;
  this->TotalPhysicalMemory /= 1024;

  // Undefined values (for now at least)
  this->TotalVirtualMemory = 0;
  this->AvailablePhysicalMemory = 0;
  this->AvailableVirtualMemory = 0;

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_658.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 97, 0, 0, 2, 2, 0, 0, 1, 19, 0, 0, 0, 0, 1, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 38, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 0, 18, 0, 0, 17, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_658.cpp,22
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,511,-1,"sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_659.cpp,"{
      Person author;
      this->ParsePerson(this->Line.c_str()+7, author);
      this->Rev.Author = author.Name;
      this->Rev.EMail = author.EMail;

      // Convert the time to a human-readable format that is also easy
      // to machine-parse: ""CCYY-MM-DD hh:mm:ss"".
      time_t seconds = static_cast<time_t>(author.Time);
      struct tm* t = gmtime(&seconds);
      char dt[1024];
      sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);
      this->Rev.Date = dt;

      // Add the time-zone field ""+zone"" or ""-zone"".
      char tz[32];
      if(author.TimeZone >= 0)
        {
        sprintf(tz, "" +%04ld"", author.TimeZone);
        }
      else
        {
        sprintf(tz, "" -%04ld"", -author.TimeZone);
        }
      this->Rev.Date += tz;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_659.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 85, 0, 0, 5, 5, 0, 0, 2, 9, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 1, 1, 1, 0, 8, 0, 0, 8, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_659.cpp,19
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,520,-1,"sprintf(tz, "" +%04ld"", author.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_660.cpp,"{
        sprintf(tz, "" +%04ld"", author.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_660.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_660.cpp,28
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,524,-1,"sprintf(tz, "" -%04ld"", -author.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_661.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_661.cpp,"{
        sprintf(tz, "" -%04ld"", -author.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_661.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_661.cpp,32
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,540,-1,"sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_662.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_662.cpp,"{
      Person committer;
      this->ParsePerson(this->Line.c_str()+10, committer);
      this->Rev.Committer = committer.Name;
      this->Rev.CommitterEMail = committer.EMail;

      // Convert the time to a human-readable format that is also easy
      // to machine-parse: ""CCYY-MM-DD hh:mm:ss"".
      time_t seconds = static_cast<time_t>(committer.Time);
      struct tm* t = gmtime(&seconds);
      char dt[1024];
      sprintf(dt, ""%04d-%02d-%02d %02d:%02d:%02d"",
              t->tm_year+1900, t->tm_mon+1, t->tm_mday,
              t->tm_hour, t->tm_min, t->tm_sec);
      this->Rev.CommitDate = dt;

      // Add the time-zone field ""+zone"" or ""-zone"".
      char tz[32];
      if(committer.TimeZone >= 0)
        {
        sprintf(tz, "" +%04ld"", committer.TimeZone);
        }
      else
        {
        sprintf(tz, "" -%04ld"", -committer.TimeZone);
        }
      this->Rev.CommitDate += tz;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_662.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 85, 0, 0, 5, 5, 0, 0, 2, 9, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 32, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 1, 1, 1, 0, 8, 0, 0, 8, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_662.cpp,48
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,549,-1,"sprintf(tz, "" +%04ld"", committer.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_663.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_663.cpp,"{
        sprintf(tz, "" +%04ld"", committer.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_663.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_663.cpp,57
59925264829e5c9509f505897aafd33478e80cfe,"CTest: Factor out duplicate Git author/committer code

Factor out date/time format code into FormatDateTime function instead of
duplicating it.",[],Source/CTest/cmCTestGIT.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_472.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1027.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1027.cpp,503,503,553,-1,"sprintf(tz, "" -%04ld"", -committer.TimeZone);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_664.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_664.cpp,"{
        sprintf(tz, "" -%04ld"", -committer.TimeZone);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_664.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_664.cpp,61
a4a5e375685adcfe765c45be086706720a96dbea,"Use iostream to make Borland happy

It seems as though cstdio doesn't bring in stdio.h with the Borland
compilers.",[],Tests/TestsWorkingDirectory/main.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_473.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_473.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_473.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1028.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1028.cpp,18,19,20,21,"fprintf(stderr, ""No current working directory.\n"");","std::cerr << ""No current working directory."" << std::endl;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_665.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_665.cpp,"{
    fprintf(stderr, ""No current working directory.\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_665.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_665.cpp,5
a4a5e375685adcfe765c45be086706720a96dbea,"Use iostream to make Borland happy

It seems as though cstdio doesn't bring in stdio.h with the Borland
compilers.",[],Tests/TestsWorkingDirectory/main.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_473.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_473.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_473.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1029.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1029.cpp,46,47,48,49,"fprintf(stderr, ""No current working directory\n"");","std::cerr << ""No current working directory"" << std::endl;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_666.cpp,"{
    fprintf(stderr, ""No current working directory\n"");
    abort();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_666.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_666.cpp,5
9bcaff02ff066e9bdd69e3e1e3134aa65c53c121,"Merge branch 'cmake-guiRememberAdvancedCheckbox' into dev/strict-mode

Conflicts:
	Source/QtDialog/CMakeSetupDialog.cxx",[],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_474.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_474.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_474.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1030.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1030.cpp,758,758,763,764,"fprintf(stderr, ""  followed by Component (%d)\n"", *oi);","fprintf(stderr, ""  followed by Component (%d)\n"", i);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_667.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_667.cpp,"{
      fprintf(stderr, ""  followed by Component (%d)\n"", *oi);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_667.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_667.cpp,18
9bcaff02ff066e9bdd69e3e1e3134aa65c53c121,"Merge branch 'cmake-guiRememberAdvancedCheckbox' into dev/strict-mode

Conflicts:
	Source/QtDialog/CMakeSetupDialog.cxx",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_475.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_475.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1031.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1031.cpp,283,291,293,301,"fprintf(stderr, ""  depends on target %d [%s]\n"", dependee_index,
              dependee->GetName());","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_668.cpp,"{
      int dependee_index = *ni;
      cmTarget* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s]\n"", dependee_index,
              dependee->GetName());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_668.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_668.cpp,15
2a5790a080d86c63daf3d2c17d533c919cbef582,"Use std::cout instead of fprintf

Alex",[],Source/cmGraphVizWriter.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_476.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_476.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_476.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1032.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1032.cpp,164,164,166,166,"f(stderr, ""Writing %s...\n"", currentFilename.c_str());","d::cout << ""Writing "" << currentFilename << ""..."" << std::endl;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_669.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_669.cpp,"{
    if (ptrIt->second == NULL)
      {
      continue;
      }

    if (this->GenerateForTargetType(ptrIt->second->GetType()) == false)
      {
      continue;
      }

    std::set<std::string> insertedConnections;
    std::set<std::string> insertedNodes;

    std::string currentFilename = fileName;
    currentFilename += ""."";
    currentFilename += ptrIt->first;
    cmGeneratedFileStream str(currentFilename.c_str());
    if ( !str )
      {
      return;
      }

    fprintf(stderr, ""Writing %s...\n"", currentFilename.c_str());
    this->WriteHeader(str);

    this->WriteConnections(ptrIt->first.c_str(),
                              insertedNodes, insertedConnections, str);
    this->WriteFooter(str);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_669.cpp,"[3, 0, 0, 0, 0, 2, 1, 0, 0, 0, 4, 0, 0, 0, 0, 66, 0, 0, 4, 4, 0, 0, 1, 3, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 3, 3, 0, 0, 12, 0, 0, 6, 0, 13, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_669.cpp,29
487bd571d56134b15b1060e1921a7e16711f12e6,"Properly insert all targets, also those which don't link to anything.

Alex",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_477.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_477.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_477.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1033.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1033.cpp,3094,3069,3099,-1,"fprintf(stderr, "" + %s\n"", realTargetName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_670.cpp,"{
        targetDeps[realTargetName] = DOT_DEP_TARGET;
        fprintf(stderr, "" + %s\n"", realTargetName);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_670.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_670.cpp,32
681cf011dde81c08c0404569289110f9585c6daf,"Distinguish ""strong"" and ""weak"" target dependency edges

Utility dependencies are ""strong"" because they must be enforced to
generate a working build.  Link dependencies are ""weak"" because they can
be broken in the case of a static library cycle.",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_479.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_479.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_479.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1035.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1035.cpp,291,296,293,298,"fprintf(stderr, ""  depends on target %d [%s]\n"", dependee_index,
              dependee->GetName());","fprintf(stderr, ""  depends on target %d [%s] (%s)\n"", dependee_index,
              dependee->GetName(), ni->IsStrong()? ""strong"" : ""weak"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_671.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_671.cpp,"{
      int dependee_index = *ni;
      cmTarget* dependee = this->Targets[dependee_index];
      fprintf(stderr, ""  depends on target %d [%s]\n"", dependee_index,
              dependee->GetName());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_671.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 2, 2, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_671.cpp,15
a61c5ab6e59a458ad34383e64d0679a7fe898c61,"Add CMAKE_TESTS_CDASH_SERVER variable and CTestSubmitLargeOutput test.

If defined and non-empty, the value of CMAKE_TESTS_CDASH_SERVER should point
to a CDash server willing to accept submissions for a project named
PublicDashboard. On machines that also run a CDash dashboard, set this
variable to ""http://localhost/CDash-trunk-Testing"" so that the CMake tests
that submit dashboards do not have to send those submissions over the wire.

The CTestSubmitLargeOutput test runs a dashboard that has a test that produces
very large amount of output on stdout/stderr. Since we do not even want	 to
attempt to send such large output over the wire, this test is off by default
unless the CMAKE_TESTS_CDASH_SERVER server is localhost. This test is expected
to cause a submission failure when sent to CDash. It passes if the submit
results contain error output. It fails if the submit succeeds.

CMAKE_TESTS_CDASH_SERVER: CDash server used by CMake/Tests.

If not defined or """", this variable defaults to the server at
http://www.cdash.org/CDash.

If set explicitly to ""NOTFOUND"", curl tests and ctest tests that use the
network are skipped.

If set to something starting with ""http://localhost/"", the CDash is expected
to be an instance of CDash used for CDash testing, pointing to a
cdash4simpletest database. In these cases, the CDash dashboards should be
run first.",[],Utilities/cmcurl/Testing/curltest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_484.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_484.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_484.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1042.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1042.cpp,98,98,104,104,"printf(""Error fetching: http://www.cmake.org/page1.html\n"");","printf(""Error fetching: %s\n"", url1);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_672.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_672.cpp,"{
      printf(""Error fetching: http://www.cmake.org/page1.html\n"");
      retVal = 1;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_672.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_672.cpp,66
dc1d2189ae922be9d6e7f5fde698532db47e46aa,CMake 2.8.1-rc1,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_486.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_486.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1044.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1044.cpp,2364,2316,2374,-1,"sprintf(tmp,""Version %s"", cmVersion::GetCMakeVersion());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_673.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_673.cpp,"{
#ifdef CMAKE_BUILD_WITH_CMAKE
  // Loop over all registered commands and print out documentation
  const char *name;
  const char *terse;
  const char *full;
  char tmp[1024];
  sprintf(tmp,""Version %s"", cmVersion::GetCMakeVersion());
  f << ""<html>\n"";
  f << ""<h1>Documentation for commands of CMake "" << tmp << ""</h1>\n"";
  f << ""<ul>\n"";
  for(RegisteredCommandsMap::iterator j = this->Commands.begin();
      j != this->Commands.end(); ++j)
    {
    name = (*j).second->GetName();
    terse = (*j).second->GetTerseDocumentation();
    full = (*j).second->GetFullDocumentation();
    f << ""<li><b>"" << name << ""</b> - "" << terse << std::endl
      << ""<br><i>Usage:</i> "" << full << ""</li>"" << std::endl << std::endl;
    }
  f << ""</ul></html>\n"";
#else
  (void)f;
#endif
  return 1;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_673.cpp,"[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 67, 0, 0, 4, 5, 0, 0, 2, 12, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 1, 0, 1, 0, 7, 0, 0, 10, 0, 3, 3, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_673.cpp,8
8ba2a4040484d0aa1be26ad8fde3d7109a7c2fb1,"Fixes for borland, compiles with lots of warnings, but compiles, might fix vs70 again too.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_490.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1050.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1050.cpp,479,479,481,481,"archive_set_error(&a->archive, EILSEQ,
            ""Can't translate pathname '%s' to UTF-8"", path);","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
            ""Can't translate pathname '%s' to UTF-8"", path);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_674.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_674.cpp,"{
        archive_set_error(&a->archive, EILSEQ,
            ""Can't translate pathname '%s' to UTF-8"", path);
        ret = ARCHIVE_WARN;
        hdrcharset = ""BINARY"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_674.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_674.cpp,84
8ba2a4040484d0aa1be26ad8fde3d7109a7c2fb1,"Fixes for borland, compiles with lots of warnings, but compiles, might fix vs70 again too.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_490.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1050.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1050.cpp,479,479,489,489,"archive_set_error(&a->archive, EILSEQ,
            ""Can't translate uname '%s' to UTF-8"", uname);","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
            ""Can't translate uname '%s' to UTF-8"", uname);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_675.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_675.cpp,"{
        archive_set_error(&a->archive, EILSEQ,
            ""Can't translate uname '%s' to UTF-8"", uname);
        ret = ARCHIVE_WARN;
        hdrcharset = ""BINARY"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_675.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_675.cpp,92
8ba2a4040484d0aa1be26ad8fde3d7109a7c2fb1,"Fixes for borland, compiles with lots of warnings, but compiles, might fix vs70 again too.",[],Utilities/cmlibarchive/libarchive/archive_write_set_format_pax.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_490.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_490.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1050.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1050.cpp,479,479,497,497,"archive_set_error(&a->archive, EILSEQ,
            ""Can't translate gname '%s' to UTF-8"", gname);","archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
            ""Can't translate gname '%s' to UTF-8"", gname);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_676.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_676.cpp,"{
        archive_set_error(&a->archive, EILSEQ,
            ""Can't translate gname '%s' to UTF-8"", gname);
        ret = ARCHIVE_WARN;
        hdrcharset = ""BINARY"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_676.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_676.cpp,100
8a690289c205da90133e704439dc6f7ef1a08680,"Add label summary times to ctest default output.  Also, remove parallel time output.  Add flag to disable label summary.",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_495.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_495.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1055.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1055.cpp,589,589,606,-1,"sprintf(totalBuf, ""%6.2f sec"", totalTestTime);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_677.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_677.cpp,"{
    if (this->HandlerVerbose && passed.size() &&
      (this->UseIncludeRegExpFlag || this->UseExcludeRegExpFlag))
      {
      cmCTestLog(this->CTest, HANDLER_VERBOSE_OUTPUT, std::endl
        << ""The following tests passed:"" << std::endl);
      for(std::vector<cmStdString>::iterator j = passed.begin();
          j != passed.end(); ++j)
        {
        cmCTestLog(this->CTest, HANDLER_VERBOSE_OUTPUT, ""\t"" << *j
          << std::endl);
        }
      }

    float percent = float(passed.size()) * 100.0f / total;
    if ( failed.size() > 0 &&  percent > 99)
      {
      percent = 99;
      }
    
    cmCTestLog(this->CTest, HANDLER_OUTPUT, std::endl
               << static_cast<int>(percent + .5) << ""% tests passed, ""
               << failed.size() << "" tests failed out of "" 
               << total << std::endl); 
    double totalTestTime = 0;

    for(cmCTestTestHandler::TestResultsVector::size_type cc = 0;
        cc < this->TestResults.size(); cc ++ )
      {
      cmCTestTestResult *result = &this->TestResults[cc];
      totalTestTime += result->ExecutionTime;
      }
    
    char realBuf[1024];
    sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));
    cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\nTotal Test time (real) = ""
               << realBuf << ""\n"" );

    char totalBuf[1024];
    sprintf(totalBuf, ""%6.2f sec"", totalTestTime); 
    cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\nTotal Test time (parallel) = ""
               <<  totalBuf << ""\n"" );

    if (failed.size())
      {
      cmGeneratedFileStream ofs;
      cmCTestLog(this->CTest, ERROR_MESSAGE, std::endl
                 << ""The following tests FAILED:"" << std::endl);
      this->StartLogFile(""TestsFailed"", ofs);
      
      std::vector<cmCTestTestHandler::cmCTestTestResult>::iterator ftit;
      for(ftit = this->TestResults.begin();
          ftit != this->TestResults.end(); ++ftit)
        {
        if ( ftit->Status != cmCTestTestHandler::COMPLETED )
          {
          ofs << ftit->TestCount << "":"" << ftit->Name << std::endl;
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\t"" << std::setw(3)
                     << ftit->TestCount << "" - "" 
                     << ftit->Name.c_str() << "" (""
                     << this->GetTestStatus(ftit->Status) << "")"" 
                     << std::endl);
          }
        }
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_677.cpp,"[4, 0, 3, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 205, 0, 0, 7, 9, 0, 0, 8, 27, 0, 0, 0, 0, 1, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104, 0, 69, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 3, 0, 7, 4, 0, 0, 29, 0, 0, 13, 0, 37, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_677.cpp,112
177edc5ed1bed7306a122129dfcaf13d898f83ef,Fixed ctest -N segfault issue.  Further refactored ctest.  Enabled failover for ctest,[],Source/CTest/cmCTestRunTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_497.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_497.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_497.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1057.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1057.cpp,67,67,175,174,"sprintf(buf, ""%6.2f sec"", this->TestProcess->GetTotalTime());","sprintf(buf, ""%6.2f sec"", this->TestProcess->GetTotalTime());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_678.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_678.cpp,"{
    std::vector<std::pair<cmsys::RegularExpression,
      std::string> >::iterator passIt;
    bool forceFail = false;
    if ( this->TestProperties->RequiredRegularExpressions.size() > 0 )
      {
      bool found = false;
      for ( passIt = this->TestProperties->RequiredRegularExpressions.begin();
            passIt != this->TestProperties->RequiredRegularExpressions.end();
            ++ passIt )
        {
        if ( passIt->first.find(this->ProcessOutput.c_str()) )
          {
          found = true;
          reason = ""Required regular expression found."";
          }
        }
      if ( !found )
        { 
        reason = ""Required regular expression not found."";
        forceFail = true;
        }
      reason +=  ""Regex=[""; 
      for ( passIt = this->TestProperties->RequiredRegularExpressions.begin();
            passIt != this->TestProperties->RequiredRegularExpressions.end();
            ++ passIt )
        {
        reason += passIt->second;
        reason += ""\n"";
        }
      reason += ""]"";
      }
    if ( this->TestProperties->ErrorRegularExpressions.size() > 0 )
      {
      for ( passIt = this->TestProperties->ErrorRegularExpressions.begin();
            passIt != this->TestProperties->ErrorRegularExpressions.end();
            ++ passIt )
        {
        if ( passIt->first.find(this->ProcessOutput.c_str()) )
          {
          reason = ""Error regular expression found in output."";
          reason += "" Regex=["";
          reason += passIt->second;
          reason += ""]"";
          forceFail = true;
          }
        }
      }
    if (res == cmsysProcess_State_Exited)
      {
      bool success = 
        !forceFail &&  (retVal == 0 || 
        this->TestProperties->RequiredRegularExpressions.size());
      if((success && !this->TestProperties->WillFail) 
        || (!success && this->TestProperties->WillFail))
        {
        this->TestResult.Status = cmCTestTestHandler::COMPLETED;
        cmCTestLog(this->CTest, HANDLER_OUTPUT, ""   Passed  "" );
        }
      else
        {
        this->TestResult.Status = cmCTestTestHandler::FAILED;
        cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Failed  "" << reason );
        }
      }
    else if ( res == cmsysProcess_State_Expired )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Timeout"");
      this->TestResult.Status = cmCTestTestHandler::TIMEOUT;
      }
    else if ( res == cmsysProcess_State_Exception )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Exception: "");
      switch ( retVal )
        {
        case cmsysProcess_Exception_Fault:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""SegFault"");
          this->TestResult.Status = cmCTestTestHandler::SEGFAULT;
          break;
        case cmsysProcess_Exception_Illegal:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Illegal"");
          this->TestResult.Status = cmCTestTestHandler::ILLEGAL;
          break;
        case cmsysProcess_Exception_Interrupt:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Interrupt"");
          this->TestResult.Status = cmCTestTestHandler::INTERRUPT;
          break;
        case cmsysProcess_Exception_Numerical:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Numerical"");
          this->TestResult.Status = cmCTestTestHandler::NUMERICAL;
          break;
        default:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Other"");
          this->TestResult.Status = cmCTestTestHandler::OTHER_FAULT;
        }
      }
    else // if ( res == cmsysProcess_State_Error )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Bad command "" << res );
      this->TestResult.Status = cmCTestTestHandler::BAD_COMMAND;
      }

    passed = this->TestResult.Status == cmCTestTestHandler::COMPLETED;

    char buf[1024];
    sprintf(buf, ""%6.2f sec"", this->TestProcess->GetTotalTime());
    cmCTestLog(this->CTest, HANDLER_OUTPUT, buf << ""\n"" );
    if ( this->TestHandler->LogFile )
      {
      *this->TestHandler->LogFile << ""Test time = "" << buf << std::endl;
      }
    this->DartProcessing();
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_678.cpp,"[10, 0, 3, 0, 4, 0, 0, 1, 4, 1, 17, 0, 0, 0, 0, 288, 0, 0, 5, 5, 0, 0, 6, 30, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 156, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 10, 2, 0, 29, 0, 0, 37, 2, 41, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_678.cpp,118
8ffd8d0a03d68241ce4f5f8a9fd266bee1032e1d,"ENH: refactored ctest.  All testing is now parallel.  If no -j option is specified, defaults to a MP level of 1 (non parallel)",[],Source/CTest/cmCTestRunTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_499.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_499.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_499.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1059.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1059.cpp,273,173,275,175,"sprintf(buf, ""%6.2f sec"", this->TestResult.ExecutionTime);","sprintf(buf, ""%6.2f sec"", this->TestProcess->GetTotalTime());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_679.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_679.cpp,"{
    std::vector<std::pair<cmsys::RegularExpression,
      std::string> >::iterator passIt;
    bool forceFail = false;
    if ( this->TestProperties->RequiredRegularExpressions.size() > 0 )
      {
      bool found = false;
      for ( passIt = this->TestProperties->RequiredRegularExpressions.begin();
            passIt != this->TestProperties->RequiredRegularExpressions.end();
            ++ passIt )
        {
        if ( passIt->first.find(output.c_str()) )
          {
          found = true;
          reason = ""Required regular expression found."";
          }
        }
      if ( !found )
        { 
        reason = ""Required regular expression not found."";
        forceFail = true;
        }
      reason +=  ""Regex=[""; 
      for ( passIt = this->TestProperties->RequiredRegularExpressions.begin();
            passIt != this->TestProperties->RequiredRegularExpressions.end();
            ++ passIt )
        {
        reason += passIt->second;
        reason += ""\n"";
        }
      reason += ""]"";
      }
    if ( this->TestProperties->ErrorRegularExpressions.size() > 0 )
      {
      for ( passIt = this->TestProperties->ErrorRegularExpressions.begin();
            passIt != this->TestProperties->ErrorRegularExpressions.end();
            ++ passIt )
        {
        if ( passIt->first.find(output.c_str()) )
          {
          reason = ""Error regular expression found in output."";
          reason += "" Regex=["";
          reason += passIt->second;
          reason += ""]"";
          forceFail = true;
          }
        }
      }

    if (res == cmsysProcess_State_Exited)
      {
      bool success = 
        !forceFail &&  (retVal == 0 || 
        this->TestProperties->RequiredRegularExpressions.size());
      if((success && !this->TestProperties->WillFail) 
        || (!success && this->TestProperties->WillFail))
        {
        this->TestResult.Status = cmCTestTestHandler::COMPLETED;
        cmCTestLog(this->CTest, HANDLER_OUTPUT,   ""   Passed  "" );
        }
      else
        {
        this->TestResult.Status = cmCTestTestHandler::FAILED;
        cmCTestLog(this->CTest, HANDLER_OUTPUT,
                   ""***Failed  "" << reason );
        }
      }
    else if ( res == cmsysProcess_State_Expired )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Timeout"");
      this->TestResult.Status = cmCTestTestHandler::TIMEOUT;
      }
    else if ( res == cmsysProcess_State_Exception )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Exception: "");
      switch ( retVal )
        {
        case cmsysProcess_Exception_Fault:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""SegFault"");
          this->TestResult.Status = cmCTestTestHandler::SEGFAULT;
          break;
        case cmsysProcess_Exception_Illegal:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Illegal"");
          this->TestResult.Status = cmCTestTestHandler::ILLEGAL;
          break;
        case cmsysProcess_Exception_Interrupt:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Interrupt"");
          this->TestResult.Status = cmCTestTestHandler::INTERRUPT;
          break;
        case cmsysProcess_Exception_Numerical:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Numerical"");
          this->TestResult.Status = cmCTestTestHandler::NUMERICAL;
          break;
        default:
          cmCTestLog(this->CTest, HANDLER_OUTPUT, ""Other"");
          this->TestResult.Status = cmCTestTestHandler::OTHER_FAULT;
        }
      }
    else // if ( res == cmsysProcess_State_Error )
      {
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""***Bad command "" << res );
      this->TestResult.Status = cmCTestTestHandler::BAD_COMMAND;
      }

    passed = this->TestResult.Status == cmCTestTestHandler::COMPLETED;

    char buf[1024];
    sprintf(buf, ""%6.2f sec"", this->TestResult.ExecutionTime);
    cmCTestLog(this->CTest, HANDLER_OUTPUT, buf << ""\n"" );
    if ( this->TestHandler->LogFile )
      {
      *this->TestHandler->LogFile << ""\nTest time = "" << buf << std::endl;
      }
    this->DartProcessing(output);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_679.cpp,"[10, 0, 3, 0, 4, 0, 0, 1, 4, 1, 17, 0, 0, 0, 0, 287, 0, 0, 5, 5, 0, 0, 6, 30, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 154, 0, 107, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 14, 10, 2, 0, 28, 0, 0, 37, 2, 42, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_679.cpp,235
8ffd8d0a03d68241ce4f5f8a9fd266bee1032e1d,"ENH: refactored ctest.  All testing is now parallel.  If no -j option is specified, defaults to a MP level of 1 (non parallel)",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_500.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_500.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_500.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1060.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1060.cpp,591,598,594,606,"sprintf(buf, ""%6.2f sec"", totalTestTime);","sprintf(totalBuf, ""%6.2f sec"", totalTestTime);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_680.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_680.cpp,"{
      cmCTestLog(this->CTest, HANDLER_OUTPUT, std::endl
                 << static_cast<int>(percent + .5) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" 
                 << total << std::endl); 
      double totalTestTime = 0;

      for(cmCTestTestHandler::TestResultsVector::size_type cc = 0;
          cc < this->TestResults.size(); cc ++ )
        {
        cmCTestTestResult *result = &this->TestResults[cc];
        totalTestTime += result->ExecutionTime;
        }
      
      char buf[1024];
      sprintf(buf, ""%6.2f sec"", totalTestTime); 
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\nTotal Test time = "" 
                 <<  buf << ""\n"" );
      
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_680.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 52, 0, 0, 3, 4, 0, 0, 4, 9, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 22, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 0, 0, 0, 7, 0, 0, 4, 0, 11, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_680.cpp,101
8ffd8d0a03d68241ce4f5f8a9fd266bee1032e1d,"ENH: refactored ctest.  All testing is now parallel.  If no -j option is specified, defaults to a MP level of 1 (non parallel)",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_500.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_500.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_500.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1060.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1060.cpp,591,598,594,601,,"sprintf(realBuf, ""%6.2f sec"", (double)(clock_finish - clock_start));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_681.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_681.cpp,"{
      cmCTestLog(this->CTest, HANDLER_OUTPUT, std::endl
                 << static_cast<int>(percent + .5) << ""% tests passed, ""
                 << failed.size() << "" tests failed out of "" 
                 << total << std::endl); 
      double totalTestTime = 0;

      for(cmCTestTestHandler::TestResultsVector::size_type cc = 0;
          cc < this->TestResults.size(); cc ++ )
        {
        cmCTestTestResult *result = &this->TestResults[cc];
        totalTestTime += result->ExecutionTime;
        }
      
      char buf[1024];
      sprintf(buf, ""%6.2f sec"", totalTestTime); 
      cmCTestLog(this->CTest, HANDLER_OUTPUT, ""\nTotal Test time = "" 
                 <<  buf << ""\n"" );
      
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_681.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 52, 0, 0, 3, 4, 0, 0, 4, 9, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 22, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 0, 0, 0, 7, 0, 0, 4, 0, 11, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_681.cpp,101
98c51ff6dcd5e6aa80050cfc00f19eb6092e79c0,"ENH: Overhaul CMake version numbering

This moves the version numbers into an isolated configured header so
that not all of CMake needs to rebuild when the version changes.

Previously we had spaces, dashes and/or the word 'patch' randomly chosen
before the patch number.  Now we always report version numbers in the
traditional format ""<major>.<minor>.<patch>[-rc<rc>]"".

We still use odd minor numbers for development versions.  Now we also
use the CCYYMMDD date as the patch number of development versions, thus
allowing tests for exact CMake versions.",[],Source/WXDialog/CMakeSetupFrame.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_507.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_507.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_507.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1069.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1069.cpp,700,700,702,702,"str.Printf(""CMake %d.%d - %s"", cmVersion::GetMajorVersion(),
               cmVersion::GetMinorVersion(), 
               cmVersion::GetReleaseVersion().c_str());","str.Printf(""CMake %s"", cmVersion::GetCMakeVersion());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_682.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_682.cpp,"{ 
    // path to where cmake.exe is
    // m_PathToExecutable = cm.GetPathToExecutable().c_str();
    m_PathToExecutable = fn;

    // adjust size of last bar, to display % progress
    wxStatusBar *bar = GetStatusBar();
    if(bar)
    {
        wxASSERT(bar->GetFieldsCount() > 1);
        
        // fill all with -1. Why this way? because the count of the status bars
        // can change. All of the widths must be accounted for and initialised
        int *widths = new int[bar->GetFieldsCount()];
        for(int i = 0; i < bar->GetFieldsCount(); i++)
            widths[i] = -1;

        // the % field
        widths[1] = 75;
        bar->SetStatusWidths(bar->GetFieldsCount(), widths);
        delete widths;
    }

    wxString name, generator;
    std::vector<std::string> names;
  
    m_RunningConfigure = false;

    // set grid labels
    m_cmOptions->SetColLabelValue(0, wxT(""Cache Name""));
    m_cmOptions->SetColLabelValue(1, wxT(""Cache Value""));
    m_cmOptions->SetProjectGenerated(false);

    // set drop target
    m_cmOptions->SetDropTarget(new DnDFile(m_cmBuildPath));

    m_cmake->GetRegisteredGenerators(names);
    for(std::vector<std::string>::iterator i = names.begin(); i != names.end(); ++i)
    {
        name = i->c_str();
        m_cmGeneratorChoice->Append(name);
    }
    
    // sync advanced option with grid
    m_cmOptions->SetShowAdvanced(m_cmShowAdvanced->GetValue());

    // if we have a command line query that a generator 
    // needs to be chosen instead of the default, take it
    bool foundGivenGenerator = false;
    if(!cm.m_GeneratorChoiceString.IsEmpty())
    {
        // set proper discovered generator
        foundGivenGenerator = m_cmGeneratorChoice->SetStringSelection(cm.m_GeneratorChoiceString);  
    }

    // if none selected, we will see if VS8, VS7 or VS6 is present
    if(!foundGivenGenerator || m_cmGeneratorChoice->GetValue().IsEmpty())
    {
        std::string mp;
        mp = ""[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\8.0\\Setup;Dbghelp_path]"";
        cmSystemTools::ExpandRegistryValues(mp);
        if(mp != ""/registry"")
            generator = wxT(""Visual Studio 8 2005"");
        else
        {
            mp = ""[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\7.1;InstallDir]"";
            cmSystemTools::ExpandRegistryValues(mp);
            if (mp != ""/registry"")
                generator = wxT(""Visual Studio 7 .NET 2003"");
            else
            {
                mp = ""[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\7.0;InstallDir]"";
                cmSystemTools::ExpandRegistryValues(mp);
                if (mp != ""/registry"")
                    generator = wxT(""Visual Studio 7"");
                else
                    generator = wxT(""Visual Studio 6"");         
            }
        }
    }

    // set proper discovered generator
    m_cmGeneratorChoice->SetStringSelection(generator);
    
    wxString str;
    str.Printf(""CMake %d.%d - %s"", cmVersion::GetMajorVersion(),
               cmVersion::GetMinorVersion(), 
               cmVersion::GetReleaseVersion().c_str());
    str.Printf(""CMakeSetup v%i.%i%s"", CMAKEGUI_MAJORVER, CMAKEGUI_MINORVER, CMAKEGUI_ADDVER);

    SetTitle(str);
    wxString path;
    
    // get last 5 used projects
    for(size_t i = 0; i < CM_MAX_RECENT_PATHS; i++)
    {
        path.Printf(""%s%i"", _(CM_RECENT_BUILD_PATH), i);
        if(m_config->Read(path, &str))
            AppendPathToRecentList(str);
    }

    // get query items
    for(size_t i = 0; i < CM_MAX_SEARCH_QUERIES; i++)
    {
        path.Printf(""%s%i"", _(CM_SEARCH_QUERY), i);
        if(m_config->Read(path, &str))
            m_cmSearchQuery->Append(str);
    }


    // make sure the call to update grid is not executed
    m_noRefresh = true;
    m_cmSearchQuery->SetValue(_(""""));
    m_noRefresh = false;

    // Get the parameters from the command line info
    // If an unknown parameter is found, try to interpret it too, since it
    // is likely to be a file dropped on the shortcut :)
    bool sourceDirLoaded = false,
         buildDirLoaded = false;
    
    if(cm.m_LastUnknownParameter.empty())
    {
        if(cm.m_WhereSource.size() > 0 )
        {
            m_cmProjectPath->SetValue(cm.m_WhereSource.c_str());
            sourceDirLoaded = true;
        }   
    
        if (cm.m_WhereBuild.size() > 0 )
        {
            m_cmBuildPath->SetValue(cm.m_WhereBuild.c_str());
            buildDirLoaded = true;
        }
            
        m_cmShowAdvanced->SetValue(cm.m_AdvancedValues);
    }
    else
    {
        m_cmShowAdvanced->SetValue(false);
        
        // TODO: Interpret directory from dropped shortcut
        //this->ChangeDirectoriesFromFile(cmdInfo->m_LastUnknownParameter.c_str());
    }

    if (cm.m_ExitAfterLoad)
    {
        int id = GetId();
        m_ExitTimer = new wxTimer(this, id);
        m_ExitTimer->Start(3000);

        Connect( id, wxEVT_TIMER,(wxObjectEventFunction) &CMakeSetupFrm::OnExitTimer ); 

    } 

    // retrieve settings, this needs to be done here
    // because writing to the m_cmBuildPath triggers a cache reload
    if(!sourceDirLoaded && m_config->Read(CM_LASTPROJECT_PATH, &str))
        m_cmProjectPath->SetValue(str);

    if(!buildDirLoaded)
    {
        m_cmOptions->RemoveAll();
        if(m_config->Read(CM_LASTBUILD_PATH, &str))
            m_cmBuildPath->SetValue(str);
    }

    // set window size from settings
    long xsize, ysize, splitpos;
    if(m_config->Read(CM_XSIZE, &xsize) && m_config->Read(CM_YSIZE, &ysize) &&
       m_config->Read(CM_SPLITTERPOS, &splitpos))
    {
        SetSize(xsize, ysize);
        m_splitter->SetSashPosition(splitpos);
    }

    if(m_config->Read(CM_XPOS, &xsize) && m_config->Read(CM_YPOS, &ysize))
        SetSize(xsize, ysize, -1, -1, wxSIZE_USE_EXISTING);

    UpdateWindowState();
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_682.cpp,"[17, 0, 4, 0, 0, 0, 0, 0, 0, 0, 26, 0, 0, 0, 0, 345, 0, 0, 11, 19, 0, 0, 14, 41, 0, 0, 0, 0, 2, 0, 77, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 133, 0, 176, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 3, 0, 21, 17, 4, 0, 79, 0, 0, 53, 0, 85, 0, 4, 0, 0, 4, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_682.cpp,86
3043ddf1445de03556564917e01a4f9748b04d89,BUG: #8611 add pass fail reasons into log file,[u'https://gitlab.kitware.com/cmake/cmake/issues/8611'],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_508.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_508.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_508.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1070.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1070.cpp,761,761,770,-1,"sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_683.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_683.cpp,"{
    double ttime = clock_finish - clock_start;
    int hours = static_cast<int>(ttime / (60 * 60));
    int minutes = static_cast<int>(ttime / 60) % 60;
    int seconds = static_cast<int>(ttime) % 60;
    char buffer[100];
    sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);
    *this->LogFile
      << ""----------------------------------------------------------""
      << std::endl
      << ""\"""" << testname.c_str() << ""\"" end time: ""
      << this->CTest->CurrentTime() << std::endl
      << ""\"""" << testname.c_str() << ""\"" time elapsed: ""
      << buffer << std::endl
      << ""----------------------------------------------------------""
      << std::endl << std::endl;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_683.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 53, 0, 0, 5, 5, 0, 0, 4, 13, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 18, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_683.cpp,126
dc13914cd698b49cbae491c1e1aebbcd44fbe932,"ENH: Create cmXMLSafe to help escapes in XML

This class provides easy syntax to efficiently insert blocks of data
into XML documents with proper escapes.  It replaces the old
cmCTest::MakeXMLSafe and cmSystemTools::MakeXMLSafe methods which
allocated extra memory instead of directly streaming the data.",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_509.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_509.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_509.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1071.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1071.cpp,149,150,168,-1,"sprintf(buffer, ""&lt;%d&gt;"", (int)ch);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_684.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_684.cpp,"{
      char buffer[33];
      sprintf(buffer, ""&lt;%d&gt;"", (int)ch);
      //sprintf(buffer, ""&#x%0x;"", (unsigned int)ch);
      result.insert(result.end(), buffer, buffer+strlen(buffer));
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_684.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_684.cpp,12
ae7f2b47b3f94ec023f19474755cc76a2c0c6edc,"COMP: Fix unused yyunput warning in lexer

This adds the ""nounput"" option to the flex input file so that yyunput is
not generated.  The function is static but not used so some compilers
warn.",[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_511.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_511.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_511.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1073.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1073.cpp,1264,1262,1294,-1,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" );",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_685.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_685.cpp,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_685.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_685.cpp,28
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1075.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1075.cpp,565,574,571,580,"sprintf(buf, ""%u"", this->VersionPatch);","sprintf(buf, ""%u"", this->VersionPatch);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_686.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_686.cpp,"{
        sprintf(buf, ""%u"", this->VersionPatch);
        this->Makefile->AddDefinition((ver+""_PATCH"").c_str(), buf);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_686.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_686.cpp,36
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1075.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1075.cpp,565,574,576,578,"sprintf(buf, ""%u"", this->VersionMinor);","sprintf(buf, ""%u"", this->VersionMinor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_687.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_687.cpp,"{
        sprintf(buf, ""%u"", this->VersionMinor);
        this->Makefile->AddDefinition((ver+""_MINOR"").c_str(), buf);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_687.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_687.cpp,41
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1075.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1075.cpp,565,574,581,576,"sprintf(buf, ""%u"", this->VersionMajor);","sprintf(buf, ""%u"", this->VersionMajor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_688.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_688.cpp,"{
        sprintf(buf, ""%u"", this->VersionMajor);
        this->Makefile->AddDefinition((ver+""_MAJOR"").c_str(), buf);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_688.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_688.cpp,46
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1075.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1075.cpp,565,574,588,582,,"sprintf(buf, ""%u"", this->VersionTweak);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_689.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_689.cpp,"{
    // Tell the module that is about to be read what version of the
    // package has been requested.
    std::string ver = this->Name;
    ver += ""_FIND_VERSION"";
    this->Makefile->AddDefinition(ver.c_str(), this->Version.c_str());
    char buf[64];
    switch(this->VersionCount)
      {
      case 3:
        {
        sprintf(buf, ""%u"", this->VersionPatch);
        this->Makefile->AddDefinition((ver+""_PATCH"").c_str(), buf);
        } // no break
      case 2:
        {
        sprintf(buf, ""%u"", this->VersionMinor);
        this->Makefile->AddDefinition((ver+""_MINOR"").c_str(), buf);
        } // no break
      case 1:
        {
        sprintf(buf, ""%u"", this->VersionMajor);
        this->Makefile->AddDefinition((ver+""_MAJOR"").c_str(), buf);
        } // no break
      default: break;
      }

    // Tell the module whether an exact version has been requested.
    std::string exact = this->Name;
    exact += ""_FIND_VERSION_EXACT"";
    this->Makefile->AddDefinition(exact.c_str(),
                                  this->VersionExact? ""1"":""0"");
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_689.cpp,"[0, 0, 0, 0, 1, 0, 0, 1, 3, 1, 5, 0, 0, 0, 0, 79, 0, 0, 3, 3, 0, 0, 2, 14, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 1, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 2, 1, 1, 0, 14, 0, 0, 10, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_689.cpp,53
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1075.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1075.cpp,565,574,588,584,,"sprintf(buf, ""%u"", this->VersionCount);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_690.cpp,"{
    // Tell the module that is about to be read what version of the
    // package has been requested.
    std::string ver = this->Name;
    ver += ""_FIND_VERSION"";
    this->Makefile->AddDefinition(ver.c_str(), this->Version.c_str());
    char buf[64];
    switch(this->VersionCount)
      {
      case 3:
        {
        sprintf(buf, ""%u"", this->VersionPatch);
        this->Makefile->AddDefinition((ver+""_PATCH"").c_str(), buf);
        } // no break
      case 2:
        {
        sprintf(buf, ""%u"", this->VersionMinor);
        this->Makefile->AddDefinition((ver+""_MINOR"").c_str(), buf);
        } // no break
      case 1:
        {
        sprintf(buf, ""%u"", this->VersionMajor);
        this->Makefile->AddDefinition((ver+""_MAJOR"").c_str(), buf);
        } // no break
      default: break;
      }

    // Tell the module whether an exact version has been requested.
    std::string exact = this->Name;
    exact += ""_FIND_VERSION_EXACT"";
    this->Makefile->AddDefinition(exact.c_str(),
                                  this->VersionExact? ""1"":""0"");
   }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_690.cpp,"[0, 0, 0, 0, 1, 0, 0, 1, 3, 1, 5, 0, 0, 0, 0, 79, 0, 0, 3, 3, 0, 0, 2, 14, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 1, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 2, 1, 1, 0, 14, 0, 0, 10, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_690.cpp,53
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1076.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1076.cpp,1234,1234,1239,1241,"sprintf(buf, ""%u"", this->VersionPatch);","sprintf(buf, ""%u"", this->VersionPatch);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_691.cpp,"{
    char buf[64];
    sprintf(buf, ""%u"", this->VersionPatch);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_PATCH"", buf);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_691.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_691.cpp,17
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1076.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1076.cpp,1234,1234,1249,1239,"sprintf(buf, ""%u"", this->VersionMinor);","sprintf(buf, ""%u"", this->VersionMinor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_692.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_692.cpp,"{
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMinor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MINOR"", buf);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_692.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_692.cpp,27
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1076.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1076.cpp,1234,1234,1259,1237,"sprintf(buf, ""%u"", this->VersionMajor);","sprintf(buf, ""%u"", this->VersionMajor);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_693.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_693.cpp,"{
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMajor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MAJOR"", buf);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_693.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_693.cpp,37
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1076.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1076.cpp,1234,1234,1268,1243,,"sprintf(buf, ""%u"", this->VersionTweak);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_694.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_694.cpp,"{
  // The version file will be loaded in an isolated scope.
  this->Makefile->PushScope();

  // Clear the output variables.
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION"");
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION_COMPATIBLE"");
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION_EXACT"");

  // Set the input variables.
  this->Makefile->AddDefinition(""PACKAGE_FIND_NAME"", this->Name.c_str());
  this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION"",
                                this->Version.c_str());
  if(this->VersionCount >= 3)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionPatch);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_PATCH"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_PATCH"");
    }
  if(this->VersionCount >= 2)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMinor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MINOR"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_MINOR"");
    }
  if(this->VersionCount >= 1)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMajor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MAJOR"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_MAJOR"");
    }

  // Load the version check file.
  bool found = false;
  if(this->ReadListFile(version_file.c_str()))
    {
    // Check the output variables.
    found = this->Makefile->IsOn(""PACKAGE_VERSION_EXACT"");
    if(!found && !this->VersionExact)
      {
      found = this->Makefile->IsOn(""PACKAGE_VERSION_COMPATIBLE"");
      }
    if(found || this->Version.empty())
      {
      // Get the version found.
      this->VersionFound =
        this->Makefile->GetSafeDefinition(""PACKAGE_VERSION"");

      // Try to parse the version number and store the results that were
      // successfully parsed.
      unsigned int parsed_major;
      unsigned int parsed_minor;
      unsigned int parsed_patch;
      this->VersionFoundCount =
        sscanf(this->VersionFound.c_str(), ""%u.%u.%u"",
               &parsed_major, &parsed_minor, &parsed_patch);
      switch(this->VersionFoundCount)
        {
        case 3: this->VersionFoundPatch = parsed_patch; // no break!
        case 2: this->VersionFoundMinor = parsed_minor; // no break!
        case 1: this->VersionFoundMajor = parsed_major; // no break!
        default: break;
        }
      }
    }

  // Restore the original scope.
  this->Makefile->PopScope();

  // Succeed if the version was found or no version was requested.
  return found || this->Version.empty();
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_694.cpp,"[6, 0, 0, 0, 1, 0, 1, 1, 3, 1, 11, 0, 0, 0, 0, 170, 0, 0, 7, 7, 0, 0, 1, 28, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 7, 6, 3, 0, 27, 0, 0, 23, 0, 34, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_694.cpp,46
994262e5cc05abfb96da9af38f8d84988405ea5b,"ENH: Improve find_package version numbering

Make the number of version components specified explicitly available.
Set variables for unspecified version components to ""0"" instead of
leaving them unset.  This simplifies version number handling for find-
and config-modules.  Also support a fourth ""tweak"" version component
since some packages use them.",[],Source/cmFindPackageCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_513.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_513.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1076.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1076.cpp,1234,1234,1268,1245,,"sprintf(buf, ""%u"", this->VersionCount);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_695.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_695.cpp,"{
  // The version file will be loaded in an isolated scope.
  this->Makefile->PushScope();

  // Clear the output variables.
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION"");
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION_COMPATIBLE"");
  this->Makefile->RemoveDefinition(""PACKAGE_VERSION_EXACT"");

  // Set the input variables.
  this->Makefile->AddDefinition(""PACKAGE_FIND_NAME"", this->Name.c_str());
  this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION"",
                                this->Version.c_str());
  if(this->VersionCount >= 3)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionPatch);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_PATCH"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_PATCH"");
    }
  if(this->VersionCount >= 2)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMinor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MINOR"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_MINOR"");
    }
  if(this->VersionCount >= 1)
    {
    char buf[64];
    sprintf(buf, ""%u"", this->VersionMajor);
    this->Makefile->AddDefinition(""PACKAGE_FIND_VERSION_MAJOR"", buf);
    }
  else
    {
    this->Makefile->RemoveDefinition(""PACKAGE_FIND_VERSION_MAJOR"");
    }

  // Load the version check file.
  bool found = false;
  if(this->ReadListFile(version_file.c_str()))
    {
    // Check the output variables.
    found = this->Makefile->IsOn(""PACKAGE_VERSION_EXACT"");
    if(!found && !this->VersionExact)
      {
      found = this->Makefile->IsOn(""PACKAGE_VERSION_COMPATIBLE"");
      }
    if(found || this->Version.empty())
      {
      // Get the version found.
      this->VersionFound =
        this->Makefile->GetSafeDefinition(""PACKAGE_VERSION"");

      // Try to parse the version number and store the results that were
      // successfully parsed.
      unsigned int parsed_major;
      unsigned int parsed_minor;
      unsigned int parsed_patch;
      this->VersionFoundCount =
        sscanf(this->VersionFound.c_str(), ""%u.%u.%u"",
               &parsed_major, &parsed_minor, &parsed_patch);
      switch(this->VersionFoundCount)
        {
        case 3: this->VersionFoundPatch = parsed_patch; // no break!
        case 2: this->VersionFoundMinor = parsed_minor; // no break!
        case 1: this->VersionFoundMajor = parsed_major; // no break!
        default: break;
        }
      }
    }

  // Restore the original scope.
  this->Makefile->PopScope();

  // Succeed if the version was found or no version was requested.
  return found || this->Version.empty();
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_695.cpp,"[6, 0, 0, 0, 1, 0, 1, 1, 3, 1, 11, 0, 0, 0, 0, 170, 0, 0, 7, 7, 0, 0, 1, 28, 0, 0, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 3, 0, 7, 6, 3, 0, 27, 0, 0, 23, 0, 34, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_695.cpp,46
816ee0f83cd9775e3b378fe3b074efe06d6b29a6,"ENH: New link line item ordering algorithm

This change introduces a new algorithm for link line construction.  The
order it computes always begins with the exact link line specified by
the user.  Dependencies of items specified by the user are tracked, and
those that are not already satisified by the line are appended to it at
the end with minimal repeats.  This restores the behavior of CMake 2.4
and below while still fixing some of its bugs.  See issue #7546.",[u'https://gitlab.kitware.com/cmake/cmake/issues/7546'],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_514.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1079.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1079.cpp,793,835,796,842,"fprintf(stderr, ""\n"");","fprintf(stderr, ""  topo order index %d\n"",
            this->ComponentOrder[c]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_696.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_696.cpp,"{
  fprintf(stderr, ""The strongly connected components are:\n"");
  std::vector<NodeList> const& components = ccg.GetComponents();
  for(unsigned int c=0; c < components.size(); ++c)
    {
    fprintf(stderr, ""Component (%u):\n"", c);
    NodeList const& nl = components[c];
    for(NodeList::const_iterator ni = nl.begin(); ni != nl.end(); ++ni)
      {
      int i = *ni;
      fprintf(stderr, ""  item %d [%s]\n"", i,
              this->EntryList[i].Item.c_str());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_696.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 54, 0, 0, 3, 5, 0, 0, 7, 5, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 0, 0, 0, 10, 0, 0, 4, 0, 12, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_696.cpp,16
816ee0f83cd9775e3b378fe3b074efe06d6b29a6,"ENH: New link line item ordering algorithm

This change introduces a new algorithm for link line construction.  The
order it computes always begins with the exact link line specified by
the user.  Dependencies of items specified by the user are tracked, and
those that are not already satisified by the line are appended to it at
the end with minimal repeats.  This restores the behavior of CMake 2.4
and below while still fixing some of its bugs.  See issue #7546.",[u'https://gitlab.kitware.com/cmake/cmake/issues/7546'],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_514.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1079.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1079.cpp,793,835,798,840,,"fprintf(stderr, ""  followed by Component (%d)\n"", *oi);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_697.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_697.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_697.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_697.cpp,0
816ee0f83cd9775e3b378fe3b074efe06d6b29a6,"ENH: New link line item ordering algorithm

This change introduces a new algorithm for link line construction.  The
order it computes always begins with the exact link line specified by
the user.  Dependencies of items specified by the user are tracked, and
those that are not already satisified by the line are appended to it at
the end with minimal repeats.  This restores the behavior of CMake 2.4
and below while still fixing some of its bugs.  See issue #7546.",[u'https://gitlab.kitware.com/cmake/cmake/issues/7546'],Source/cmComputeLinkDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_514.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_514.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1079.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1079.cpp,793,835,801,845,,"f(stderr, ""\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_698.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_698.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_698.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_698.cpp,0
68dfcefbcb755018ddadfa8bf132114a1b3fa28c,"COMP: sprintf warnings. DWORD should use %ld rather than %d. Also, const char *p, a shadowed variable warning.",[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1081.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1081.cpp,4279,4279,4281,4281,"sprintf(buffer, ""%d"", osvi.dwMajorVersion);","sprintf(buffer, ""%ld"", osvi.dwMajorVersion);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_699.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_699.cpp,"{
        HKEY hKey;
        #define BUFSIZE 80
        char szProductType[BUFSIZE];
        DWORD dwBufLen=BUFSIZE;
        LONG lRet;

        lRet = RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          ""SYSTEM\\CurrentControlSet\\Control\\ProductOptions"",
          0, KEY_QUERY_VALUE, &hKey);
        if (lRet != ERROR_SUCCESS)
          {
          return 0;
          }

        lRet = RegQueryValueEx(hKey, ""ProductType"", NULL, NULL,
                               (LPBYTE) szProductType, &dwBufLen);

        if ((lRet != ERROR_SUCCESS) || (dwBufLen > BUFSIZE))
          {
          return 0;
          }

        RegCloseKey(hKey);

        if (lstrcmpi(""WINNT"", szProductType) == 0)
          {
          res += "" Workstation"";
          }
        if (lstrcmpi(""LANMANNT"", szProductType) == 0)
          {
          res += "" Server"";
          }
        if (lstrcmpi(""SERVERNT"", szProductType) == 0)
          {
          res += "" Advanced Server"";
          }

        res += "" "";
        sprintf(buffer, ""%d"", osvi.dwMajorVersion);
        res += buffer;
        res += ""."";
        sprintf(buffer, ""%d"", osvi.dwMinorVersion);
        res += buffer;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_699.cpp,"[5, 0, 0, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0, 0, 0, 58, 0, 0, 4, 4, 0, 0, 1, 18, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 5, 5, 0, 0, 8, 0, 0, 12, 0, 24, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_699.cpp,175
68dfcefbcb755018ddadfa8bf132114a1b3fa28c,"COMP: sprintf warnings. DWORD should use %ld rather than %d. Also, const char *p, a shadowed variable warning.",[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1081.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1081.cpp,4279,4279,4284,4284,"sprintf(buffer, ""%d"", osvi.dwMinorVersion);","sprintf(buffer, ""%ld"", osvi.dwMinorVersion);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_700.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_700.cpp,"{
        HKEY hKey;
        #define BUFSIZE 80
        char szProductType[BUFSIZE];
        DWORD dwBufLen=BUFSIZE;
        LONG lRet;

        lRet = RegOpenKeyEx(
          HKEY_LOCAL_MACHINE,
          ""SYSTEM\\CurrentControlSet\\Control\\ProductOptions"",
          0, KEY_QUERY_VALUE, &hKey);
        if (lRet != ERROR_SUCCESS)
          {
          return 0;
          }

        lRet = RegQueryValueEx(hKey, ""ProductType"", NULL, NULL,
                               (LPBYTE) szProductType, &dwBufLen);

        if ((lRet != ERROR_SUCCESS) || (dwBufLen > BUFSIZE))
          {
          return 0;
          }

        RegCloseKey(hKey);

        if (lstrcmpi(""WINNT"", szProductType) == 0)
          {
          res += "" Workstation"";
          }
        if (lstrcmpi(""LANMANNT"", szProductType) == 0)
          {
          res += "" Server"";
          }
        if (lstrcmpi(""SERVERNT"", szProductType) == 0)
          {
          res += "" Advanced Server"";
          }

        res += "" "";
        sprintf(buffer, ""%d"", osvi.dwMajorVersion);
        res += buffer;
        res += ""."";
        sprintf(buffer, ""%d"", osvi.dwMinorVersion);
        res += buffer;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_700.cpp,"[5, 0, 0, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0, 0, 0, 58, 0, 0, 4, 4, 0, 0, 1, 18, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 26, 0, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 5, 5, 0, 0, 8, 0, 0, 12, 0, 24, 1, 0, 1, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_700.cpp,178
68dfcefbcb755018ddadfa8bf132114a1b3fa28c,"COMP: sprintf warnings. DWORD should use %ld rather than %d. Also, const char *p, a shadowed variable warning.",[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1082.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1082.cpp,4304,4304,4306,4306,"sprintf(buffer, ""%d"", osvi.dwBuildNumber & 0xFFFF);","sprintf(buffer, ""%ld"", osvi.dwBuildNumber & 0xFFFF);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_701.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_701.cpp,"{
          res += "" Service Pack 6a (Build "";
          sprintf(buffer, ""%d"", osvi.dwBuildNumber & 0xFFFF);
          res += buffer;
          res += "")"";
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_701.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 4, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_701.cpp,200
68dfcefbcb755018ddadfa8bf132114a1b3fa28c,"COMP: sprintf warnings. DWORD should use %ld rather than %d. Also, const char *p, a shadowed variable warning.",[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_516.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_516.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1083.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1083.cpp,4313,4313,4315,4315,"sprintf(buffer, ""%d"", osvi.dwBuildNumber & 0xFFFF);","sprintf(buffer, ""%ld"", osvi.dwBuildNumber & 0xFFFF);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_702.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_702.cpp,"{
          res += "" "";
          res += osvi.szCSDVersion;
          res += "" (Build "";
          sprintf(buffer, ""%d"", osvi.dwBuildNumber & 0xFFFF);
          res += buffer;
          res += "")"";
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_702.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 6, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_702.cpp,209
5233b75a777b0f3379408291e6f32b0eb15c2f54,"ENH: Improve handling of old-style compatibility.

  - Remove CMP_0001 (no slash in target name) and restore
    old CMAKE_BACKWARDS_COMPATIBILITY check for it
  - Replace all checks of CMAKE_BACKWARDS_COMPATIBILITY
    with cmLocalGenerator::NeedBackwardsCompatibility calls
  - Create new CMP_0001 to determine whether or not
    CMAKE_BACKWARDS_COMPATIBILITY is used.
    (old = use, new = ignore)
  - Show CMAKE_BACKWARDS_COMPATIBILITY in cache only when
    CMP_0001 is set to OLD or WARN
  - Update documentation of cmake_policy and cmake_minimum_required
    to indicate their relationship and the 2.4 version boundary
  - When no cmake policy version is set in top level makefile
    implicitly call cmake_policy(VERSION 2.4) which restores
    CMAKE_BACKWARDS_COMPATIBILITY and other 2.4 compatibility
  - Fix tests MakeClean and Preprocess to call
    cmake_policy(VERSION 2.6) because they depend on new policies",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_518.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_518.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_518.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1087.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1087.cpp,1899,1899,1905,-1,"sprintf(ver,""%i.%i"",cmVersion::GetMajorVersion(),
            cmVersion::GetMinorVersion());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_703.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_703.cpp,"{
    char ver[256];
    sprintf(ver,""%i.%i"",cmVersion::GetMajorVersion(),
            cmVersion::GetMinorVersion());
    this->CacheManager->AddCacheEntry
      (""CMAKE_BACKWARDS_COMPATIBILITY"",ver, 
       ""For backwards compatibility, what version of CMake commands and ""
       ""syntax should this version of CMake allow."",
       cmCacheManager::INTERNAL);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_703.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 1, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_703.cpp,29
cd4d2acbe654ca57a9ffc7ca34dcf4835bfc77c3,ENH: more policy changes,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_519.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_519.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_519.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1088.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1088.cpp,1899,1899,1905,-1,"sprintf(ver,""%i.%i"",cmVersion::GetMajorVersion(),
            cmVersion::GetMinorVersion());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_704.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_704.cpp,"{
    char ver[256];
    sprintf(ver,""%i.%i"",cmVersion::GetMajorVersion(),
            cmVersion::GetMinorVersion());
    this->CacheManager->AddCacheEntry
      (""CMAKE_BACKWARDS_COMPATIBILITY"",ver, 
       ""For backwards compatibility, what version of CMake commands and ""
       ""syntax should this version of CMake allow."",
       cmCacheManager::STRING);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_704.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 1, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_704.cpp,29
4987e17f46cb2542106ee2d9afe2752ef78d0f1f,"ENH: Improve link line generation for static library cycles.

  - Move Tarjan algorithm from cmComputeTargetDepends
    into its own class cmComputeComponentGraph
  - Use cmComputeComponentGraph to identify the component DAG
    of link dependencies in cmComputeLinkDepends
  - Emit non-trivial component members more than once but always
    in a contiguous group on the link line",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_520.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_520.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_520.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1090.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1090.cpp,295,292,396,-1,"fprintf(stderr, ""The strongly connected components are:\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_705.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_705.cpp,"{
  fprintf(stderr, ""The strongly connected components are:\n"");
  int n = static_cast<int>(this->Components.size());
  for(int c = 0; c < n; ++c)
    {
    ComponentList const& cl = this->Components[c];
    fprintf(stderr, ""Component (%d):\n"", c);
    for(ComponentList::const_iterator ci = cl.begin();
        ci != cl.end(); ++ci)
      {
      int i = *ci;
      fprintf(stderr, ""  contains target %d [%s]\n"",
              i, this->Targets[i]->GetName());
      }
    }
  fprintf(stderr, ""\n"");
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_705.cpp,"[0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 1, 48, 0, 0, 3, 5, 0, 0, 7, 5, 0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 28, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 2, 0, 2, 0, 0, 0, 10, 0, 0, 4, 0, 13, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_705.cpp,2
4987e17f46cb2542106ee2d9afe2752ef78d0f1f,"ENH: Improve link line generation for static library cycles.

  - Move Tarjan algorithm from cmComputeTargetDepends
    into its own class cmComputeComponentGraph
  - Use cmComputeComponentGraph to identify the component DAG
    of link dependencies in cmComputeLinkDepends
  - Emit non-trivial component members more than once but always
    in a contiguous group on the link line",[],Source/cmComputeTargetDepends.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_520.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_520.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_520.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1090.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1090.cpp,295,292,297,298,,"fprintf(stderr, ""The strongly connected components are:\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_706.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_706.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_706.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_706.cpp,0
433099ecddb334cc6e43c6302594d7c713ef4d1e,ENH: Converted cmMakefile DefineFlags added by ADD_DEFINITIONS command into a COMPILE_DEFINITIONS directory property.,[],Tests/Preprocess/preprocess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_522.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_522.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_522.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1092.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1092.cpp,82,94,86,98,,"fprintf(stderr, ""DIRECTORY_DEF_DEBUG should be defined in C\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_707.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_707.cpp,"{
  fprintf(stderr, ""FILE_DEF_RELEASE should not be defined in C\n"");
  result = 0;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_707.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_707.cpp,78
433099ecddb334cc6e43c6302594d7c713ef4d1e,ENH: Converted cmMakefile DefineFlags added by ADD_DEFINITIONS command into a COMPILE_DEFINITIONS directory property.,[],Tests/Preprocess/preprocess.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_523.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_523.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_523.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1093.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1093.cpp,84,96,88,100,,"fprintf(stderr, ""DIRECTORY_DEF_DEBUG should be defined in CXX\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_708.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_708.cpp,"{
  fprintf(stderr, ""FILE_DEF_RELEASE should not be defined in CXX\n"");
  result = 0;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_708.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_708.cpp,78
50c5d5a3d5b6edc32baf3f6102368aae535262e0,ENH: fix leaks and turn on by default,[],Source/kwsys/SystemInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_524.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1094.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1094.cpp,171,172,176,177,"sprintf(temp,""%d"",this->ChipID.Type);",str << this->ChipID.Type;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_709.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_709.cpp,"{
  char * temp = new char[32];
  sprintf(temp,""%d"",this->ChipID.Type);
  return temp;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_709.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_709.cpp,3
50c5d5a3d5b6edc32baf3f6102368aae535262e0,ENH: fix leaks and turn on by default,[],Source/kwsys/SystemInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_524.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1094.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1094.cpp,171,172,184,185,"sprintf(temp,""%d"",this->ChipID.Family);",str << this->ChipID.Family;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_710.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_710.cpp,"{
  char * temp = new char[32];
  sprintf(temp,""%d"",this->ChipID.Family);
  return temp;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_710.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_710.cpp,3
50c5d5a3d5b6edc32baf3f6102368aae535262e0,ENH: fix leaks and turn on by default,[],Source/kwsys/SystemInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_524.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1094.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1094.cpp,171,172,192,193,"sprintf(temp,""%d"",this->ChipID.Model);",str << this->ChipID.Model;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_711.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_711.cpp,"{
  char * temp = new char[32];
  sprintf(temp,""%d"",this->ChipID.Model);
  return temp;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_711.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_711.cpp,3
50c5d5a3d5b6edc32baf3f6102368aae535262e0,ENH: fix leaks and turn on by default,[],Source/kwsys/SystemInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_524.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_524.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1094.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1094.cpp,171,172,200,201,"sprintf(temp,""%d"",this->ChipID.Revision);",str << this->ChipID.Revision;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_712.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_712.cpp,"{
  char * temp = new char[32];
  sprintf(temp,""%d"",this->ChipID.Revision);
  return temp;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_712.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_712.cpp,3
a65193857293f065139bc991488d0cef9a199c16,ENH: fix the compile and add install rule,[],Source/WXDialog/CMakeSetupFrame.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_526.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_526.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_526.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1096.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1096.cpp,699,700,701,702,,"str.Printf(""CMake %d.%d - %s"", cmVersion::GetMajorVersion(),
               cmVersion::GetMinorVersion(), 
               cmVersion::GetReleaseVersion().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_713.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_713.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_713.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_713.cpp,0
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1105.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1105.cpp,528,606,534,612,"(void)vsprintf(buf, format, va);","(void)vsprintf(buf, format, va);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_714.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_714.cpp,"{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_714.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 3, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 24, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 1, 0, 7, 0, 0, 5, 0, 15, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_714.cpp,10
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1105.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1105.cpp,528,606,537,617,,"len = vsprintf(buf, format, va);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_715.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_715.cpp,"{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_715.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 3, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 24, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 1, 0, 7, 0, 0, 5, 0, 15, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_715.cpp,13
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1105.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1105.cpp,528,606,542,626,,"len = vsnprintf(buf, sizeof(buf), format, va);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_716.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_716.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_716.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_716.cpp,0
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1106.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1106.cpp,552,644,558,649,"sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);","sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_717.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_717.cpp,"{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_717.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 62, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 57, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 5, 0, 0, 3, 0, 50, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_717.cpp,558
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1106.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1106.cpp,552,644,561,654,,"len = sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
                a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_718.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_718.cpp,"{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_718.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 62, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 57, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 1, 0, 5, 0, 0, 3, 0, 50, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_718.cpp,561
3edcd70754afe7c6b2ff71e0010c6b3d64b4fe37,ENH: Update zlib to 1.2.3. Addresses bugs #5445 and #3473.,"[u'https://gitlab.kitware.com/cmake/cmake/issues/5445', u'https://gitlab.kitware.com/cmake/cmake/issues/3473']",Utilities/cmzlib/gzio.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_529.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_529.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1106.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1106.cpp,552,644,566,663,,"len = snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
                 a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_719.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_719.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_719.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_719.cpp,0
9c2d6f98d7e0fd42bcf2ec78fbd66190c6dc439e,"ENH: apply patch from Mathieu which creates a deb file (not finishsed yet)

Alex",[],Source/CPack/cmCPackGenerators.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_530.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_530.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_530.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1107.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1107.cpp,90,90,92,-1,"fprintf(stderr, ""********* NewGen %s\n"", name);",,3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_720.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_720.cpp,"{
  cmCPackGenericGenerator* gen = this->NewGeneratorInternal(name);
  fprintf(stderr, ""********* NewGen %s\n"", name);
  if ( !gen )
    {
    return 0;
    }
  this->Generators.push_back(gen);
  gen->SetLogger(this->Logger);
  return gen;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_720.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 22, 0, 0, 1, 1, 0, 0, 1, 2, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_720.cpp,3
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,55,54,,"fprintf(ofp, ""#if defined(_WIN32)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_721.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_721.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_721.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_721.cpp,0
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,55,,"fprintf(ofp, ""# include <io.h>\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_722.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_722.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_722.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,56,,"fprintf(ofp, ""#else\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_723.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_723.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_723.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_723.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,57,,"fprintf(ofp, ""# include <unistd.h>\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_724.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_724.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_724.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_724.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,58,,"fprintf(ofp, ""#endif\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_725.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_725.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_725.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_725.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,59,,"fprintf(ofp, ""\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_726.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_726.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_726.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_726.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,60,,"fprintf(ofp, ""static void kwsys_unlink(const char* fname)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_727.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_727.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_727.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_727.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,61,,"fprintf(ofp, ""{\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_728.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_728.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_728.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_728.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,62,,"fprintf(ofp, ""#if defined(__WATCOMC__)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_729.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_729.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_729.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_729.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,63,,"fprintf(ofp, ""  unlink(fname);\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_730.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_730.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_730.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_730.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,64,,"fprintf(ofp, ""#else\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_731.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_731.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_731.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_731.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,65,,"fprintf(ofp, ""  _unlink(fname);\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_732.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_732.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_732.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_732.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,66,,"fprintf(ofp, ""#endif\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_733.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_733.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_733.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_733.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,67,,"fprintf(ofp, ""}\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_734.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_734.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_734.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_734.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1111.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1111.cpp,52,52,56,68,,"fprintf(ofp, ""\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_735.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_735.cpp,"e((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_735.cpp,"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 26, 0, 0, 0, 0, 0, 0, 1, 14, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 1, 0, 6, 0, 0, 5, 0, 16, 0, 1, 0, 1, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_735.cpp,39
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1112.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1112.cpp,78,93,80,-1,"fprintf(ofp, ""#ifdef __WATCOMC__\n"");",,3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_736.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_736.cpp,"{
  FILE* ifp;
  FILE* ofp;
  int i;
  int n;
  int count = 0;
  unsigned char buffer[1024];
  
  /* Check arguments.  */
  if(argc != 5)
    {
    fprintf(stderr, ""Usage: %s <input> <output> <kwsys-name> <array>\n"",
            argv[0]);
    return 1;
    }
  
  /* Open the input file.  */
  ifp = fopen(argv[1], ""rb"");
  if(!ifp)
    {
    fprintf(stderr, ""Cannot open input file: \""%s\""\n"", argv[1]);
    return 2;
    }
  ofp = fopen(argv[2], ""w"");
  if(!ofp)
    {
    fprintf(stderr, ""Cannot open output file: \""%s\""\n"", argv[2]);
    return 2;
    }
  
  /* Prepend header comment.  */
  fprintf(ofp, ""/*\n * DO NOT EDIT\n * This file is generated by:\n"");
  fprintf(ofp, "" * %s\n */\n\n"", argv[0]);
  fprintf(ofp, ""#include \""kwsysPrivate.h\""\n"");
  fprintf(ofp, ""#include KWSYS_HEADER(Configure.h)\n\n"");
  fprintf(ofp, ""#include <stdio.h>\n\n"");
  
  /* Split file up in 1024-byte chunks.  */
  while((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }
  fclose(ifp);
  
  /* Provide a function to write the data to a file.  */
  fprintf(ofp, ""extern %s_EXPORT int %sEncodedWriteArray%s(const char* fname)\n"",
          argv[3], argv[3], argv[4]);
  fprintf(ofp, ""{\n"");
  fprintf(ofp, ""#ifdef __WATCOMC__\n"");
  fprintf(ofp, ""#define _unlink unlink\n"");
  fprintf(ofp, ""#endif\n"");
  fprintf(ofp, ""  FILE* ofp = fopen(fname, \""wb\"");\n"");
  fprintf(ofp, ""  if(!ofp) { return 0; }\n"");
  for(i=0; i < count; ++i)
    {
    fprintf(ofp, ""  if(fwrite(kwsysEncodedArray%s_%d, 1,\n""
                 ""            sizeof(kwsysEncodedArray%s_%d), ofp) !=\n""
                 ""       sizeof(kwsysEncodedArray%s_%d))\n"",
            argv[4], i, argv[4], i, argv[4], i);
    fprintf(ofp, ""    {\n"");
    fprintf(ofp, ""    fclose(ofp);\n"");
    fprintf(ofp, ""    _unlink(fname);\n"");
    fprintf(ofp, ""    return 0;\n"");
    fprintf(ofp, ""    }\n"");
    }
  fprintf(ofp, ""  fclose(ofp);\n"");
  fprintf(ofp, ""  return 1;\n"");
  fprintf(ofp, ""}\n"");
  fclose(ofp);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_736.cpp,"[4, 1, 2, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 0, 134, 0, 0, 6, 6, 0, 0, 3, 62, 0, 0, 0, 0, 2, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 16, 0, 7, 4, 1, 0, 34, 0, 0, 33, 0, 86, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_736.cpp,63
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1112.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1112.cpp,78,93,81,-1,"fprintf(ofp, ""#define _unlink unlink\n"");",,3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_737.cpp,"{
  FILE* ifp;
  FILE* ofp;
  int i;
  int n;
  int count = 0;
  unsigned char buffer[1024];
  
  /* Check arguments.  */
  if(argc != 5)
    {
    fprintf(stderr, ""Usage: %s <input> <output> <kwsys-name> <array>\n"",
            argv[0]);
    return 1;
    }
  
  /* Open the input file.  */
  ifp = fopen(argv[1], ""rb"");
  if(!ifp)
    {
    fprintf(stderr, ""Cannot open input file: \""%s\""\n"", argv[1]);
    return 2;
    }
  ofp = fopen(argv[2], ""w"");
  if(!ofp)
    {
    fprintf(stderr, ""Cannot open output file: \""%s\""\n"", argv[2]);
    return 2;
    }
  
  /* Prepend header comment.  */
  fprintf(ofp, ""/*\n * DO NOT EDIT\n * This file is generated by:\n"");
  fprintf(ofp, "" * %s\n */\n\n"", argv[0]);
  fprintf(ofp, ""#include \""kwsysPrivate.h\""\n"");
  fprintf(ofp, ""#include KWSYS_HEADER(Configure.h)\n\n"");
  fprintf(ofp, ""#include <stdio.h>\n\n"");
  
  /* Split file up in 1024-byte chunks.  */
  while((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }
  fclose(ifp);
  
  /* Provide a function to write the data to a file.  */
  fprintf(ofp, ""extern %s_EXPORT int %sEncodedWriteArray%s(const char* fname)\n"",
          argv[3], argv[3], argv[4]);
  fprintf(ofp, ""{\n"");
  fprintf(ofp, ""#ifdef __WATCOMC__\n"");
  fprintf(ofp, ""#define _unlink unlink\n"");
  fprintf(ofp, ""#endif\n"");
  fprintf(ofp, ""  FILE* ofp = fopen(fname, \""wb\"");\n"");
  fprintf(ofp, ""  if(!ofp) { return 0; }\n"");
  for(i=0; i < count; ++i)
    {
    fprintf(ofp, ""  if(fwrite(kwsysEncodedArray%s_%d, 1,\n""
                 ""            sizeof(kwsysEncodedArray%s_%d), ofp) !=\n""
                 ""       sizeof(kwsysEncodedArray%s_%d))\n"",
            argv[4], i, argv[4], i, argv[4], i);
    fprintf(ofp, ""    {\n"");
    fprintf(ofp, ""    fclose(ofp);\n"");
    fprintf(ofp, ""    _unlink(fname);\n"");
    fprintf(ofp, ""    return 0;\n"");
    fprintf(ofp, ""    }\n"");
    }
  fprintf(ofp, ""  fclose(ofp);\n"");
  fprintf(ofp, ""  return 1;\n"");
  fprintf(ofp, ""}\n"");
  fclose(ofp);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_737.cpp,"[4, 1, 2, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 0, 134, 0, 0, 6, 6, 0, 0, 3, 62, 0, 0, 0, 0, 2, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 16, 0, 7, 4, 1, 0, 34, 0, 0, 33, 0, 86, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_737.cpp,64
d75bfedab59d325b72d575beac8844290de0c279,COMP: Need to include header for unlink function.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_534.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_534.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1112.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1112.cpp,78,93,82,-1,"fprintf(ofp, ""#endif\n"");",,3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_738.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_738.cpp,"{
  FILE* ifp;
  FILE* ofp;
  int i;
  int n;
  int count = 0;
  unsigned char buffer[1024];
  
  /* Check arguments.  */
  if(argc != 5)
    {
    fprintf(stderr, ""Usage: %s <input> <output> <kwsys-name> <array>\n"",
            argv[0]);
    return 1;
    }
  
  /* Open the input file.  */
  ifp = fopen(argv[1], ""rb"");
  if(!ifp)
    {
    fprintf(stderr, ""Cannot open input file: \""%s\""\n"", argv[1]);
    return 2;
    }
  ofp = fopen(argv[2], ""w"");
  if(!ofp)
    {
    fprintf(stderr, ""Cannot open output file: \""%s\""\n"", argv[2]);
    return 2;
    }
  
  /* Prepend header comment.  */
  fprintf(ofp, ""/*\n * DO NOT EDIT\n * This file is generated by:\n"");
  fprintf(ofp, "" * %s\n */\n\n"", argv[0]);
  fprintf(ofp, ""#include \""kwsysPrivate.h\""\n"");
  fprintf(ofp, ""#include KWSYS_HEADER(Configure.h)\n\n"");
  fprintf(ofp, ""#include <stdio.h>\n\n"");
  
  /* Split file up in 1024-byte chunks.  */
  while((n = (int)fread(buffer, 1, 1024, ifp)) > 0)
    {
    fprintf(ofp, ""static unsigned char kwsysEncodedArray%s_%d[%d] = {\n"", 
            argv[4], count++, n);
    for(i=0; i < n-1; ++i)
      {
      fprintf(ofp, ""0x%02X"", buffer[i]);
      if(i%10 == 9)
        {
        fprintf(ofp, "",\n"");
        }
      else
        {
        fprintf(ofp, "", "");
        }
      }
    fprintf(ofp, ""0x%02X};\n\n"", buffer[n-1]);
    }
  fclose(ifp);
  
  /* Provide a function to write the data to a file.  */
  fprintf(ofp, ""extern %s_EXPORT int %sEncodedWriteArray%s(const char* fname)\n"",
          argv[3], argv[3], argv[4]);
  fprintf(ofp, ""{\n"");
  fprintf(ofp, ""#ifdef __WATCOMC__\n"");
  fprintf(ofp, ""#define _unlink unlink\n"");
  fprintf(ofp, ""#endif\n"");
  fprintf(ofp, ""  FILE* ofp = fopen(fname, \""wb\"");\n"");
  fprintf(ofp, ""  if(!ofp) { return 0; }\n"");
  for(i=0; i < count; ++i)
    {
    fprintf(ofp, ""  if(fwrite(kwsysEncodedArray%s_%d, 1,\n""
                 ""            sizeof(kwsysEncodedArray%s_%d), ofp) !=\n""
                 ""       sizeof(kwsysEncodedArray%s_%d))\n"",
            argv[4], i, argv[4], i, argv[4], i);
    fprintf(ofp, ""    {\n"");
    fprintf(ofp, ""    fclose(ofp);\n"");
    fprintf(ofp, ""    _unlink(fname);\n"");
    fprintf(ofp, ""    return 0;\n"");
    fprintf(ofp, ""    }\n"");
    }
  fprintf(ofp, ""  fclose(ofp);\n"");
  fprintf(ofp, ""  return 1;\n"");
  fprintf(ofp, ""}\n"");
  fclose(ofp);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_738.cpp,"[4, 1, 2, 0, 0, 0, 4, 0, 0, 0, 9, 0, 0, 0, 0, 134, 0, 0, 6, 6, 0, 0, 3, 62, 0, 0, 0, 0, 2, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 151, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 16, 0, 7, 4, 1, 0, 34, 0, 0, 33, 0, 86, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_738.cpp,65
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_535.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1113.cpp,205,256,212,272,"fprintf(stdout, ""%s"",   base64);","fprintf(stdout, ""%s\n"", base64);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_739.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_739.cpp,"{
  char *base64;
  size_t base64Len;
  unsigned char *data;
  int dataLen;

  data = (unsigned char *)suck(&dataLen);
  base64Len = Curl_base64_encode(data, dataLen, &base64);

  fprintf(stderr, ""%d\n"", base64Len);
  fprintf(stdout, ""%s"",   base64);

  free(base64); free(data);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_739.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 29, 0, 0, 4, 4, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 6, 0, 12, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_739.cpp,11
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_535.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1113.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1113.cpp,205,256,214,264,,"fprintf(stderr, ""Error: curl_easy_init failed\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_740.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_740.cpp,"{
  char *base64;
  size_t base64Len;
  unsigned char *data;
  int dataLen;

  data = (unsigned char *)suck(&dataLen);
  base64Len = Curl_base64_encode(data, dataLen, &base64);

  fprintf(stderr, ""%d\n"", base64Len);
  fprintf(stdout, ""%s"",   base64);

  free(base64); free(data);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_740.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 29, 0, 0, 4, 4, 0, 0, 0, 3, 0, 0, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 6, 0, 12, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_740.cpp,13
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_535.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_535.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1114.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1114.cpp,235,298,242,304,,"fprintf(stderr, ""Error: curl_easy_init failed\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_741.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_741.cpp,"{
  char *base64;
  int base64Len;
  unsigned char *data;
  int dataLen;
  int i, j;

  base64 = (char *)suck(&base64Len);
  data = (unsigned char *)malloc(base64Len * 3/4 + 8);
  dataLen = Curl_base64_decode(base64, data);

  fprintf(stderr, ""%d\n"", dataLen);

  for(i=0; i < dataLen; i+=0x10) {
    printf(""0x%02x: "", i);
    for(j=0; j < 0x10; j++)
      if((j+i) < dataLen)
        printf(""%02x "", data[i+j]);
      else
        printf(""   "");

    printf("" | "");

    for(j=0; j < 0x10; j++)
      if((j+i) < dataLen)
        printf(""%c"", isgraph(data[i+j])?data[i+j]:'.');
      else
        break;
    puts("""");
  }

  free(base64); free(data);
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_741.cpp,"[2, 0, 3, 0, 1, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 68, 0, 0, 5, 6, 0, 0, 3, 18, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 1, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0, 6, 3, 3, 0, 13, 0, 0, 12, 0, 19, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_741.cpp,12
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/cookie.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_537.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1116.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1116.cpp,839,957,848,-1,"fprintf(out,
              ""%s%s\t"" /* domain */
              ""%s\t"" /* tailmatch */
              ""%s\t"" /* path */
              ""%s\t"" /* secure */
              ""%u\t"" /* expires */
              ""%s\t"" /* name */
              ""%s\n"", /* value */

              /* Make sure all domains are prefixed with a dot if they allow
                 tailmatching. This is Mozilla-style. */
              (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
              co->domain?co->domain:""unknown"",
              co->tailmatch?""TRUE"":""FALSE"",
              co->path?co->path:""/"",
              co->secure?""TRUE"":""FALSE"",
              (unsigned int)co->expires,
              co->name,
              co->value?co->value:"""");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_742.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_742.cpp,"fprintf(out,
              ""%s%s\t"" /* domain */
              ""%s\t"" /* tailmatch */
              ""%s\t"" /* path */
              ""%s\t"" /* secure */
              ""%u\t"" /* expires */
              ""%s\t"" /* name */
              ""%s\n"", /* value */

              /* Make sure all domains are prefixed with a dot if they allow
                 tailmatching. This is Mozilla-style. */
              (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
              co->domain?co->domain:""unknown"",
              co->tailmatch?""TRUE"":""FALSE"",
              co->path?co->path:""/"",
              co->secure?""TRUE"":""FALSE"",
              (unsigned int)co->expires,
              co->name,
              co->value?co->value:"""")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_742.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_742.cpp,30
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/cookie.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_537.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1116.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1116.cpp,839,957,840,970,,"fprintf(out, ""#\n# Fatal libcurl error\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_743.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_743.cpp,"f(c) {
    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://www.netscape.com/newsref/std/cookie_spec.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      fprintf(out,
              ""%s%s\t"" /* domain */
              ""%s\t"" /* tailmatch */
              ""%s\t"" /* path */
              ""%s\t"" /* secure */
              ""%u\t"" /* expires */
              ""%s\t"" /* name */
              ""%s\n"", /* value */

              /* Make sure all domains are prefixed with a dot if they allow
                 tailmatching. This is Mozilla-style. */
              (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
              co->domain?co->domain:""unknown"",
              co->tailmatch?""TRUE"":""FALSE"",
              co->path?co->path:""/"",
              co->secure?""TRUE"":""FALSE"",
              (unsigned int)co->expires,
              co->name,
              co->value?co->value:"""")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_743.cpp,"[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 2, 0, 13, 0, 0, 0, 2, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_743.cpp,22
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/cookie.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_537.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_537.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1116.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1116.cpp,839,957,840,973,,(out;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_744.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_744.cpp,"f(c) {
    fputs(""# Netscape HTTP Cookie File\n""
          ""# http://www.netscape.com/newsref/std/cookie_spec.html\n""
          ""# This file was generated by libcurl! Edit at your own risk.\n\n"",
          out);
    co = c->cookies;

    while(co) {
      fprintf(out,
              ""%s%s\t"" /* domain */
              ""%s\t"" /* tailmatch */
              ""%s\t"" /* path */
              ""%s\t"" /* secure */
              ""%u\t"" /* expires */
              ""%s\t"" /* name */
              ""%s\n"", /* value */

              /* Make sure all domains are prefixed with a dot if they allow
                 tailmatching. This is Mozilla-style. */
              (co->tailmatch && co->domain && co->domain[0] != '.')? ""."":"""",
              co->domain?co->domain:""unknown"",
              co->tailmatch?""TRUE"":""FALSE"",
              co->path?co->path:""/"",
              co->secure?""TRUE"":""FALSE"",
              (unsigned int)co->expires,
              co->name,
              co->value?co->value:"""")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_744.cpp,"[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 2, 0, 13, 0, 0, 0, 2, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_744.cpp,22
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/hostip4.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_541.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_541.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_541.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1120.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1120.cpp,125,101,163,-1,"snprintf((char*)(h->h_name), 16, ""%s"", hostname);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_745.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_745.cpp,"{
  Curl_addrinfo *ai;
  struct hostent *h;
  struct in_addr *addrentry;
  struct namebuf buffer;
  struct namebuf *buf = &buffer;

  h = &buf->hostentry;
  h->h_addr_list = &buf->h_addr_list[0];
  addrentry = &buf->addrentry;
  addrentry->s_addr = num;
  h->h_addr_list[0] = (char*)addrentry;
  h->h_addr_list[1] = NULL;
  h->h_addrtype = AF_INET;
  h->h_length = sizeof(*addrentry);
  h->h_name = &buf->h_name[0];
  h->h_aliases = NULL;

  /* Now store the dotted version of the address */
  snprintf((char*)(h->h_name), 16, ""%s"", hostname);

  ai = Curl_he2ai(h, port);

  return ai;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_745.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 75, 0, 0, 5, 5, 0, 0, 1, 6, 0, 0, 0, 0, 4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 25, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 4, 0, 0, 0, 0, 0, 3, 0, 0, 12, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_745.cpp,20
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1122.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1122.cpp,145,150,152,157,"*userp = aprintf( ""%sAuthorization: Basic %s\015\012"",
                      proxy?""Proxy-"":"""",
                      authorization);","*userp = aprintf( ""%sAuthorization: Basic %s\r\n"",
                      proxy?""Proxy-"":"""",
                      authorization);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_746.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_746.cpp,"{
    if(*userp)
      free(*userp);
    *userp = aprintf( ""%sAuthorization: Basic %s\015\012"",
                      proxy?""Proxy-"":"""",
                      authorization);
    free(authorization);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_746.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 1, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_746.cpp,25
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1123.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1123.cpp,895,1093,969,1167,,"host = aprintf(""Host: %s\r\n"", host_port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_747.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_747.cpp,"{
    if(conn->newurl) {
      /* This only happens if we've looped here due to authentication reasons,
         and we don't really use the newly cloned URL here then. Just free()
         it. */
      free(conn->newurl);
      conn->newurl = NULL;
    }

    host_port = aprintf(""%s:%d"", hostname, remote_port);
    if(!host_port)
      return CURLE_OUT_OF_MEMORY;

    /* Setup the proxy-authorization header, if any */
    result = Curl_http_output_auth(conn, (char *)""CONNECT"", host_port, TRUE);
    if(CURLE_OK == result) {

      /* OK, now send the connect request to the proxy */
      result =
        Curl_sendf(tunnelsocket, conn,
                   ""CONNECT %s:%d HTTP/1.0\015\012""
                   ""%s""
                   ""%s""
                   ""\r\n"",
                   hostname, remote_port,
                   conn->bits.proxy_user_passwd?
                   conn->allocptr.proxyuserpwd:"""",
                   data->set.useragent?conn->allocptr.uagent:""""
                   );
      if(result)
        failf(data, ""Failed sending CONNECT to proxy"");
    }
    free(host_port);
    if(result)
      return result;

    FD_ZERO (&readfd);          /* clear it */
    FD_SET (tunnelsocket, &readfd);     /* read socket */

    /* get this in a backup variable to be able to restore it on each lap in
       the select() loop */
    rkeepfd = readfd;

    ptr=data->state.buffer;
    line_start = ptr;

    nread=0;
    perline=0;

    while((nread<BUFSIZE) && (keepon && !error)) {
      readfd = rkeepfd;     /* set every lap */
      interval.tv_sec = 1;  /* timeout each second and check the timeout */
      interval.tv_usec = 0;

      if(data->set.timeout) {
        /* if timeout is requested, find out how much remaining time we have */
        timeout = data->set.timeout - /* timeout time */
          Curl_tvdiff(Curl_tvnow(), conn->now)/1000; /* spent time */
        if(timeout <=0 ) {
          failf(data, ""Proxy connection aborted due to timeout"");
          error = SELECT_TIMEOUT; /* already too little time */
          break;
        }
      }

      switch (select (tunnelsocket+1, &readfd, NULL, NULL, &interval)) {
      case -1: /* select() error, stop reading */
        error = SELECT_ERROR;
        failf(data, ""Proxy CONNECT aborted due to select() error"");
        break;
      case 0: /* timeout */
        break;
      default:
        /*
         * This code previously didn't use the kerberos sec_read() code
         * to read, but when we use Curl_read() it may do so. Do confirm
         * that this is still ok and then remove this comment!
         */
        res= Curl_read(conn, tunnelsocket, ptr, BUFSIZE-nread, &gotbytes);
        if(res< 0)
          /* EWOULDBLOCK */
          continue; /* go loop yourself */
        else if(res)
          keepon = FALSE;
        else if(gotbytes <= 0) {
          keepon = FALSE;
          error = SELECT_ERROR;
          failf(data, ""Proxy CONNECT aborted"");
        }
        else {
          /*
           * We got a whole chunk of data, which can be anything from one byte
           * to a set of lines and possibly just a piece of the last line.
           *
           * TODO: To make this code work less error-prone, we need to make
           * sure that we read and create full lines before we compare them,
           * as there is really nothing that stops the proxy from delivering
           * the response lines in multiple parts, each part consisting of
           * only a little piece of the line(s).  */
          int i;

          nread += gotbytes;
          for(i = 0; i < gotbytes; ptr++, i++) {
            perline++; /* amount of bytes in this line so far */
            if(*ptr=='\n') {
              char letter;
              int writetype;

              /* output debug output if that is requested */
              if(data->set.verbose)
                Curl_debug(data, CURLINFO_HEADER_IN, line_start, perline,
                           conn->host.dispname);

              /* send the header to the callback */
              writetype = CLIENTWRITE_HEADER;
              if(data->set.include_header)
                writetype |= CLIENTWRITE_BODY;

              result = Curl_client_write(data, writetype, line_start, perline);
              if(result)
                return result;

              /* Newlines are CRLF, so the CR is ignored as the line isn't
                 really terminated until the LF comes. Treat a following CR
                 as end-of-headers as well.*/

              if(('\r' == line_start[0]) ||
                 ('\n' == line_start[0])) {
                /* end of response-headers from the proxy */
                keepon=FALSE;
                break; /* breaks out of for-loop, not switch() */
              }

              /* keep a backup of the position we are about to blank */
              letter = line_start[perline];
              line_start[perline]=0; /* zero terminate the buffer */
              if((checkprefix(""WWW-Authenticate:"", line_start) &&
                  (401 == k->httpcode)) ||
                 (checkprefix(""Proxy-authenticate:"", line_start) &&
                  (407 == k->httpcode))) {
                result = Curl_http_input_auth(conn, k->httpcode, line_start);
                if(result)
                  return result;
              }
              else if(2 == sscanf(line_start, ""HTTP/1.%d %d"",
                                  &subversion,
                                  &k->httpcode)) {
                /* store the HTTP code from the proxy */
                data->info.httpproxycode = k->httpcode;
              }
              /* put back the letter we blanked out before */
              line_start[perline]= letter;

              perline=0; /* line starts over here */
              line_start = ptr+1; /* this skips the zero byte we wrote */
            }
          }
        }
        break;
      } /* switch */
    } /* while there's buffer left and loop is requested */

    if(error)
      return CURLE_RECV_ERROR;

    if(data->info.httpproxycode != 200)
      /* Deal with the possibly already received authenticate
         headers. 'newurl' is set to a new URL if we must loop. */
      Curl_http_auth_act(conn);

  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_747.cpp,"[20, 1, 1, 0, 5, 1, 5, 1, 2, 1, 25, 0, 0, 0, 0, 234, 0, 0, 3, 3, 0, 0, 1, 39, 0, 0, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 2, 146, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 25, 22, 3, 0, 22, 0, 0, 42, 3, 60, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_747.cpp,67
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1124.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1124.cpp,1300,1710,1319,1724,"conn->allocptr.ref = aprintf(""Referer: %s\015\012"", data->change.referer);","conn->allocptr.ref = aprintf(""Referer: %s\r\n"", data->change.referer);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_748.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_748.cpp,"conn->allocptr.ref = aprintf(""Referer: %s\015\012"", data->change.referer)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_748.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_748.cpp,92
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1124.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1124.cpp,1300,1710,1352,1735,,"(""Accept-Encoding: %s\r\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_749.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_749.cpp,"{
  struct SessionHandle *data=conn->data;
  char *buf = data->state.buffer; /* this is a short cut to the buffer */
  CURLcode result;
  struct HTTP *http;
  char *ppath = conn->path;
  char *host = conn->host.name;
  const char *te = """"; /* tranfer-encoding */
  char *ptr;
  char *request;
  Curl_HttpReq httpreq = data->set.httpreq;
  char *addcookies = NULL;

  if(!conn->proto.http) {
    /* Only allocate this struct if we don't already have it! */

    http = (struct HTTP *)malloc(sizeof(struct HTTP));
    if(!http)
      return CURLE_OUT_OF_MEMORY;
    memset(http, 0, sizeof(struct HTTP));
    conn->proto.http = http;
  }
  else
    http = conn->proto.http;

  /* We default to persistant connections */
  conn->bits.close = FALSE;

  if ( (conn->protocol&(PROT_HTTP|PROT_FTP)) &&
       data->set.upload) {
    httpreq = HTTPREQ_PUT;
  }

  /* Now set the 'request' pointer to the proper request string */
  if(data->set.customrequest)
    request = data->set.customrequest;
  else {
    if(conn->bits.no_body)
      request = (char *)""HEAD"";
    else {
      curlassert((httpreq > HTTPREQ_NONE) && (httpreq < HTTPREQ_LAST));
      switch(httpreq) {
      case HTTPREQ_POST:
      case HTTPREQ_POST_FORM:
        request = (char *)""POST"";
        break;
      case HTTPREQ_PUT:
        request = (char *)""PUT"";
        break;
      default: /* this should never happen */
      case HTTPREQ_GET:
        request = (char *)""GET"";
        break;
      case HTTPREQ_HEAD:
        request = (char *)""HEAD"";
        break;
      }
    }
  }

  /* The User-Agent string might have been allocated in url.c already, because
     it might have been used in the proxy connect, but if we have got a header
     with the user-agent string specified, we erase the previously made string
     here. */
  if(checkheaders(data, ""User-Agent:"") && conn->allocptr.uagent) {
    free(conn->allocptr.uagent);
    conn->allocptr.uagent=NULL;
  }

  /* setup the authentication headers */
  result = Curl_http_output_auth(conn, request, ppath, FALSE);
  if(result)
    return result;

  if((!data->state.authhost.done || !data->state.authproxy.done ) &&
     (httpreq != HTTPREQ_GET)) {
    /* Until we are authenticated, we switch over to HEAD. Unless its a GET
       we want to do. The explanation for this is rather long and boring, but
       the point is that it can't be done otherwise without risking having to
       send the POST or PUT data multiple times. */
    httpreq = HTTPREQ_HEAD;
    request = (char *)""HEAD"";
    conn->bits.no_body = TRUE;
    conn->bits.authprobe = TRUE; /* this is a request done to probe for
                                    authentication methods */
  }
  else
    conn->bits.authprobe = FALSE;

  Curl_safefree(conn->allocptr.ref);
  if(data->change.referer && !checkheaders(data, ""Referer:""))
    conn->allocptr.ref = aprintf(""Referer: %s\015\012"", data->change.referer);
  else
    conn->allocptr.ref = NULL;

  if(data->set.cookie && !checkheaders(data, ""Cookie:""))
    addcookies = data->set.cookie;

  if(!conn->bits.upload_chunky && (httpreq != HTTPREQ_GET)) {
    /* not a chunky transfer yet, but data is to be sent */
    ptr = checkheaders(data, ""Transfer-Encoding:"");
    if(ptr) {
      /* Some kind of TE is requested, check if 'chunked' is chosen */
      conn->bits.upload_chunky =
        Curl_compareheader(ptr, ""Transfer-Encoding:"", ""chunked"");
      te = """";
    }
  }
  else if(conn->bits.upload_chunky) {
    /* RFC2616 section 4.4:
       Messages MUST NOT include both a Content-Length header field and a
       non-identity transfer-coding. If the message does include a non-
       identity transfer-coding, the Content-Length MUST be ignored. */

    if(!checkheaders(data, ""Transfer-Encoding:"")) {
      te = ""Transfer-Encoding: chunked\r\n"";
    }
    else {
      te = """";
      conn->bits.upload_chunky = FALSE; /* transfer-encoding was disabled,
                                           so don't chunkify this! */
    }
  }

  Curl_safefree(conn->allocptr.host);

  ptr = checkheaders(data, ""Host:"");
  if(ptr && !data->state.this_is_a_follow) {
    /* If we have a given custom Host: header, we extract the host name in
       order to possibly use it for cookie reasons later on. We only allow the
       custom Host: header if this is NOT a redirect, as setting Host: in the
       redirected request is being out on thin ice. */
    char *start = ptr+strlen(""Host:"");
    while(*start && isspace((int)*start ))
      start++;
    ptr = start; /* start host-scanning here */

    /* scan through the string to find the end (space or colon) */
    while(*ptr && !isspace((int)*ptr) && !(':'==*ptr))
      ptr++;

    if(ptr != start) {
      size_t len=ptr-start;
      conn->allocptr.cookiehost = malloc(len+1);
      if(!conn->allocptr.cookiehost)
        return CURLE_OUT_OF_MEMORY;
      memcpy(conn->allocptr.cookiehost, start, len);
      conn->allocptr.cookiehost[len]=0;
    }

    conn->allocptr.host = NULL;
  }
  else {
    /* When building Host: headers, we must put the host name within
       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */

    if(((conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTPS)) ||
       (!(conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTP)) )
      /* If (HTTPS on port 443) OR (non-HTTPS on port 80) then don't include
         the port number in the host string */
      conn->allocptr.host = aprintf(""Host: %s%s%s\r\n"",
                                    conn->bits.ipv6_ip?""["":"""",
                                    host,
                                    conn->bits.ipv6_ip?""]"":"""");
    else
      conn->allocptr.host = aprintf(""Host: %s%s%s:%d\r\n"",
                                    conn->bits.ipv6_ip?""["":"""",
                                    host,
                                    conn->bits.ipv6_ip?""]"":"""",
                                    conn->remote_port);

    if(!conn->allocptr.host)
      /* without Host: we can't make a nice request */
      return CURLE_OUT_OF_MEMORY;
  }

  if (conn->bits.httpproxy && !conn->bits.tunnel_proxy)  {
    /* Using a proxy but does not tunnel through it */

    /* The path sent to the proxy is in fact the entire URL. But if the remote
       host is a IDN-name, we must make sure that the request we produce only
       uses the encoded host name! */
    if(conn->host.dispname != conn->host.name) {
      char *url = data->change.url;
      char *iPtr = strstr(url, conn->host.dispname);
      if(iPtr) {
        /* This is where the display name starts in the URL, now replace this
           part with the encoded name. TODO: This method of replacing the host
           name is rather crude as I believe there's a slight risk that the
           user has entered a user name or password that contain the host name
           string. */
        size_t currlen = strlen(conn->host.dispname);
        size_t newlen = strlen(conn->host.name);
        size_t urllen = strlen(url);

        char *newurl;

        newurl = malloc(urllen + newlen - currlen + 1);
        if(newurl) {
          /* copy the part before the host name */
          memcpy(newurl, url, iPtr - url);
          /* append the new host name instead of the old */
          memcpy(newurl + (iPtr - url), conn->host.name, newlen);
          /* append the piece after the host name */
          memcpy(newurl + newlen + (iPtr - url),
                 iPtr + currlen, /* copy the trailing zero byte too */
                 urllen - (iPtr-url) - currlen + 1);
          if(data->change.url_alloc)
            free(data->change.url);
          data->change.url = newurl;
          data->change.url_alloc = TRUE;
        }
        else
          return CURLE_OUT_OF_MEMORY;
      }
    }
    ppath = data->change.url;
  }
  if(HTTPREQ_POST_FORM == httpreq) {
    /* we must build the whole darned post sequence first, so that we have
       a size of the whole shebang before we start to send it */
     result = Curl_getFormData(&http->sendit, data->set.httppost,
                               &http->postsize);
     if(CURLE_OK != result) {
       /* Curl_getFormData() doesn't use failf() */
       failf(data, ""failed creating formpost data"");
       return result;
     }
  }


  if(!checkheaders(data, ""Pragma:""))
    http->p_pragma = ""Pragma: no-cache\r\n"";

  if(!checkheaders(data, ""Accept:""))
    http->p_accept = ""Accept: */*\r\n"";

  if(( (HTTPREQ_POST == httpreq) ||
       (HTTPREQ_POST_FORM == httpreq) ||
       (HTTPREQ_PUT == httpreq) ) &&
     conn->resume_from) {
    /**********************************************************************
     * Resuming upload in HTTP means that we PUT or POST and that we have
     * got a resume_from value set. The resume value has already created
     * a Range: header that will be passed along. We need to ""fast forward""
     * the file the given number of bytes and decrease the assume upload
     * file size before we continue this venture in the dark lands of HTTP.
     *********************************************************************/

    if(conn->resume_from < 0 ) {
      /*
       * This is meant to get the size of the present remote-file by itself.
       * We don't support this now. Bail out!
       */
       conn->resume_from = 0;
    }

    if(conn->resume_from) {
      /* do we still game? */
      curl_off_t passed=0;

      /* Now, let's read off the proper amount of bytes from the
         input. If we knew it was a proper file we could've just
         fseek()ed but we only have a stream here */
      do {
        size_t readthisamountnow = (size_t)(conn->resume_from - passed);
        size_t actuallyread;

        if(readthisamountnow > BUFSIZE)
          readthisamountnow = BUFSIZE;

        actuallyread =
          data->set.fread(data->state.buffer, 1, (size_t)readthisamountnow,
                          data->set.in);

        passed += actuallyread;
        if(actuallyread != readthisamountnow) {
          failf(data, ""Could only read %"" FORMAT_OFF_T
                "" bytes from the input"",
                passed);
          return CURLE_READ_ERROR;
        }
      } while(passed != conn->resume_from); /* loop until done */

      /* now, decrease the size of the read */
      if(data->set.infilesize>0) {
        data->set.infilesize -= conn->resume_from;

        if(data->set.infilesize <= 0) {
          failf(data, ""File already completely uploaded"");
          return CURLE_PARTIAL_FILE;
        }
      }
      /* we've passed, proceed as normal */
    }
  }
  if(conn->bits.use_range) {
    /*
     * A range is selected. We use different headers whether we're downloading
     * or uploading and we always let customized headers override our internal
     * ones if any such are specified.
     */
    if((httpreq == HTTPREQ_GET) &&
       !checkheaders(data, ""Range:"")) {
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"", conn->range);
    }
    else if((httpreq != HTTPREQ_GET) &&
            !checkheaders(data, ""Content-Range:"")) {

      if(conn->resume_from) {
        /* This is because ""resume"" was selected */
        curl_off_t total_expected_size=
          conn->resume_from + data->set.infilesize;
        conn->allocptr.rangeline =
            aprintf(""Content-Range: bytes %s%"" FORMAT_OFF_T
                    ""/%"" FORMAT_OFF_T ""\r\n"",
                    conn->range, total_expected_size-1,
                    total_expected_size);
      }
      else {
        /* Range was selected and then we just pass the incoming range and
           append total size */
        conn->allocptr.rangeline =
            aprintf(""Content-Range: bytes %s/%"" FORMAT_OFF_T ""\r\n"",
                    conn->range, data->set.infilesize);
      }
    }
  }

  {
    /* Use 1.1 unless the use specificly asked for 1.0 */
    const char *httpstring=
      data->set.httpversion==CURL_HTTP_VERSION_1_0?""1.0"":""1.1"";

    send_buffer *req_buffer;
    struct curl_slist *headers=data->set.headers;
    curl_off_t postsize; /* off_t type to be able to hold a large file size */

    /* initialize a dynamic send-buffer */
    req_buffer = add_buffer_init();

    if(!req_buffer)
      return CURLE_OUT_OF_MEMORY;

    /* add the main request stuff */
    result =
      add_bufferf(req_buffer,
                  ""%s "" /* GET/HEAD/POST/PUT */
                  ""%s HTTP/%s\r\n"" /* path + HTTP version */
                  ""%s"" /* proxyuserpwd */
                  ""%s"" /* userpwd */
                  ""%s"" /* range */
                  ""%s"" /* user agent */
                  ""%s"" /* host */
                  ""%s"" /* pragma */
                  ""%s"" /* accept */
                  ""%s"" /* accept-encoding */
                  ""%s"" /* referer */
                  ""%s"",/* transfer-encoding */

                request,
                ppath,
                httpstring,
                conn->allocptr.proxyuserpwd?
                conn->allocptr.proxyuserpwd:"""",
                conn->allocptr.userpwd?conn->allocptr.userpwd:"""",
                (conn->bits.use_range && conn->allocptr.rangeline)?
                conn->allocptr.rangeline:"""",
                (data->set.useragent && *data->set.useragent && conn->allocptr.uagent)?
                conn->allocptr.uagent:"""",
                (conn->allocptr.host?conn->allocptr.host:""""), /* Host: host */
                http->p_pragma?http->p_pragma:"""",
                http->p_accept?http->p_accept:"""",
                (data->set.encoding && *data->set.encoding && conn->allocptr.accept_encoding)?
                conn->allocptr.accept_encoding:"""",
                (data->change.referer && conn->allocptr.ref)?conn->allocptr.ref:"""" /* Referer: <data> */,
                te
                );

    if(result)
      return result;

    if(data->cookies || addcookies) {
      struct Cookie *co=NULL; /* no cookies from start */
      int count=0;

      if(data->cookies) {
        Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
        co = Curl_cookie_getlist(data->cookies,
                                 conn->allocptr.cookiehost?
                                 conn->allocptr.cookiehost:host, ppath,
                                 (bool)(conn->protocol&PROT_HTTPS?TRUE:FALSE));
        Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
      }
      if(co) {
        struct Cookie *store=co;
        /* now loop through all cookies that matched */
        while(co) {
          if(co->value) {
            if(0 == count) {
              result = add_bufferf(req_buffer, ""Cookie: "");
              if(result)
                break;
            }
            result = add_bufferf(req_buffer,
                                 ""%s%s=%s"", count?""; "":"""",
                                 co->name, co->value);
            if(result)
              break;
            count++;
          }
          co = co->next; /* next cookie please */
        }
        Curl_cookie_freelist(store); /* free the cookie list */
      }
      if(addcookies && (CURLE_OK == result)) {
        if(!count)
          result = add_bufferf(req_buffer, ""Cookie: "");
        if(CURLE_OK == result) {
          result = add_bufferf(req_buffer, ""%s%s"",
                               count?""; "":"""",
                               addcookies);
          count++;
        }
      }
      if(count && (CURLE_OK == result))
        result = add_buffer(req_buffer, ""\r\n"", 2);

      if(result)
        return result;
    }

    if(data->set.timecondition) {
      struct tm *thistime;

      /* Phil Karn (Fri, 13 Apr 2001) pointed out that the If-Modified-Since
       * header family should have their times set in GMT as RFC2616 defines:
       * ""All HTTP date/time stamps MUST be represented in Greenwich Mean Time
       * (GMT), without exception. For the purposes of HTTP, GMT is exactly
       * equal to UTC (Coordinated Universal Time)."" (see page 20 of RFC2616).
       */

#ifdef HAVE_GMTIME_R
      /* thread-safe version */
      struct tm keeptime;
      thistime = (struct tm *)gmtime_r(&data->set.timevalue, &keeptime);
#else
      thistime = gmtime(&data->set.timevalue);
#endif

#ifdef HAVE_STRFTIME
      /* format: ""Tue, 15 Nov 1994 12:45:26 GMT"" */
      strftime(buf, BUFSIZE-1, ""%a, %d %b %Y %H:%M:%S GMT"", thistime);
#else
      /* TODO: Right, we *could* write a replacement here */
      strcpy(buf, ""no strftime() support"");
#endif
      switch(data->set.timecondition) {
      case CURL_TIMECOND_IFMODSINCE:
      default:
        result = add_bufferf(req_buffer,
                             ""If-Modified-Since: %s\r\n"", buf);
        break;
      case CURL_TIMECOND_IFUNMODSINCE:
        result = add_bufferf(req_buffer,
                             ""If-Unmodified-Since: %s\r\n"", buf);
        break;
      case CURL_TIMECOND_LASTMOD:
        result = add_bufferf(req_buffer,
                             ""Last-Modified: %s\r\n"", buf);
        break;
      }
      if(result)
        return result;
    }

    while(headers) {
      ptr = strchr(headers->data, ':');
      if(ptr) {
        /* we require a colon for this to be a true header */

        ptr++; /* pass the colon */
        while(*ptr && isspace((int)*ptr))
          ptr++;

        if(*ptr) {
          /* only send this if the contents was non-blank */

          result = add_bufferf(req_buffer, ""%s\r\n"", headers->data);
          if(result)
            return result;
        }
      }
      headers = headers->next;
    }

    http->postdata = NULL;  /* nothing to post at this point */
    Curl_pgrsSetUploadSize(data, 0); /* upload size is 0 atm */

    /* If 'authdone' is FALSE, we must not set the write socket index to the
       Curl_transfer() call below, as we're not ready to actually upload any
       data yet. */

    switch(httpreq) {

    case HTTPREQ_POST_FORM:
      if(Curl_FormInit(&http->form, http->sendit)) {
        failf(data, ""Internal HTTP POST error!"");
        return CURLE_HTTP_POST_ERROR;
      }

      /* set the read function to read from the generated form data */
      conn->fread = (curl_read_callback)Curl_FormReader;
      conn->fread_in = &http->form;

      http->sending = HTTPSEND_BODY;

      if(!conn->bits.upload_chunky) {
        /* only add Content-Length if not uploading chunked */
        result = add_bufferf(req_buffer,
                             ""Content-Length: %"" FORMAT_OFF_T ""\r\n"",
                             http->postsize);
        if(result)
          return result;
      }

      if(!checkheaders(data, ""Expect:"")) {
        /* if not disabled explicitly we add a Expect: 100-continue
           to the headers which actually speeds up post operations (as
           there is one packet coming back from the web server) */
        result = add_bufferf(req_buffer,
                             ""Expect: 100-continue\r\n"");
        if(result)
          return result;
        data->set.expect100header = TRUE;
      }

      if(!checkheaders(data, ""Content-Type:"")) {
        /* Get Content-Type: line from Curl_formpostheader.

           The Content-Type header line also contains the MIME boundary
           string etc why disabling this header is likely to not make things
           work, but we support disabling it anyway.
        */
        char *contentType;
        size_t linelength=0;
        contentType = Curl_formpostheader((void *)&http->form,
                                          &linelength);
        if(!contentType) {
          failf(data, ""Could not get Content-Type header line!"");
          return CURLE_HTTP_POST_ERROR;
        }
        result = add_buffer(req_buffer, contentType, linelength);
        if(result)
          return result;
      }

      /* make the request end in a true CRLF */
      result = add_buffer(req_buffer, ""\r\n"", 2);
      if(result)
        return result;

      /* set upload size to the progress meter */
      Curl_pgrsSetUploadSize(data, http->postsize);

      /* fire away the whole request to the server */
      result = add_buffer_send(req_buffer, conn,
                               &data->info.request_size);
      if(result)
        failf(data, ""Failed sending POST request"");
      else
        /* setup variables for the upcoming transfer */
        result = Curl_Transfer(conn, FIRSTSOCKET, -1, TRUE,
                               &http->readbytecount,
                               FIRSTSOCKET,
                               &http->writebytecount);
      if(result) {
        Curl_formclean(http->sendit); /* free that whole lot */
        return result;
      }
      break;

    case HTTPREQ_PUT: /* Let's PUT the data to the server! */

      if((data->set.infilesize>0) && !conn->bits.upload_chunky) {
        /* only add Content-Length if not uploading chunked */
        result = add_bufferf(req_buffer,
                             ""Content-Length: %"" FORMAT_OFF_T ""\r\n"", /* size */
                             data->set.infilesize );
        if(result)
          return result;
      }

      if(!checkheaders(data, ""Expect:"")) {
        /* if not disabled explicitly we add a Expect: 100-continue
           to the headers which actually speeds up post operations (as
           there is one packet coming back from the web server) */
        result = add_bufferf(req_buffer,
                             ""Expect: 100-continue\r\n"");
        if(result)
          return result;
        data->set.expect100header = TRUE;
      }

      result = add_buffer(req_buffer, ""\r\n"", 2); /* end of headers */
      if(result)
        return result;

      /* set the upload size to the progress meter */
      Curl_pgrsSetUploadSize(data, data->set.infilesize);

      /* this sends the buffer and frees all the buffer resources */
      result = add_buffer_send(req_buffer, conn,
                               &data->info.request_size);
      if(result)
        failf(data, ""Failed sending POST request"");
      else
        /* prepare for transfer */
        result = Curl_Transfer(conn, FIRSTSOCKET, -1, TRUE,
                               &http->readbytecount,
                               FIRSTSOCKET,
                               &http->writebytecount);
      if(result)
        return result;
      break;

    case HTTPREQ_POST:
      /* this is the simple POST, using x-www-form-urlencoded style */

      /* store the size of the postfields */
      postsize = data->set.postfieldsize?
        data->set.postfieldsize:
        (data->set.postfields?(curl_off_t)strlen(data->set.postfields):0);

      if(!conn->bits.upload_chunky) {
        /* We only set Content-Length and allow a custom Content-Length if
           we don't upload data chunked, as RFC2616 forbids us to set both
           kinds of headers (Transfer-Encoding: chunked and Content-Length) */

        if(!checkheaders(data, ""Content-Length:"")) {
          /* we allow replacing this header, although it isn't very wise to
             actually set your own */
          result = add_bufferf(req_buffer,
                               ""Content-Length: %"" FORMAT_OFF_T""\r\n"",
                               postsize);
          if(result)
            return result;
        }
      }

      if(!checkheaders(data, ""Content-Type:"")) {
        result = add_bufferf(req_buffer,
                             ""Content-Type: application/x-www-form-urlencoded\r\n"");
        if(result)
          return result;
      }

      if(data->set.postfields) {

        if((data->state.authhost.done || data->state.authproxy.done )
           && (postsize < (100*1024))) {
          /* If we're not done with the authentication phase, we don't expect
             to actually send off any data yet. Hence, we delay the sending of
             the body until we receive that friendly 100-continue response */

          /* The post data is less than 100K, then append it to the header.
             This limit is no magic limit but only set to prevent really huge
             POSTs to get the data duplicated with malloc() and family. */

          result = add_buffer(req_buffer, ""\r\n"", 2); /* end of headers! */
          if(result)
            return result;

          if(!conn->bits.upload_chunky) {
            /* We're not sending it 'chunked', append it to the request
               already now to reduce the number if send() calls */
            result = add_buffer(req_buffer, data->set.postfields,
                                (size_t)postsize);
          }
          else {
            /* Append the POST data chunky-style */
            result = add_bufferf(req_buffer, ""%x\r\n"", (int)postsize);
            if(CURLE_OK == result)
              result = add_buffer(req_buffer, data->set.postfields,
                                  (size_t)postsize);
            if(CURLE_OK == result)
              result = add_buffer(req_buffer,
                                  ""\r\n0\r\n\r\n"", 7); /* end of a chunked
                                                          transfer stream */
          }
          if(result)
            return result;
        }
        else {
          /* A huge POST coming up, do data separate from the request */
          http->postsize = postsize;
          http->postdata = data->set.postfields;

          http->sending = HTTPSEND_BODY;

          conn->fread = (curl_read_callback)readmoredata;
          conn->fread_in = (void *)conn;

          /* set the upload size to the progress meter */
          Curl_pgrsSetUploadSize(data, http->postsize);

          if(!checkheaders(data, ""Expect:"")) {
            /* if not disabled explicitly we add a Expect: 100-continue to the
               headers which actually speeds up post operations (as there is
               one packet coming back from the web server) */
            add_bufferf(req_buffer,
                        ""Expect: 100-continue\r\n"");
            data->set.expect100header = TRUE;
          }

          add_buffer(req_buffer, ""\r\n"", 2); /* end of headers! */
        }
      }
      else {
        add_buffer(req_buffer, ""\r\n"", 2); /* end of headers! */

        /* set the upload size to the progress meter */
        Curl_pgrsSetUploadSize(data, data->set.infilesize);

        /* set the pointer to mark that we will send the post body using
           the read callback */
        http->postdata = (char *)&http->postdata;
      }
      /* issue the request */
      result = add_buffer_send(req_buffer, conn,
                               &data->info.request_size);

      if(result)
        failf(data, ""Failed sending HTTP POST request"");
      else
        result =
          Curl_Transfer(conn, FIRSTSOCKET, -1, TRUE,
                        &http->readbytecount,
                        http->postdata?FIRSTSOCKET:-1,
                        http->postdata?&http->writebytecount:NULL);
      break;

    default:
      add_buffer(req_buffer, ""\r\n"", 2);

      /* issue the request */
      result = add_buffer_send(req_buffer, conn,
                               &data->info.request_size);

      if(result)
        failf(data, ""Failed sending HTTP request"");
      else
        /* HTTP GET/HEAD download: */
        result = Curl_Transfer(conn, FIRSTSOCKET, -1, TRUE,
                               &http->readbytecount,
                               http->postdata?FIRSTSOCKET:-1,
                               http->postdata?&http->writebytecount:NULL);
    }
    if(result)
      return result;
  }

  return CURLE_OK;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_749.cpp,"[93, 5, 0, 1, 12, 0, 30, 3, 11, 3, 121, 0, 0, 0, 2, 1345, 0, 0, 34, 34, 0, 0, 23, 151, 0, 0, 0, 0, 20, 0, 114, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 720, 24, 675, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 1, 0, 126, 117, 43, 0, 116, 0, 0, 144, 2, 292, 6, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_749.cpp,125
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_543.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_543.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1125.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1125.cpp,1533,1942,1535,1944,"conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"", conn->range);","conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"", data->reqdata.range);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_750.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_750.cpp,"{
      /* if a line like this was already allocated, free the previous one */
      if(conn->allocptr.rangeline)
        free(conn->allocptr.rangeline);
      conn->allocptr.rangeline = aprintf(""Range: bytes=%s\r\n"", conn->range);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_750.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_750.cpp,308
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http_ntlm.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_545.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1130.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1130.cpp,372,708,387,745,,"DEBUG_OUT(fprintf(stderr, ""**** Header %s\n "", *allocuserpwd));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_751.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_751.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy?""Proxy-"":"""",
                              base64);
      free(base64);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_751.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_751.cpp,111
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http_ntlm.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_545.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1131.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1131.cpp,411,770,449,911,"size = snprintf((char *)ntlmbuf, sizeof(ntlmbuf),
                    ""NTLMSSP%c""
                    ""\x03%c%c%c"" /* type-3, 32 bits */

                    ""%c%c%c%c"" /* LanManager length + allocated space */
                    ""%c%c"" /* LanManager offset */
                    ""%c%c"";","size = snprintf((char *)ntlmbuf, sizeof(ntlmbuf),
                    NTLMSSP_SIGNATURE ""%c""
                    ""\x03%c%c%c"" /* type-3, 32 bits */

                    ""%c%c"" /* LanManager length */
                    ""%c%c"" /* LanManager allocated space */
                    ""%c%c"" /* LanManager offset */
                    ""%c%c"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_752.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_752.cpp,"{
    int lmrespoff;
    int ntrespoff;
    int useroff;
    unsigned char lmresp[0x18]; /* fixed-size */
#ifdef USE_NTRESPONSES
    unsigned char ntresp[0x18]; /* fixed-size */
#endif
    const char *user;
    int userlen;

    user = strchr(userp, '\\');
    if(!user)
      user = strchr(userp, '/');

    if (user) {
      domain = userp;
      domlen = (int)(user - domain);
      user++;
    }
    else
      user = userp;
    userlen = (int)strlen(user);

    mkhash(passwdp, &ntlm->nonce[0], lmresp
#ifdef USE_NTRESPONSES
           , ntresp
#endif
      );

    domoff = 64; /* always */
    useroff = domoff + domlen;
    hostoff = useroff + userlen;
    lmrespoff = hostoff + hostlen;
    ntrespoff = lmrespoff + 0x18;

    /* Create the big type-3 message binary blob */
    size = snprintf((char *)ntlmbuf, sizeof(ntlmbuf),
                    ""NTLMSSP%c""
                    ""\x03%c%c%c"" /* type-3, 32 bits */

                    ""%c%c%c%c"" /* LanManager length + allocated space */
                    ""%c%c"" /* LanManager offset */
                    ""%c%c"" /* 2 zeroes */

                    ""%c%c"" /* NT-response length */
                    ""%c%c"" /* NT-response allocated space */
                    ""%c%c"" /* NT-response offset */
                    ""%c%c"" /* 2 zeroes */

                    ""%c%c""  /* domain length */
                    ""%c%c""  /* domain allocated space */
                    ""%c%c""  /* domain name offset */
                    ""%c%c""  /* 2 zeroes */

                    ""%c%c""  /* user length */
                    ""%c%c""  /* user allocated space */
                    ""%c%c""  /* user offset */
                    ""%c%c""  /* 2 zeroes */

                    ""%c%c""  /* host length */
                    ""%c%c""  /* host allocated space */
                    ""%c%c""  /* host offset */
                    ""%c%c%c%c%c%c""  /* 6 zeroes */

                    ""\xff\xff""  /* message length */
                    ""%c%c""  /* 2 zeroes */

                    ""\x01\x82"" /* flags */
                    ""%c%c""  /* 2 zeroes */

                    /* domain string */
                    /* user string */
                    /* host string */
                    /* LanManager response */
                    /* NT response */
                    ,
                    0, /* zero termination */
                    0,0,0, /* type-3 long, the 24 upper bits */

                    SHORTPAIR(0x18),  /* LanManager response length, twice */
                    SHORTPAIR(0x18),
                    SHORTPAIR(lmrespoff),
                    0x0, 0x0,

#ifdef USE_NTRESPONSES
                    SHORTPAIR(0x18),  /* NT-response length, twice */
                    SHORTPAIR(0x18),
#else
                    0x0, 0x0,
                    0x0, 0x0,
#endif
                    SHORTPAIR(ntrespoff),
                    0x0, 0x0,

                    SHORTPAIR(domlen),
                    SHORTPAIR(domlen),
                    SHORTPAIR(domoff),
                    0x0, 0x0,

                    SHORTPAIR(userlen),
                    SHORTPAIR(userlen),
                    SHORTPAIR(useroff),
                    0x0, 0x0,

                    SHORTPAIR(hostlen),
                    SHORTPAIR(hostlen),
                    SHORTPAIR(hostoff),
                    0x0, 0x0, 0x0, 0x0, 0x0, 0x0,

                    0x0, 0x0,

                    0x0, 0x0);

    /* size is now 64 */
    size=64;
    ntlmbuf[62]=ntlmbuf[63]=0;

    memcpy(&ntlmbuf[size], domain, domlen);
    size += domlen;

    memcpy(&ntlmbuf[size], user, userlen);
    size += userlen;

    /* we append the binary hashes to the end of the blob */
    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
      memcpy(&ntlmbuf[size], lmresp, 0x18);
      size += 0x18;
    }

#ifdef USE_NTRESPONSES
    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
      memcpy(&ntlmbuf[size], ntresp, 0x18);
      size += 0x18;
    }
#endif

    ntlmbuf[56] = (unsigned char)(size & 0xff);
    ntlmbuf[57] = (unsigned char)(size >> 8);

    /* convert the binary blob into base64 */
    size = Curl_base64_encode((char *)ntlmbuf, size, &base64);

    if(size >0 ) {
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy?""Proxy-"":"""",
                              base64);
      free(base64);
    }
    else
      return CURLE_OUT_OF_MEMORY; /* FIX TODO */

    ntlm->state = NTLMSTATE_TYPE3; /* we sent a type-3 */
    authp->done = TRUE;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_752.cpp,"[5, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 1, 166, 0, 0, 7, 7, 0, 0, 0, 80, 0, 0, 0, 0, 1, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 1, 146, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 11, 0, 6, 6, 4, 0, 34, 0, 0, 32, 0, 94, 9, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_752.cpp,173
9314bb49e09b323f1c889d95448ca5dd0a42cc61,ENH: Update Curl to 7.16.1,[],Utilities/cmcurl/http_ntlm.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_545.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_545.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1132.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1132.cpp,518,983,560,1067,,"DEBUG_OUT(fprintf(stderr, ""**** %s\n "", *allocuserpwd));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_753.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_753.cpp,"{
      Curl_safefree(*allocuserpwd);
      *allocuserpwd = aprintf(""%sAuthorization: NTLM %s\r\n"",
                              proxy?""Proxy-"":"""",
                              base64);
      free(base64);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_753.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_753.cpp,284
2f84bd17581920eb5cbfc3b41e8cf477ba6a5853,ENH: added per test timeout support,[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_548.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_548.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_548.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1137.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1137.cpp,649,924,765,-1,"sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_754.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_754.cpp,"{
      double ttime = clock_finish - clock_start;
      int hours = static_cast<int>(ttime / (60 * 60));
      int minutes = static_cast<int>(ttime / 60) % 60;
      int seconds = static_cast<int>(ttime) % 60;
      char buffer[100];
      sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);
      *this->LogFile
        << ""----------------------------------------------------------""
        << std::endl
        << ""\"""" << testname.c_str() << ""\"" end time: ""
        << this->CTest->CurrentTime() << std::endl
        << ""\"""" << testname.c_str() << ""\"" time elapsed: ""
        << buffer << std::endl
        << ""----------------------------------------------------------""
        << std::endl << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_754.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 53, 0, 0, 5, 5, 0, 0, 4, 13, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 18, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_754.cpp,204
3a32cec96923cf057aad00274b4a8ab7ad82a82f,ENH: merge in changes for beos support,[],Utilities/cmtar/extract.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_549.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_549.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_549.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1138.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1138.cpp,750,751,753,754,"f(""  ==> extracting: %s (mode %04o, directory)\n"", filename,
         mode);","y(buf, filename, sizeof(buf)-1);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_755.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_755.cpp,"{
  mode_t mode;
  char *filename;
  char buf[T_BLOCKSIZE];
  char *pathname = 0;

  if (!TH_ISDIR(t))
  {
    errno = EINVAL;
    return -1;
  }

  if (realname)
    {
    filename = realname;
    }
  else
    {
    pathname = th_get_pathname(t);
    filename = pathname;
    }
  mode = th_get_mode(t);

  /* Make a copy of the string because dirname and mkdirhier may modify the
   * string */
  strncpy(buf, filename, sizeof(buf)-1);
  buf[sizeof(buf)-1] = 0;

  if (mkdirhier(dirname(buf)) == -1)
    {
    if (pathname)
      {
      free(pathname);
      }
    return -1;
    }

#ifdef DEBUG
  printf(""  ==> extracting: %s (mode %04o, directory)\n"", filename,
         mode);
#endif
#ifdef WIN32
  if (mkdir(filename) == -1)
#else
  if (mkdir(filename, mode) == -1)
#endif
  {
#ifdef __BORLANDC__
  /* There is a bug in the Borland Run time library which makes MKDIR
     return EACCES when it should return EEXIST
     if it is some other error besides directory exists
     then return false */
    if ( errno == EACCES) 
    {
      errno = EEXIST;
    }
#endif      
    if (errno == EEXIST)
    {
      if (chmod(filename, mode) == -1)
      {
#ifdef DEBUG
        perror(""chmod()"");
#endif
        if (pathname)
          {
          free(pathname);
          }
        return -1;
      }
      else
      {
#ifdef DEBUG
        puts(""  *** using existing directory"");
#endif
        if (pathname)
          {
          free(pathname);
          }
        return 1;
      }
    }
    else
    {
#ifdef DEBUG
      perror(""mkdir()"");
#endif
      if (pathname)
        {
        free(pathname);
        }
      return -1;
    }
  }

  if (pathname)
    {
    free(pathname);
    }
  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_755.cpp,"[13, 0, 0, 0, 0, 0, 6, 0, 0, 0, 17, 0, 0, 0, 0, 76, 0, 0, 4, 4, 0, 0, 1, 18, 0, 0, 0, 0, 2, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 65, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 13, 13, 4, 0, 20, 0, 0, 17, 0, 26, 13, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_755.cpp,40
3a32cec96923cf057aad00274b4a8ab7ad82a82f,ENH: merge in changes for beos support,[],Utilities/cmtar/extract.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_549.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_549.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_549.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1138.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1138.cpp,750,751,762,763,,"printf(""  ==> extracting: %s (mode %04o, directory)\n"", filename,
         mode);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_756.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_756.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_756.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_756.cpp,0
ccb77b65c673037780483e23c7bc1b4bf1d17cbc,"ENH: unify version stuff, get rid of it out of cmake and cmMakefile and only use cmVersion",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_551.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_551.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1140.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1140.cpp,1487,1487,1489,1489,"sprintf(ver,""%i.%i"",cmMakefile::GetMajorVersion(),
            cmMakefile::GetMinorVersion());","sprintf(ver,""%i.%i"",cmVersion::GetMajorVersion(),
            cmVersion::GetMinorVersion());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_757.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_757.cpp,"{
    char ver[256];
    sprintf(ver,""%i.%i"",cmMakefile::GetMajorVersion(),
            cmMakefile::GetMinorVersion());
    this->CacheManager->AddCacheEntry
      (""CMAKE_BACKWARDS_COMPATIBILITY"",ver, 
       ""For backwards compatibility, what version of CMake commands and ""
       ""syntax should this version of CMake allow."",
       cmCacheManager::STRING);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_757.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 1, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_757.cpp,29
ccb77b65c673037780483e23c7bc1b4bf1d17cbc,"ENH: unify version stuff, get rid of it out of cmake and cmMakefile and only use cmVersion",[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_551.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_551.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_551.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1141.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1141.cpp,1852,1837,1854,1839,"sprintf(tmp,""Version %d.%d (%s)"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmVersion::GetReleaseVersion().c_str());","sprintf(tmp,""Version %d.%d (%s)"", cmVersion::GetMajorVersion(),
          cmVersion::GetMinorVersion(),
          cmVersion::GetReleaseVersion().c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_758.cpp,"{
#ifdef CMAKE_BUILD_WITH_CMAKE
  // Loop over all registered commands and print out documentation
  const char *name;
  const char *terse;
  const char *full;
  char tmp[1024];
  sprintf(tmp,""Version %d.%d (%s)"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmVersion::GetReleaseVersion().c_str());
  f << ""<html>\n"";
  f << ""<h1>Documentation for commands of CMake "" << tmp << ""</h1>\n"";
  f << ""<ul>\n"";
  for(RegisteredCommandsMap::iterator j = this->Commands.begin();
      j != this->Commands.end(); ++j)
    {
    name = (*j).second->GetName();
    terse = (*j).second->GetTerseDocumentation();
    full = (*j).second->GetFullDocumentation();
    f << ""<li><b>"" << name << ""</b> - "" << terse << std::endl
      << ""<br><i>Usage:</i> "" << full << ""</li>"" << std::endl << std::endl;
    }
  f << ""</ul></html>\n"";
#else
  (void)f;
#endif
  return 1;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_758.cpp,"[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 74, 0, 0, 4, 5, 0, 0, 2, 12, 0, 0, 0, 0, 3, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 1, 0, 1, 0, 10, 0, 0, 10, 0, 5, 3, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_758.cpp,8
e9fb6cd51afebff3db47686ee24e65bc858b0895,BUG: Correct the SystemReportDebugHook function. It should not call exit. It gets called multiple times at shutdown in a memory leak reporting scenario... This is the source of the long standing KWWidgetsTour debug build dashboard failure.,[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_553.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_553.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_553.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1143.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1143.cpp,4091,4091,4093,4093,"fprintf(stderr, message);","fprintf(stderr, ""%s"", message);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_759.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_759.cpp,"{
  fprintf(stderr, message);
  exit(1);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_759.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_759.cpp,2
bdf8e186e5084020a4cbbbe9aa2f63af0febf4ff,BUG: Need to match shared library names before static because some platforms have static name patterns that match their shared patterns but not vice versa.  This is needed for implementing bug#1644 on cygwin.,[u'https://gitlab.kitware.com/cmake/cmake/issues/1644'],Source/cmOrderLinkDirectories.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_555.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_555.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_555.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1145.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1145.cpp,267,267,273,-1,"fprintf(stderr, ""static regex matched [%s] [%s] [%s]\n"",
              this->ExtractStaticLibraryName.match(1).c_str(),
              this->ExtractStaticLibraryName.match(2).c_str(),
              this->ExtractStaticLibraryName.match(3).c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_760.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_760.cpp,"{
#ifdef CM_ORDER_LINK_DIRECTORIES_DEBUG
      fprintf(stderr, ""static regex matched [%s] [%s] [%s]\n"",
              this->ExtractStaticLibraryName.match(1).c_str(),
              this->ExtractStaticLibraryName.match(2).c_str(),
              this->ExtractStaticLibraryName.match(3).c_str());
#endif
      this->SetCurrentLinkType(LinkStatic);
      this->LinkItems.push_back(this->ExtractStaticLibraryName.match(2));
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_760.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 3, 0, 11, 2, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_760.cpp,12
97c97730a6c93b46295284c5a49d285f57a57121,BUG: Character + should be valid in a variable name.,[],Source/cmCommandArgumentLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_556.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_556.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_556.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1147.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1147.cpp,854,863,1216,1252,,"YY_FATAL_ERROR( ""flex scanner push-back overflow"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_761.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_761.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_761.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_761.cpp,0
f1ea7e88dc8322d4344e6b7acde6bf7bcffd7806,ENH: Exposed pattern->regex API.  Cleaned up and commented implementation of pattern->regex conversion.,[],Source/kwsys/Glob.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_557.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1151.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1151.cpp,73,72,82,-1,"sprintf(buffer, ""\\%c"", ch);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_762.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_762.cpp,"{
    sprintf(buffer, ""\\%c"", ch);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_762.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_762.cpp,7
f1ea7e88dc8322d4344e6b7acde6bf7bcffd7806,ENH: Exposed pattern->regex API.  Cleaned up and commented implementation of pattern->regex conversion.,[],Source/kwsys/Glob.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_557.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1151.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1151.cpp,73,72,88,186,"sprintf(buffer, ""%c"", tolower(ch));",ch = tolower(ch);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_763.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_763.cpp,"{
#if defined( KWSYS_GLOB_CASE_INDEPENDENT )
    // On Windows and apple, no difference between lower and upper case
    sprintf(buffer, ""%c"", tolower(ch));
#else
    sprintf(buffer, ""%c"", ch);
#endif
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_763.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 8, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_763.cpp,13
f1ea7e88dc8322d4344e6b7acde6bf7bcffd7806,ENH: Exposed pattern->regex API.  Cleaned up and commented implementation of pattern->regex conversion.,[],Source/kwsys/Glob.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_557.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_557.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1151.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1151.cpp,73,72,90,-1,"sprintf(buffer, ""%c"", ch);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_764.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_764.cpp,"{
#if defined( KWSYS_GLOB_CASE_INDEPENDENT )
    // On Windows and apple, no difference between lower and upper case
    sprintf(buffer, ""%c"", tolower(ch));
#else
    sprintf(buffer, ""%c"", ch);
#endif
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_764.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 8, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_764.cpp,15
d4ae4849f77082ee48f61e5b130ca6fd153b71ea,ENH: reorder code to remove forward declarations,[],Utilities/cmcompress/cmcompress.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_558.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_558.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_558.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1152.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1152.cpp,92,89,120,-1,"printf(""Error...\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_765.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_765.cpp,"{
      printf(""Error...\n"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_765.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_765.cpp,10
d4ae4849f77082ee48f61e5b130ca6fd153b71ea,ENH: reorder code to remove forward declarations,[],Utilities/cmcompress/cmcompress.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_558.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_558.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_558.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1153.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1153.cpp,350,123,370,-1,"fprintf(stream, ""%d.%02d%%"", q / 100, q % 100);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_766.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_766.cpp,"{
  register int q;      /* Doesn't need to be long */

  if(num > 214748L)
    {    /* 2147483647/10000 */
    q = num / (den / 10000L);
    }
  else
    {
    q = 10000L * num / den;    /* Long calculations, though */
    }
  if (q < 0)
    {
    putc('-', stream);
    q = -q;
    }
  fprintf(stream, ""%d.%02d%%"", q / 100, q % 100);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_766.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 1, 18, 0, 0, 1, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 2, 1, 0, 2, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_766.cpp,17
11d18d65dc97ca52d372c8e5ef8294a7f27cb08e,ENH: revert change in parser as it sent the parser into an infinite loop,[],Source/cmDependsFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_559.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_559.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_559.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1160.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1160.cpp,2049,2107,2051,2109,"yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" );","yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" , yyscanner);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_767.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_767.cpp,"yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_767.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_767.cpp,6
11d18d65dc97ca52d372c8e5ef8294a7f27cb08e,ENH: revert change in parser as it sent the parser into an infinite loop,[],Source/cmDependsFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_559.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_559.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_559.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1161.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1161.cpp,2064,2122,2066,2124,"yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" );","yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" , yyscanner);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_768.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_768.cpp,"yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_768.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_768.cpp,6
7169980b59c16370fa5abec8159afc5cc84a96cd,ENH: change comment for fortran depend parsing,[],Source/cmDependsFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_560.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_560.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_560.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1168.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1168.cpp,2107,2049,2109,2051,"yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" , yyscanner);","yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" );",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_769.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_769.cpp,"yy_fatal_error( ""cmDependsFortran_yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_769.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_769.cpp,6
7169980b59c16370fa5abec8159afc5cc84a96cd,ENH: change comment for fortran depend parsing,[],Source/cmDependsFortranLexer.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_560.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_560.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_560.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1169.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1169.cpp,2122,2064,2124,2066,"yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" , yyscanner);","yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" );",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_770.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_770.cpp,"yy_fatal_error( ""cmDependsFortran_yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_770.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_770.cpp,6
898dfe5a2deff445d501f3991b7553c3b3332dff,ENH: Cleanup. Replace c-style cast with static_cast and replace sprintf with cmOStringStream,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_561.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_561.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_561.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1170.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1170.cpp,2384,2383,2386,2386,"f(tgtName, ""%s%d"", graphNodePrefix, cnt++);",ostr << graphNodePrefix << cnt++;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_771.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_771.cpp,"{
      const char* realTargetName = tit->first.c_str();
      if ( ignoreTargetsSet.find(realTargetName) != ignoreTargetsSet.end() )
        {
        // Skip ignored targets
        continue;
        }
      //std::cout << ""Found target: "" << tit->first.c_str() << std::endl;
      sprintf(tgtName, ""%s%d"", graphNodePrefix, cnt++);
      targetNamesNodes[realTargetName] = tgtName;
      targetPtrs[realTargetName] = &tit->second;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_771.cpp,"[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 27, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 1, 1, 0, 0, 4, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_771.cpp,94
9bf5af6e32570195b06df594c1cb07f8c7a6a83e,ENH: Moved unique object file name computation from cmLocalUnixMakefileGenerator3 up to cmLocalGenerator for use by all generators.  Created cmLocalVisualStudioGenerator as superclass for all VS generators.  Implemented on-demand unique object file name computation for VS 7 generator to avoid slow compiles when all sources are in subdirectories.,[],Source/cmLocalUnixMakefileGenerator3.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_563.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_563.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_563.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1172.cpp,1062,1062,1097,-1,"sprintf(rpstr, ""_p_"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_772.cpp,"{
      bool done;
      int cc = 0;
      char rpstr[100];
      sprintf(rpstr, ""_p_"");
      cmSystemTools::ReplaceString(ssin, ""+"", rpstr);
      std::string sssin = sin;
      do
        {
        done = true;
        for ( it = this->UniqueObjectNamesMap.begin();
              it != this->UniqueObjectNamesMap.end();
              ++ it )
          {
          if ( it->second == ssin )
            {
            done = false;
            }
          }
        if ( done )
          {
          break;
          }
        sssin = ssin;
        cmSystemTools::ReplaceString(ssin, ""_p_"", rpstr);
        sprintf(rpstr, ""_p%d_"", cc++);
        }
      while ( !done );
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_772.cpp,"[2, 0, 1, 1, 1, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 48, 0, 0, 4, 4, 0, 0, 3, 8, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 4, 2, 0, 0, 6, 0, 0, 7, 0, 11, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_772.cpp,33
9bf5af6e32570195b06df594c1cb07f8c7a6a83e,ENH: Moved unique object file name computation from cmLocalUnixMakefileGenerator3 up to cmLocalGenerator for use by all generators.  Created cmLocalVisualStudioGenerator as superclass for all VS generators.  Implemented on-demand unique object file name computation for VS 7 generator to avoid slow compiles when all sources are in subdirectories.,[],Source/cmLocalUnixMakefileGenerator3.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_563.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_563.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_563.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1172.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1172.cpp,1062,1062,1118,-1,"sprintf(rpstr, ""_p%d_"", cc++);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_773.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_773.cpp,"{
        done = true;
        for ( it = this->UniqueObjectNamesMap.begin();
              it != this->UniqueObjectNamesMap.end();
              ++ it )
          {
          if ( it->second == ssin )
            {
            done = false;
            }
          }
        if ( done )
          {
          break;
          }
        sssin = ssin;
        cmSystemTools::ReplaceString(ssin, ""_p_"", rpstr);
        sprintf(rpstr, ""_p%d_"", cc++);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_773.cpp,"[2, 0, 1, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 4, 0, 0, 5, 0, 6, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_773.cpp,54
da285df242411b2b798018009e1c2f37e5515c60,ENH: Added test 8 to test grandchildren running after children exit.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_567.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_567.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_567.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1177.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1177.cpp,258,303,261,306,,"printf(""Child was disowned.\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_774.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_774.cpp,"{
    case kwsysProcess_State_Starting:
      printf(""No process has been executed.\n""); break;
    case kwsysProcess_State_Executing:
      printf(""The process is still executing.\n""); break;
    case kwsysProcess_State_Expired:
      printf(""Child was killed when timeout expired.\n""); break;
    case kwsysProcess_State_Exited:
      printf(""Child exited with value = %d\n"",
             kwsysProcess_GetExitValue(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Killed:
      printf(""Child was killed by parent.\n""); break;
    case kwsysProcess_State_Exception:
      printf(""Child terminated abnormally: %s\n"",
             kwsysProcess_GetExceptionString(kp));
      result = ((exception != kwsysProcess_GetExitException(kp)) ||
                (value != kwsysProcess_GetExitValue(kp))); break;
    case kwsysProcess_State_Error:
      printf(""Error in administrating child process: [%s]\n"",
             kwsysProcess_GetErrorString(kp)); break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_774.cpp,"[0, 0, 0, 0, 7, 0, 0, 0, 7, 0, 1, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 9, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_774.cpp,96
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapPythonCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_568.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_568.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_568.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1180.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1180.cpp,196,198,198,200,"fprintf(fout,
            ""extern  \""C\"" {__declspec( dllexport) PyObject *PyVTKClass_%sNew(char *); }\n"",classes[i].c_str());","fprintf(fout, ""extern  \""C\"" {__declspec( dllexport) ""
            ""PyObject *PyVTKClass_%sNew(char *); }\n"", classes[i].c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_775.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_775.cpp,"{
#ifdef _WIN32
    fprintf(fout,
            ""extern  \""C\"" {__declspec( dllexport) PyObject *PyVTKClass_%sNew(char *); }\n"",classes[i].c_str());
#else
    fprintf(fout,""extern  \""C\"" {PyObject *PyVTKClass_%sNew(char *); }\n"",
            classes[i].c_str());
#endif
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_775.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 4, 0, 0, 2, 0, 6, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_775.cpp,25
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1181.cpp,247,252,246,251,"fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");","fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) ""
          ""&& (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,""
          ""int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,""
          ""int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_776.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_776.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "",
                         tempOutputFile.c_str());
    cmSystemTools::ReportLastSystemError("""");
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < this->Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(this->Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  fprintf(fout,""#include \""vtkVersion.h\""\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING(x) VTK_TCL_TO_STRING0(x)\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING0(x) #x\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  char pkgName[]=\""%s\"";\n"", this->LibraryName.c_str());
  fprintf(fout,""  char pkgVers[]=VTK_TCL_TO_STRING(VTK_MAJOR_VERSION)""
               "" \"".\"" ""
               ""VTK_TCL_TO_STRING(VTK_MINOR_VERSION);\n"");
  fprintf(fout,""  Tcl_PkgProvide(interp, pkgName, pkgVers);\n"");
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_776.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 227, 0, 0, 4, 4, 0, 0, 7, 76, 0, 0, 0, 0, 1, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 76, 0, 0, 52, 0, 123, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_776.cpp,27
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1181.cpp,247,252,259,267,"fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());","fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n""
            ,classes[i].c_str());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_777.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_777.cpp,"{
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_777.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_777.cpp,40
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1181.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1181.cpp,247,252,260,269,,"fprintf(fout,""             int argc, char *argv[]);\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_778.cpp,"{
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_778.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_778.cpp,41
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1182.cpp,280,290,282,292,"fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");","fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp,""
          ""ClientData arg);\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_779.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_779.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "",
                         tempOutputFile.c_str());
    cmSystemTools::ReportLastSystemError("""");
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < this->Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(this->Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  fprintf(fout,""#include \""vtkVersion.h\""\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING(x) VTK_TCL_TO_STRING0(x)\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING0(x) #x\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  char pkgName[]=\""%s\"";\n"", this->LibraryName.c_str());
  fprintf(fout,""  char pkgVers[]=VTK_TCL_TO_STRING(VTK_MAJOR_VERSION)""
               "" \"".\"" ""
               ""VTK_TCL_TO_STRING(VTK_MINOR_VERSION);\n"");
  fprintf(fout,""  Tcl_PkgProvide(interp, pkgName, pkgVers);\n"");
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_779.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 227, 0, 0, 4, 4, 0, 0, 7, 76, 0, 0, 0, 0, 1, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 76, 0, 0, 52, 0, 123, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_779.cpp,63
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1182.cpp,280,290,290,302,"fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);","fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT ""
          ""%s_SafeInit(Tcl_Interp *interp);}\n"", kitName);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_780.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "",
                         tempOutputFile.c_str());
    cmSystemTools::ReportLastSystemError("""");
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < this->Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(this->Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  fprintf(fout,""#include \""vtkVersion.h\""\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING(x) VTK_TCL_TO_STRING0(x)\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING0(x) #x\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  char pkgName[]=\""%s\"";\n"", this->LibraryName.c_str());
  fprintf(fout,""  char pkgVers[]=VTK_TCL_TO_STRING(VTK_MAJOR_VERSION)""
               "" \"".\"" ""
               ""VTK_TCL_TO_STRING(VTK_MINOR_VERSION);\n"");
  fprintf(fout,""  Tcl_PkgProvide(interp, pkgName, pkgVers);\n"");
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_780.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 227, 0, 0, 4, 4, 0, 0, 7, 76, 0, 0, 0, 0, 1, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 76, 0, 0, 52, 0, 123, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_780.cpp,71
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1182.cpp,280,290,292,304,"fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);","fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init""
          ""(Tcl_Interp *interp);}\n"", kitName);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_781.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_781.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "",
                         tempOutputFile.c_str());
    cmSystemTools::ReportLastSystemError("""");
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < this->Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(this->Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  fprintf(fout,""#include \""vtkVersion.h\""\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING(x) VTK_TCL_TO_STRING0(x)\n"");
  fprintf(fout,""#define VTK_TCL_TO_STRING0(x) #x\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < this->Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  char pkgName[]=\""%s\"";\n"", this->LibraryName.c_str());
  fprintf(fout,""  char pkgVers[]=VTK_TCL_TO_STRING(VTK_MAJOR_VERSION)""
               "" \"".\"" ""
               ""VTK_TCL_TO_STRING(VTK_MINOR_VERSION);\n"");
  fprintf(fout,""  Tcl_PkgProvide(interp, pkgName, pkgVers);\n"");
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_781.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 227, 0, 0, 4, 4, 0, 0, 7, 76, 0, 0, 0, 0, 1, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 52, 0, 206, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 76, 0, 0, 52, 0, 123, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_781.cpp,73
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1182.cpp,280,290,300,312,"fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");","fprintf(fout,""extern \""C\""\n{\nvoid ""
            ""vtkCommonDeleteAssocData(ClientData cd)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_782.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_782.cpp,"{
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_782.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_782.cpp,81
cac30b5ff8f7034b5290700a4dee28c84e001ac9,STYLE: fix line length,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_569.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_569.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1182.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1182.cpp,280,290,302,315,"fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");","fprintf(fout,""  vtkTclInterpStruct *tis = ""
            ""static_cast<vtkTclInterpStruct*>(cd);\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_783.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_783.cpp,"{
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_783.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_783.cpp,83
fb5d92ea37b6b7cbd9eda84538ce072b90b80b73,ENH: m_ cleanup for curses,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_578.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_578.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_578.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1194.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1194.cpp,441,441,443,443,"sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), m_NumberOfPages);","sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), this->NumberOfPages);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_784.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_784.cpp,"{
    sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), m_NumberOfPages);
    curses_move(0,65-strlen(firstLine)-1);
    printw(firstLine);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_784.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_784.cpp,80
3d96e522617647665d7e99919ba71d34b1db870c,STYLE: some m_ to this-> cleanup,[],Source/cmGlobalGenerator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_581.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_581.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_581.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1199.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1199.cpp,581,581,583,583,"sprintf(num,""%d"",static_cast<int>(m_LocalGenerators.size()));","sprintf(num,""%d"",static_cast<int>(this->LocalGenerators.size()));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_785.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_785.cpp,"{
  // Delete any existing cmLocalGenerators
  unsigned int i;
  for (i = 0; i < m_LocalGenerators.size(); ++i)
    {
    delete m_LocalGenerators[i];
    }
  m_LocalGenerators.clear();

  // Setup relative path generation.
  this->ConfigureRelativePaths();

  // start with this directory
  cmLocalGenerator *lg = this->CreateLocalGenerator();
  m_LocalGenerators.push_back(lg);

  // set the Start directories
  lg->GetMakefile()->SetStartDirectory
    (m_CMakeInstance->GetStartDirectory());
  lg->GetMakefile()->SetStartOutputDirectory
    (m_CMakeInstance->GetStartOutputDirectory());
  lg->GetMakefile()->MakeStartDirectoriesCurrent();
  
  // now do it
  lg->Configure();
  
  // update the cache entry for the number of local generators, this is used
  // for progress
  char num[100];
  sprintf(num,""%d"",static_cast<int>(m_LocalGenerators.size()));
  this->GetCMakeInstance()->AddCacheEntry
    (""CMAKE_NUMBER_OF_LOCAL_GENERATORS"", num,
     ""number of local generators"", cmCacheManager::INTERNAL);
  
  std::set<cmStdString> notFoundMap;
  // after it is all done do a ConfigureFinalPass
  cmCacheManager* manager = 0;
  for (i = 0; i < m_LocalGenerators.size(); ++i)
    {
    manager = m_LocalGenerators[i]->GetMakefile()->GetCacheManager();
    m_LocalGenerators[i]->ConfigureFinalPass();
    cmTargets & targets = 
      m_LocalGenerators[i]->GetMakefile()->GetTargets(); 
    for (cmTargets::iterator l = targets.begin();
         l != targets.end(); l++)
      {
      cmTarget::LinkLibraries libs = l->second.GetLinkLibraries();
      for(cmTarget::LinkLibraries::iterator lib = libs.begin();
          lib != libs.end(); ++lib)
        {
        if(lib->first.size() > 9 && 
           cmSystemTools::IsNOTFOUND(lib->first.c_str()))
          {
          std::string varName = lib->first.substr(0, lib->first.size()-9);
          notFoundMap.insert(varName);
          }
        }
      std::vector<std::string>& incs = 
        m_LocalGenerators[i]->GetMakefile()->GetIncludeDirectories();
      
      for( std::vector<std::string>::iterator lib = incs.begin();
           lib != incs.end(); ++lib)
        {
        if(lib->size() > 9 && 
           cmSystemTools::IsNOTFOUND(lib->c_str()))
          {
          std::string varName = lib->substr(0, lib->size()-9); 
          notFoundMap.insert(varName);
          }
        }
      m_CMakeInstance->UpdateProgress(""Configuring"", 
                                      0.9f+0.1f*(i+1.0f)/m_LocalGenerators.size());
      m_LocalGenerators[i]->GetMakefile()->CheckInfiniteLoops();
      }
    }

  if(notFoundMap.size())
    {
    std::string notFoundVars;
    for(std::set<cmStdString>::iterator ii = notFoundMap.begin();
        ii != notFoundMap.end(); ++ii)
      { 
      notFoundVars += *ii;
      if(manager)
        {
        cmCacheManager::CacheIterator it = 
          manager->GetCacheIterator(ii->c_str());
        if(it.GetPropertyAsBool(""ADVANCED""))
          {
          notFoundVars += "" (ADVANCED)"";
          }
        }
      notFoundVars += ""\n"";
      }
    cmSystemTools::Error(""This project requires some variables to be set,\n""
                         ""and cmake can not find them.\n""
                         ""Please set the following variables:\n"",
                         notFoundVars.c_str());
    }
  // at this point m_LocalGenerators has been filled,
  // so create the map from project name to vector of local generators
  this->FillProjectMap();
  if ( !m_CMakeInstance->GetScriptMode() )
    {
    m_CMakeInstance->UpdateProgress(""Configuring done"", -1);
    }
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_785.cpp,"[6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0, 276, 0, 0, 12, 16, 0, 0, 18, 25, 0, 0, 0, 0, 4, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 115, 0, 93, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 7, 0, 12, 6, 0, 0, 66, 0, 0, 22, 0, 32, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_785.cpp,30
3d96e522617647665d7e99919ba71d34b1db870c,STYLE: some m_ to this-> cleanup,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_584.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_584.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_584.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1203.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1203.cpp,536,537,540,541,"sprintf(output,""%s/%s_force_%i"", m_Makefile->GetStartOutputDirectory(),
          target.GetName(), count);","sprintf(output,""%s/%s_force_%i"", this->Makefile->GetStartOutputDirectory(),
          target.GetName(), count);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_786.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_786.cpp,"{
  // Create a fake output that forces the rule to run.
  char* output = new char[(strlen(m_Makefile->GetStartOutputDirectory()) +
                           strlen(target.GetName()) + 30)];
  sprintf(output,""%s/%s_force_%i"", m_Makefile->GetStartOutputDirectory(),
          target.GetName(), count);

  // Add the rule with the given dependencies and commands.
  const char* no_main_dependency = 0;
  m_Makefile->AddCustomCommandToOutput(output,
                                       depends,
                                       no_main_dependency,
                                       origCommand.GetCommandLines(),
                                       origCommand.GetComment(),
                                       origCommand.GetWorkingDirectory());

  // Replace the dependencies with the output of this rule so that the
  // next rule added will run after this one.
  depends.clear();
  depends.push_back(output);

  // Add a source file representing this output to the project.
  cmSourceFile* outsf = m_Makefile->GetSourceFileWithOutput(output);
  target.GetSourceFiles().push_back(outsf);

  // Free the fake output name.
  delete [] output;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_786.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 57, 0, 0, 3, 3, 0, 0, 3, 3, 0, 0, 0, 0, 3, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 16, 0, 0, 6, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_786.cpp,9
3d96e522617647665d7e99919ba71d34b1db870c,STYLE: some m_ to this-> cleanup,[],Source/cmOutputRequiredFilesCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_585.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_585.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_585.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1204.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1204.cpp,199,199,214,214,"fprintf(fout,""%s\n"",(*d)->m_FullPath.c_str());","fprintf(fout,""%s\n"",(*d)->FullPath.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_787.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_787.cpp,"{
          tmp = tmp.substr(0, pos);
          fprintf(fout,""%s\n"",(*d)->m_FullPath.c_str());
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_787.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_787.cpp,21
ccac9542b109ca6f1edc8a2460310068e90019aa,ENH: Add a way to overwrite some preferences and ignore certain targets,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_606.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_606.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_606.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1240.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1240.cpp,2033,2083,2036,2092,"sprintf(tgtName, ""node%d"", cnt++);","sprintf(tgtName, ""%s%d"", graphNodePrefix, cnt++);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_788.cpp,"{
      //std::cout << ""Found target: "" << tit->first.c_str() << std::endl;
      sprintf(tgtName, ""node%d"", cnt++);
      targetNamesNodes[tit->first.c_str()] = tgtName;
      targetPtrs[tit->first.c_str()] = &tit->second;
      //str << ""    \"""" << tgtName << ""\"" [ label=\"""" << tit->first.c_str() <<  ""\"" shape=\""box\""];"" << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_788.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_788.cpp,33
ccac9542b109ca6f1edc8a2460310068e90019aa,ENH: Add a way to overwrite some preferences and ignore certain targets,[],Source/cmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_606.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_606.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_606.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1241.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1241.cpp,2049,2105,2061,2128,"sprintf(tgtName, ""node%d"", cnt++);","sprintf(tgtName, ""%s%d"", graphNodePrefix, cnt++);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_789.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_789.cpp,"{
          sprintf(tgtName, ""node%d"", cnt++);
          targetDeps[libName] = 2;
          targetNamesNodes[libName] = tgtName;
          //str << ""    \"""" << tgtName << ""\"" [ label=\"""" << libName <<  ""\"" shape=\""ellipse\""];"" << std::endl;
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_789.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_789.cpp,58
0323a0d6d20402d994f4f886d51b8c33c02ed73a,BUG: Fix mem leaks related to th_get_pathname. Change this implementation of th_get_pathname so that it *always* returns a strdup'ed value. Callers must now free non-NULL returns from th_get_pathname. Change all callers to call free appropriately.,[],Utilities/cmtar/extract.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_607.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_607.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_607.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1242.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1242.cpp,170,197,175,203,"printf(""tar_extract_file(): calling libtar_hash_add(): key=\""%s\"", ""
         ""value=\""%s\""\n"", th_get_pathname(t), realname);","printf(""tar_extract_file(): calling libtar_hash_add(): key=\""%s\"", ""
         ""value=\""%s\""\n"", pathname, realname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_790.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_790.cpp,"{
  int i;
  linkname_t *lnp;

  if (t->options & TAR_NOOVERWRITE)
  {
    struct stat s;

#ifdef WIN32
    if (stat(realname, &s) == 0 || errno != ENOENT)
#else
    if (lstat(realname, &s) == 0 || errno != ENOENT)
#endif
    {
      errno = EEXIST;
      return -1;
    }
  }

  if (TH_ISDIR(t))
  {
    i = tar_extract_dir(t, realname);
    if (i == 1)
      i = 0;
  }
#ifndef _WIN32
  else if (TH_ISLNK(t))
    i = tar_extract_hardlink(t, realname);
  else if (TH_ISSYM(t))
    i = tar_extract_symlink(t, realname);
  else if (TH_ISCHR(t))
    i = tar_extract_chardev(t, realname);
  else if (TH_ISBLK(t))
    i = tar_extract_blockdev(t, realname);
  else if (TH_ISFIFO(t))
    i = tar_extract_fifo(t, realname);
#endif
  else /* if (TH_ISREG(t)) */
    i = tar_extract_regfile(t, realname);

  if (i != 0)
    return i;

  i = tar_set_file_perms(t, realname);
  if (i != 0)
    return i;

  lnp = (linkname_t *)calloc(1, sizeof(linkname_t));
  if (lnp == NULL)
    return -1;
  strlcpy(lnp->ln_save, th_get_pathname(t), sizeof(lnp->ln_save));
  strlcpy(lnp->ln_real, realname, sizeof(lnp->ln_real));
#ifdef DEBUG
  printf(""tar_extract_file(): calling libtar_hash_add(): key=\""%s\"", ""
         ""value=\""%s\""\n"", th_get_pathname(t), realname);
#endif
  if (libtar_hash_add(t->h, lnp) != 0)
    return -1;

  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_790.cpp,"[14, 0, 0, 0, 0, 0, 6, 0, 0, 0, 16, 0, 0, 0, 0, 109, 0, 0, 3, 3, 0, 0, 0, 14, 0, 0, 0, 0, 1, 0, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 0, 78, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 14, 14, 2, 0, 26, 0, 0, 14, 5, 44, 7, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_790.cpp,55
0323a0d6d20402d994f4f886d51b8c33c02ed73a,BUG: Fix mem leaks related to th_get_pathname. Change this implementation of th_get_pathname so that it *always* returns a strdup'ed value. Callers must now free non-NULL returns from th_get_pathname. Change all callers to call free appropriately.,[],Utilities/cmtar/extract.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_607.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_607.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_607.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1244.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1244.cpp,268,325,284,357,"printf(""### done extracting %s\n"", filename);","f(""### done extracting %s\n"", filename);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_791.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_791.cpp,"{
  mode_t mode;
  size_t size;
  uid_t uid;
  gid_t gid;
  int fdout;
  int i, k;
  char buf[T_BLOCKSIZE];
  char *filename;

#ifdef DEBUG
  printf(""==> tar_extract_regfile(t=0x%lx, realname=\""%s\"")\n"", t,
         realname);
#endif

  if (!TH_ISREG(t))
  {
    errno = EINVAL;
    return -1;
  }

  filename = (realname ? realname : th_get_pathname(t));
  mode = th_get_mode(t);
  size = th_get_size(t);
  uid = th_get_uid(t);
  gid = th_get_gid(t);

  /* Make a copy of the string because dirname and mkdirhier may modify the
   * string */
  strncpy(buf, filename, sizeof(buf)-1);
  buf[sizeof(buf)-1] = 0;

  if (mkdirhier(dirname(buf)) == -1)
    {
    return -1;
    }

#ifdef DEBUG
  printf(""  ==> extracting: %s (mode %04o, uid %d, gid %d, %d bytes)\n"",
         filename, mode, uid, gid, size);
#endif
  fdout = open(filename, O_WRONLY | O_CREAT | O_TRUNC
#ifdef O_BINARY
         | O_BINARY
#endif
        , 0666);
  if (fdout == -1)
  {
#ifdef DEBUG
    perror(""open()"");
#endif
    return -1;
  }

#if 0
  /* change the owner.  (will only work if run as root) */
  if (fchown(fdout, uid, gid) == -1 && errno != EPERM)
  {
#ifdef DEBUG
    perror(""fchown()"");
#endif
    return -1;
  }

  /* make sure the mode isn't inheritted from a file we're overwriting */
  if (fchmod(fdout, mode & 07777) == -1)
  {
#ifdef DEBUG
    perror(""fchmod()"");
#endif
    return -1;
  }
#endif

  /* extract the file */
  for (i = size; i > 0; i -= T_BLOCKSIZE)
  {
    k = tar_block_read(t, buf);
    if (k != T_BLOCKSIZE)
    {
      if (k != -1)
        errno = EINVAL;
      return -1;
    }

    /* write block to output file */
    if (write(fdout, buf,
        ((i > T_BLOCKSIZE) ? T_BLOCKSIZE : i)) == -1)
      return -1;
  }

  /* close output file */
  if (close(fdout) == -1)
    return -1;

#ifdef DEBUG
  printf(""### done extracting %s\n"", filename);
#endif

  (void)filename;
  (void)gid;
  (void)uid;
  (void)mode;

  return 0;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_791.cpp,"[8, 0, 1, 0, 0, 0, 7, 0, 0, 0, 9, 0, 0, 0, 0, 108, 0, 0, 8, 9, 0, 0, 1, 22, 0, 0, 0, 0, 1, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 2, 79, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 2, 0, 10, 9, 2, 0, 19, 0, 0, 19, 0, 34, 16, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_791.cpp,98
0323a0d6d20402d994f4f886d51b8c33c02ed73a,BUG: Fix mem leaks related to th_get_pathname. Change this implementation of th_get_pathname so that it *always* returns a strdup'ed value. Callers must now free non-NULL returns from th_get_pathname. Change all callers to call free appropriately.,[],Utilities/cmtar/output.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_608.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_608.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_608.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1249.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1249.cpp,124,125,126,127,"printf("" %s"", th_get_pathname(t));",pathname = th_get_pathname(t);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_792.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_792.cpp,"char modestring[12];
#if !defined(_WIN32) || defined(__CYGWIN__)
  struct passwd *pw;
  struct group *gr;
#endif
  uid_t uid;
  gid_t gid;
  char username[_POSIX_LOGIN_NAME_MAX];
  char groupname[_POSIX_LOGIN_NAME_MAX];
  time_t mtime;
  struct tm *mtm;

#ifdef HAVE_STRFTIME
  char timebuf[18];
#else
  const char *months[] = {
    ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
    ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""
  };
#endif

  uid = th_get_uid(t);
#if !defined(_WIN32) || defined(__CYGWIN__)
  pw = getpwuid(uid);
  if (pw != NULL)
    strlcpy(username, pw->pw_name, sizeof(username));
  else
#endif
    snprintf(username, sizeof(username), ""%d"", (int)uid);
  gid = th_get_gid(t);
#if !defined(_WIN32) || defined(__CYGWIN__)
  gr = getgrgid(gid);
  if (gr != NULL)
    strlcpy(groupname, gr->gr_name, sizeof(groupname));
  else
#endif
    snprintf(groupname, sizeof(groupname), ""%d"", (int)gid);
    
  strmode(th_get_mode(t), modestring);
  printf(""%.10s %-8.8s %-8.8s "", modestring, username, groupname);

#if !defined(_WIN32) || defined(__CYGWIN__)
  if (TH_ISCHR(t) || TH_ISBLK(t))
    printf("" %3d, %3d "", th_get_devmajor(t), th_get_devminor(t));
  else
#endif
    printf(""%9ld "", (long)th_get_size(t));

  mtime = th_get_mtime(t);
  mtm = localtime(&mtime);
#ifdef HAVE_STRFTIME
  strftime(timebuf, sizeof(timebuf), ""%h %e %H:%M %Y"", mtm);
  printf(""%s"", timebuf);
#else
  printf(""%.3s %2d %2d:%02d %4d"",
         months[mtm->tm_mon],
         mtm->tm_mday, mtm->tm_hour, mtm->tm_min, mtm->tm_year + 1900);
#endif

  printf("" %s"", th_get_pathname(t))",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_792.cpp,"[7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 1, 143, 0, 0, 11, 11, 0, 0, 1, 24, 0, 0, 0, 0, 4, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 104, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 6, 0, 3, 3, 5, 0, 37, 0, 0, 17, 0, 64, 14, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_792.cpp,62
0323a0d6d20402d994f4f886d51b8c33c02ed73a,BUG: Fix mem leaks related to th_get_pathname. Change this implementation of th_get_pathname so that it *always* returns a strdup'ed value. Callers must now free non-NULL returns from th_get_pathname. Change all callers to call free appropriately.,[],Utilities/cmtar/output.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_608.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_608.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_608.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1249.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1249.cpp,124,125,128,130,,"printf("" %s"", pathname);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_793.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_793.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_793.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_793.cpp,0
bdbb7f84bc85c27aa49133f060e3407aa3990eea,ENH: Added special test 0 to just run a given command line.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_612.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_612.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_612.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1254.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1254.cpp,330,330,339,-1,"fprintf(stdout, ""Usage: %s <test number>\n"", argv[0]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_794.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_794.cpp,"{
    fprintf(stdout, ""Usage: %s <test number>\n"", argv[0]);
    return 1;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_794.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_794.cpp,30
c5e532d07dd4e820be2a81b07e12629690425027,COMP: Try to remove warnings and add support for cygwin,[],Utilities/cmtar/output.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_617.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_617.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_617.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1260.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1260.cpp,85,87,93,95,"snprintf(username, sizeof(username), ""%d"", uid);","snprintf(username, sizeof(username), ""%d"", (int)uid);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_795.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_795.cpp,"snprintf(username, sizeof(username), ""%d"", uid)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_795.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_795.cpp,31
c5e532d07dd4e820be2a81b07e12629690425027,COMP: Try to remove warnings and add support for cygwin,[],Utilities/cmtar/output.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_617.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_617.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_617.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1260.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1260.cpp,85,87,101,103,"snprintf(groupname, sizeof(groupname), ""%d"", gid);","snprintf(groupname, sizeof(groupname), ""%d"", (int)gid);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_796.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_796.cpp,"snprintf(groupname, sizeof(groupname), ""%d"", gid)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_796.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_796.cpp,39
d1180fc4e1545f98fddd9a51bb2140f04af0730d,ENH: Add untaring support,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_618.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_618.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_618.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1261.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1261.cpp,1382,1382,1384,1384,"fprintf(stderr, ""tar_open(): %s\n"", strerror(errno));","cmSystemTools::Error(""Problem with tar_open(): "", strerror(errno));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_797.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_797.cpp,"{
    fprintf(stderr, ""tar_open(): %s\n"", strerror(errno));
    return false;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_797.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_797.cpp,17
18d31fd97c3305b54a6d1d56b6ef8600089ef6da,COMP: Several borland fixes,[],Utilities/cmtar/wrapper.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_623.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_623.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_623.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1266.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1266.cpp,145,145,147,147,"snprintf(realpath, MAXPATHLEN, ""%s/%s"", realdir,
       dent->d_name);","snprintf(realpath, TAR_MAXPATHLEN, ""%s/%s"", realdir,
       dent->d_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_798.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_798.cpp,"{
    if (strcmp(dent->d_name, ""."") == 0 ||
        strcmp(dent->d_name, "".."") == 0)
      continue;

    snprintf(realpath, MAXPATHLEN, ""%s/%s"", realdir,
       dent->d_name);
    if (savedir)
      snprintf(savepath, MAXPATHLEN, ""%s/%s"", savedir,
         dent->d_name);

#ifndef WIN32
    if (lstat(realpath, &s) != 0)
      return -1;
#else
    if (stat(realpath, &s) != 0)
      return -1;
#endif
    if (S_ISDIR(s.st_mode))
    {
      if (tar_append_tree(t, realpath,
              (savedir ? savepath : NULL)) != 0)
        return -1;
      continue;
    }

    if (tar_append_file(t, realpath,
            (savedir ? savepath : NULL)) != 0)
      return -1;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_798.cpp,"[7, 0, 0, 0, 0, 2, 4, 0, 0, 0, 8, 0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 2, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 3, 0, 9, 0, 0, 2, 0, 25, 3, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_798.cpp,48
18d31fd97c3305b54a6d1d56b6ef8600089ef6da,COMP: Several borland fixes,[],Utilities/cmtar/wrapper.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_623.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_623.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_623.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1266.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1266.cpp,145,145,150,150,"snprintf(savepath, MAXPATHLEN, ""%s/%s"", savedir,
         dent->d_name);","snprintf(savepath, TAR_MAXPATHLEN, ""%s/%s"", savedir,
         dent->d_name);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_799.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_799.cpp,"snprintf(savepath, MAXPATHLEN, ""%s/%s"", savedir,
         dent->d_name)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_799.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 5, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_799.cpp,51
9b486bacfc98d6878b0e48f0136653c98cc5b385,ENH: Modify API a little bit to allow arbitrary length values. Encode certain characters. Rename UNIX registry to FILE registry. More testing,[],Source/kwsys/Registry.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_626.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_626.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_626.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1269.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1269.cpp,630,653,656,-1,"::sprintf(newkey, ""%s\\%s"", this->m_SubKey.c_str(), key);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_800.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_800.cpp,"{
  char *newkey;
  if ( !m_SubKeySpecified || m_SubKey.empty() || !key )
    {
    return 0;
    }
  int len = strlen(this->m_SubKey.c_str()) + strlen(key) + 1;
  newkey = new char[ len+1 ] ;
  ::sprintf(newkey, ""%s\\%s"", this->m_SubKey.c_str(), key);
  return newkey;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_800.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 29, 0, 0, 2, 2, 0, 0, 1, 4, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 0, 0, 6, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_800.cpp,9
3f14dae7162f5a78748a13b03d6501b52bbea784,ENH: Extended test 0 to run the executable twice using the same process object.  This tests the reusability of the objects.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_629.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_629.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_629.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1273.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1273.cpp,150,151,164,-1,"fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_801.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_801.cpp,"{
    fprintf(stderr, ""kwsysProcess_New returned NULL!\n"");
    return 1;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_801.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_801.cpp,12
05d8429206d7192e328c2646cbc2b9776362dd7b,COMP: Remove warnings,[],Source/CTest/cmCTestSubmitHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_631.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_631.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_631.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1275.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1275.cpp,268,268,270,270,"sprintf(hex, ""%%%02X"", (int)c);","sprintf(hexCh, ""%%%02X"", (int)c);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_802.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_802.cpp,"{
        case '+':
        case '?':
        case '/':
        case '\\':
        case '&':
        case ' ':
        case '=':
        case '%':
          sprintf(hex, ""%%%02X"", (int)c);
          ofile.append(hex);
          break;
        default: 
          ofile.append(hex);
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_802.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 8, 1, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_802.cpp,73
05d8429206d7192e328c2646cbc2b9776362dd7b,COMP: Remove warnings,[],Source/CTest/cmCTestSubmitHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_631.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_631.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_631.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1276.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1276.cpp,419,419,421,421,"sprintf(hex, ""%%%02X"", (int)c);","sprintf(hexCh, ""%%%02X"", (int)c);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_803.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_803.cpp,"{
        case '+':
        case '?':
        case '/':
        case '\\':
        case '&':
        case ' ':
        case '=':
        case '%':
          sprintf(hex, ""%%%02X"", (int)c);
          ofile.append(hex);
          break;
        default: 
          ofile.append(hex);
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_803.cpp,"[0, 0, 0, 0, 1, 0, 0, 0, 8, 1, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_803.cpp,72
1b578d3180ce60976e4cbe928fce988acfd0da39,"ENH: Several improvements with the way things are handled. Also, support multiple submited files",[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_632.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_632.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_632.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1277.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1277.cpp,39,39,47,48,"sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);","sprintf(covLogFilename, ""CoverageLog-%d"", logFileCount);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_804.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_804.cpp,"{
  char covLogFilename[1024];
  sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);
  cmCTestLog(m_CTest, HANDLER_VERBOSE_OUTPUT, ""Open file: "" << covLogFilename << std::endl);
  if (!m_CTest->OpenOutputFile(m_CTest->GetCurrentTag(), 
      covLogFilename, covLogFile, true))
    {
    cmCTestLog(m_CTest, ERROR_MESSAGE, ""Cannot open log file: "" << covLogFilename << std::endl);
    return false;
    }
  std::string local_start_time = m_CTest->CurrentTime();
  m_CTest->StartXML(covLogFile);
  covLogFile << ""<CoverageLog>"" << std::endl
    << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_804.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 47, 0, 0, 2, 2, 0, 0, 1, 10, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 0, 0, 7, 0, 0, 5, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_804.cpp,3
dec5cc1082f92fd1ba56afe9efc596377afc4461,ENH: converted macro to use variables and fixed some case issues with some function blockers,[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_633.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1278.cpp,112,112,203,-1,"sprintf(argvName,""${ARGV%i}"",t);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_805.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_805.cpp,"{
          sprintf(argvName,""${ARGV%i}"",t);
          cmSystemTools::ReplaceString(tmps, argvName,
                                       expandedArgs[t].c_str());
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_805.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_805.cpp,119
dec5cc1082f92fd1ba56afe9efc596377afc4461,ENH: converted macro to use variables and fixed some case issues with some function blockers,[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_633.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1278.cpp,112,112,162,145,,"sprintf(argvName,""ARGV%i"",cnt);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_806.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_806.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_806.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_806.cpp,0
dec5cc1082f92fd1ba56afe9efc596377afc4461,ENH: converted macro to use variables and fixed some case issues with some function blockers,[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_633.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_633.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1278.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1278.cpp,112,112,246,208,,"sprintf(argvName,""ARGV%i"",j);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_807.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_807.cpp,"{
  // Expand the argument list to the macro.
  std::vector<std::string> expandedArgs;
  m_Makefile->ExpandArguments(args, expandedArgs);
  
  std::string tmps;
  cmListFileArgument arg;
  std::string variable;

  // make sure the number of arguments passed is at least the number
  // required by the signature
  if (expandedArgs.size() < m_Args.size() - 1)
    {
    std::string errorMsg = 
      ""Macro invoked with incorrect arguments for macro named: "";
    errorMsg += m_Args[0];
    this->SetError(errorMsg.c_str());
    return false;
    }
  
  // set the value of argc
  cmOStringStream argcDefStream;
  argcDefStream << expandedArgs.size();
  std::string argcDef = argcDefStream.str();
  
  // declare varuiables for ARGV ARGN but do not compute until needed
  std::string argvDef;
  std::string argnDef;
  bool argnDefInitialized = false;
  bool argvDefInitialized = false;
  
  // Invoke all the functions that were collected in the block.
  cmListFileFunction newLFF;
  // for each function
  for(unsigned int c = 0; c < m_Functions.size(); ++c)
    {
    // Replace the formal arguments and then invoke the command.
    newLFF.m_Arguments.clear();
    newLFF.m_Arguments.reserve(m_Functions[c].m_Arguments.size());
    newLFF.m_Name = m_Functions[c].m_Name;
    newLFF.m_FilePath = m_Functions[c].m_FilePath;
    newLFF.m_Line = m_Functions[c].m_Line;
    const char* def =
      m_Makefile->GetDefinition(""CMAKE_MACRO_REPORT_DEFINITION_LOCATION""); 
    bool macroReportLocation = false;
    if(def && !cmSystemTools::IsOff(def))
      {
      macroReportLocation = true;
      }
    
    // for each argument of the current function
    for (std::vector<cmListFileArgument>::const_iterator k = 
           m_Functions[c].m_Arguments.begin();
         k != m_Functions[c].m_Arguments.end(); ++k)
      {
      tmps = k->Value;
      // replace formal arguments
      for (unsigned int j = 1; j < m_Args.size(); ++j)
        {
        variable = ""${"";
        variable += m_Args[j];
        variable += ""}""; 
        cmSystemTools::ReplaceString(tmps, variable.c_str(),
                                     expandedArgs[j-1].c_str());
        }
      // replace argc
      cmSystemTools::ReplaceString(tmps, ""${ARGC}"",argcDef.c_str());
      
      // repleace ARGN
      if (tmps.find(""${ARGN}"") != std::string::npos)
        {
        if (!argnDefInitialized)
          {
          std::vector<std::string>::const_iterator eit;
          std::vector<std::string>::size_type cnt = 0;
          for ( eit = expandedArgs.begin(); eit != expandedArgs.end(); ++eit )
            {
            if ( cnt >= m_Args.size()-1 )
              {
              if ( argnDef.size() > 0 )
                {
                argnDef += "";"";
                }
              argnDef += *eit;
              }
            cnt ++;
            }
          argnDefInitialized = true;
          }
        cmSystemTools::ReplaceString(tmps, ""${ARGN}"", argnDef.c_str());
        }
      
      // if the current argument of the current function has ${ARGV in it
      // then try replacing ARGV values
      if (tmps.find(""${ARGV"") != std::string::npos)
        {
        char argvName[60];
        
        // repleace ARGV, compute it only once
        if (!argvDefInitialized)
          {
          std::vector<std::string>::const_iterator eit;
          for ( eit = expandedArgs.begin(); eit != expandedArgs.end(); ++eit )
            {
            if ( argvDef.size() > 0 )
              {
              argvDef += "";"";
              }
            argvDef += *eit;
            }
          argvDefInitialized = true;
          }
        cmSystemTools::ReplaceString(tmps, ""${ARGV}"", argvDef.c_str());
        
        // also replace the ARGV1 ARGV2 ... etc
        for (unsigned int t = 0; t < expandedArgs.size(); ++t)
          {
          sprintf(argvName,""${ARGV%i}"",t);
          cmSystemTools::ReplaceString(tmps, argvName,
                                       expandedArgs[t].c_str());
          }
        }
      
      arg.Value = tmps;
      arg.Quoted = k->Quoted;
      if(macroReportLocation)
        {
        // Report the location of the argument where the macro was
        // defined.
        arg.FilePath = k->FilePath;
        arg.Line = k->Line;
        }
      else
        {
        // Report the location of the argument where the macro was
        // invoked.
        if (args.size())
          {
          arg.FilePath = args[0].FilePath;
          arg.Line = args[0].Line;
          }
        else
          {
          arg.FilePath = ""Unknown"";
          arg.Line = 0;
          }
        }
      newLFF.m_Arguments.push_back(arg);
      }
    if(!m_Makefile->ExecuteCommand(newLFF))
      {
      cmOStringStream error;
      error << ""Error in cmake code at\n""
            << args[0].FilePath << "":"" << args[0].Line << "":\n""
            << ""A command failed during the invocation of macro \""""
            << this->m_Args[0].c_str() << ""\""."";
      cmSystemTools::Error(error.str().c_str());
      return false;
      }
    }
  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_807.cpp,"[12, 0, 6, 0, 0, 0, 3, 0, 0, 0, 21, 0, 0, 0, 1, 372, 0, 0, 19, 23, 0, 0, 17, 44, 0, 0, 0, 0, 1, 0, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 159, 0, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 16, 0, 18, 12, 2, 0, 50, 0, 0, 38, 0, 34, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_807.cpp,162
d36f3c5543eed9e120b855e3c1b0d55d800f374e,ENH: Handle errors and optimize a bit,[],Source/cmCommandArgumentParserHelper.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_635.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_635.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_635.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1282.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1282.cpp,296,303,298,-1,"fprintf(stderr, ""Argument Parser Error: %s (%lu / Line: %d)\n"", str, pos, this->CurrentLine);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_808.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_808.cpp,"{
  unsigned long pos = static_cast<unsigned long>(this->InputBufferPos);
  fprintf(stderr, ""Argument Parser Error: %s (%lu / Line: %d)\n"", str, pos, this->CurrentLine);
  int cc;
  std::cerr << ""String: ["";
  for ( cc = 0; cc < 30 && *(this->InputBuffer.c_str() + this->InputBufferPos + cc);
    cc ++ )
    {
    std::cerr << *(this->InputBuffer.c_str() + this->InputBufferPos + cc);
    }
  std::cerr << ""]"" << std::endl;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_808.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 2, 2, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 4, 0, 7, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_808.cpp,3
bbf1c3a0e87c4358b65d41393455fc393d8e16e0,ENH: Handle more cases,[],Source/cmCommandArgumentParserHelper.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_636.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_636.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_636.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1283.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1283.cpp,289,296,291,298,"fprintf(stderr, ""JPError: %s (%lu / Line: %d)\n"", str, pos, this->CurrentLine);","fprintf(stderr, ""Argument Parser Error: %s (%lu / Line: %d)\n"", str, pos, this->CurrentLine);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_809.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_809.cpp,"{
  unsigned long pos = static_cast<unsigned long>(this->InputBufferPos);
  fprintf(stderr, ""JPError: %s (%lu / Line: %d)\n"", str, pos, this->CurrentLine);
  int cc;
  std::cerr << ""String: ["";
  for ( cc = 0; cc < 30 && *(this->InputBuffer.c_str() + this->InputBufferPos + cc);
    cc ++ )
    {
    std::cerr << *(this->InputBuffer.c_str() + this->InputBufferPos + cc);
    }
  std::cerr << ""]"" << std::endl;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_809.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 2, 2, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 15, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 4, 0, 7, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_809.cpp,3
f6e5a878fc8de3ac3ef38b144a0a649a9f227682,"ENH: Add support for writing output file. While doing that, redesign the way ctest does output. There may still be problems with commands failing, but that should be fixed by applying the similar concept to whole CMake",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_638.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_638.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_638.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1286.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1286.cpp,257,257,259,259,"fprintf(stderr,""\n%.0f%% tests passed, %i tests failed out of %i\n"",
      percent, int(failed.size()), total);","cmCTestLog(m_CTest, HANDLER_OUTPUT, std::endl << std::setprecision(0) << percent << ""% tests passed, ""
      << failed.size() << "" tests failed out of "" << total << std::endl);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_810.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_810.cpp,"{
    if (m_Verbose && passed.size() && 
      (m_UseIncludeRegExp || m_UseExcludeRegExp)) 
      {
      std::cerr << ""\nThe following tests passed:\n"";
      for(std::vector<cmStdString>::iterator j = passed.begin();
          j != passed.end(); ++j)
        {   
        std::cerr << ""\t"" << *j << ""\n"";
        }
      }

    float percent = float(passed.size()) * 100.0f / total;
    if ( failed.size() > 0 &&  percent > 99)
      {
      percent = 99;
      }
    fprintf(stderr,""\n%.0f%% tests passed, %i tests failed out of %i\n"",
      percent, int(failed.size()), total);

    if (failed.size()) 
      {
      cmGeneratedFileStream ofs;

      std::cerr << ""\nThe following tests FAILED:\n"";
      m_CTest->OpenOutputFile(""Temporary"", ""LastTestsFailed.log"", ofs);

      std::vector<cmCTestTestHandler::cmCTestTestResult>::iterator ftit;
      for(ftit = m_TestResults.begin();
        ftit != m_TestResults.end(); ++ftit)
        {
        if ( ftit->m_Status != cmCTestTestHandler::COMPLETED )
          {
          ofs << ftit->m_TestCount << "":"" << ftit->m_Name << std::endl;
          fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));
          }
        }

      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_810.cpp,"[4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 109, 0, 0, 3, 4, 0, 0, 4, 13, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 4, 0, 0, 18, 0, 0, 8, 0, 18, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_810.cpp,60
f6e5a878fc8de3ac3ef38b144a0a649a9f227682,"ENH: Add support for writing output file. While doing that, redesign the way ctest does output. There may still be problems with commands failing, but that should be fixed by applying the similar concept to whole CMake",[],Source/CTest/cmCTestTestHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_638.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_638.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_638.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1287.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1287.cpp,274,276,276,278,"fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));","cmCTestLog(m_CTest, HANDLER_OUTPUT, ""\t"" << std::setw(3) << ftit->m_TestCount << "" - "" << ftit->m_Name.c_str() << "" ("" << this->GetTestStatus(ftit->m_Status) << "")"" << std::endl);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_811.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_811.cpp,"{
          ofs << ftit->m_TestCount << "":"" << ftit->m_Name << std::endl;
          fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_811.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_811.cpp,77
15c7d45ecd787b74eb4a4dc5cafe69bd92351938,BUG: Fixed ordering of multiple commands in a custom target when implemented as custom commands.  Also added support to execute pre-build rules first to be consistent with makefile generator.,[],Source/cmLocalVisualStudio6Generator.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_644.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_644.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_644.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1293.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1293.cpp,217,217,233,242,"sprintf(output,""%s/%s_force_%i"",
              m_Makefile->GetStartOutputDirectory(),
              libName, count);","depends.insert(depends.end(),
                     cr->GetDepends().begin(), cr->GetDepends().end());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_812.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_812.cpp,"{
      char *output = new char [
        strlen(m_Makefile->GetStartOutputDirectory()) + 
        strlen(libName) + 30];
      sprintf(output,""%s/%s_force_%i"",
              m_Makefile->GetStartOutputDirectory(),
              libName, count);
      const char* no_main_dependency = 0;
      const char* no_comment = 0;
      m_Makefile->AddCustomCommandToOutput(output,
                                           cr->GetDepends(),
                                           no_main_dependency,
                                           cr->GetCommandLines(),
                                           no_comment);
      cmSourceFile* outsf = 
        m_Makefile->GetSourceFileWithOutput(output);
      target.GetSourceFiles().push_back(outsf);
      count++;
      delete [] output;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_812.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 46, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 4, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 0, 0, 0, 0, 11, 0, 0, 5, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_812.cpp,26
f362d6e2ef1766425070e8dbfaa8a2fd668a988d,BUG: Expanded difference in timeouts between tests 4 and 5 so that 5 does not timeout while waiting for 4 to timeout.  This should fix the intermittent failure of test 5 on cygwin.  ENH: When a mismatch is reported it now reports what it was as well as what it should have been.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1297.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1297.cpp,198,198,200,200,"fprintf(stderr, ""Mismatch in exit exception.  Should have been %d.\n"",
              exception);","fprintf(stderr, ""Mismatch in exit exception.  ""
              ""Should have been %d, was %d.\n"",
              exception, kwsysProcess_GetExitException(kp));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_813.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_813.cpp,"{
      fprintf(stderr, ""Mismatch in exit exception.  Should have been %d.\n"",
              exception);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_813.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_813.cpp,72
f362d6e2ef1766425070e8dbfaa8a2fd668a988d,BUG: Expanded difference in timeouts between tests 4 and 5 so that 5 does not timeout while waiting for 4 to timeout.  This should fix the intermittent failure of test 5 on cygwin.  ENH: When a mismatch is reported it now reports what it was as well as what it should have been.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1297.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1297.cpp,198,198,205,206,"fprintf(stderr, ""Mismatch in exit value.  Should have been %d.\n"",
              value);","fprintf(stderr, ""Mismatch in exit value.  ""
              ""Should have been %d, was %d.\n"",
              value, kwsysProcess_GetExitValue(kp));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_814.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_814.cpp,"{
      fprintf(stderr, ""Mismatch in exit value.  Should have been %d.\n"",
              value);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_814.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_814.cpp,77
f362d6e2ef1766425070e8dbfaa8a2fd668a988d,BUG: Expanded difference in timeouts between tests 4 and 5 so that 5 does not timeout while waiting for 4 to timeout.  This should fix the intermittent failure of test 5 on cygwin.  ENH: When a mismatch is reported it now reports what it was as well as what it should have been.,[],Source/kwsys/testProcess.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_647.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_647.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1297.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1297.cpp,198,198,212,214,"fprintf(stderr, ""Mismatch in state.  Should have been %d.\n"", state);","fprintf(stderr, ""Mismatch in state.  ""
            ""Should have been %d, was %d.\n"",
            state, kwsysProcess_GetState(kp));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_815.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_815.cpp,"{
    fprintf(stderr, ""Mismatch in state.  Should have been %d.\n"", state);
    result = 1;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_815.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_815.cpp,84
3caedbdddb285909854833375ef736fef6a7b04a,ENH: Initial implementation of SVN support. Closes Bug #1601 - Add subversion support,[u'https://gitlab.kitware.com/cmake/cmake/issues/1601'],Source/CTest/cmCTestUpdateHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_650.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_650.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_650.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1300.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1300.cpp,45,166,81,268,"sprintf(current_time, ""%04d-%02d-%02d %02d:%02d:%02d UTC"",
      t->tm_year + 1900,
      t->tm_mon + 1,
      t->tm_mday,
      t->tm_hour,
      t->tm_min,
      t->tm_sec);","sprintf(current_time, ""%04d-%02d-%02d %02d:%02d:%02d"",
      t->tm_year + 1900,
      t->tm_mon + 1,
      t->tm_mday,
      t->tm_hour,
      t->tm_min,
      t->tm_sec);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_816.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_816.cpp,"{
    struct tm* t = cmCTest::GetNightlyTime(m_CTest->GetDartConfiguration(""NightlyStartTime""),
      m_Verbose, m_CTest->GetTomorrowTag());
    char current_time[1024];
    sprintf(current_time, ""%04d-%02d-%02d %02d:%02d:%02d UTC"",
      t->tm_year + 1900,
      t->tm_mon + 1,
      t->tm_mday,
      t->tm_hour,
      t->tm_min,
      t->tm_sec);
    std::string today_update_date = current_time;
   
    extra_update_opts += ""-D \"""" + today_update_date +""\"""";
    //std::cout << ""Update: "" << extra_update_opts << std::endl;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_816.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 44, 0, 0, 3, 3, 0, 0, 2, 7, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 12, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_816.cpp,30
93384c776363f749c910ff95836533a1a9be0e4a,BUG: Removing debugging code now that the problem has been fixed on the remote dashboard.,[],Source/kwsys/SystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_651.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_651.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_651.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1301.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1301.cpp,2280,2280,2283,-1,"fprintf(stderr, ""cwd=[%s]\npwd=[%s]\npwd_path=[%s]\n"",
                cwd, pwd, pwd_path.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_817.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_817.cpp,"{
#if defined(__HP_aCC)
        fprintf(stderr, ""cwd=[%s]\npwd=[%s]\npwd_path=[%s]\n"",
                cwd, pwd, pwd_path.c_str());
#endif
        // The current working directory is a logical path.  Split
        // both the logical and physical paths into their components.
        kwsys_stl::vector<kwsys_stl::string> cwd_components;
        kwsys_stl::vector<kwsys_stl::string> pwd_components;
        SystemTools::SplitPath(cwd, cwd_components);
        SystemTools::SplitPath(pwd, pwd_components);

        // Remove the common ending of the paths to leave only the
        // part that changes under the logical mapping.
        kwsys_stl::vector<kwsys_stl::string>::iterator ic = cwd_components.end();
        kwsys_stl::vector<kwsys_stl::string>::iterator ip = pwd_components.end();
        for(;ip != pwd_components.begin() && ic != cwd_components.begin() &&
              *(ip-1) == *(ic-1); --ip,--ic);
        cwd_components.erase(ic, cwd_components.end());
        pwd_components.erase(ip, pwd_components.end());

        // Reconstruct the string versions of the part of the path
        // that changed.
        kwsys_stl::string cwd_changed = SystemTools::JoinPath(cwd_components);
        kwsys_stl::string pwd_changed = SystemTools::JoinPath(pwd_components);

        // Add the translation to keep the logical path name.
        if(!cwd_changed.empty() && !pwd_changed.empty())
          {
#if defined(__HP_aCC)
          fprintf(stderr, ""adding [%s]->[%s]\n"", cwd_changed.c_str(),
                  pwd_changed.c_str());
#endif
          SystemTools::AddTranslationPath(cwd_changed.c_str(),
                                          pwd_changed.c_str());
          }
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_817.cpp,"[3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 126, 0, 0, 6, 6, 0, 0, 5, 4, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 2, 1, 0, 0, 28, 0, 0, 7, 0, 27, 4, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_817.cpp,26
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1303.cpp,1479,1481,1487,1489,"YY_FATAL_ERROR( ""out of dynamic memory in yy_create_buffer()"" );","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_818.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_818.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_create_buffer()"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_818.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_818.cpp,6
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1303.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1303.cpp,1479,1481,1496,1498,"YY_FATAL_ERROR( ""out of dynamic memory in yy_create_buffer()"" );","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_create_buffer()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_819.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_819.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_create_buffer()"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_819.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_819.cpp,15
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1304.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1304.cpp,1697,1699,1701,1703,"YY_FATAL_ERROR( ""out of dynamic memory in yy_scan_buffer()"" );","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_buffer()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_820.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_820.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_scan_buffer()"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_820.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_820.cpp,12
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1305.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1305.cpp,1746,1748,1750,1752,"YY_FATAL_ERROR( ""out of dynamic memory in yy_scan_bytes()"" );","YY_FATAL_ERROR( ""out of dynamic memory in cmListFileLexer_yy_scan_bytes()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_821.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_821.cpp,"YY_FATAL_ERROR( ""out of dynamic memory in yy_scan_bytes()"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_821.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_821.cpp,11
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1305.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1305.cpp,1746,1748,1759,1761,"YY_FATAL_ERROR( ""bad buffer in yy_scan_bytes()"" );","YY_FATAL_ERROR( ""bad buffer in cmListFileLexer_yy_scan_bytes()"" );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_822.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_822.cpp,"YY_FATAL_ERROR( ""bad buffer in yy_scan_bytes()"" )",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_822.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_822.cpp,20
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1306.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1306.cpp,1883,1885,1891,1893,"yy_fatal_error( ""yyset_lineno called with no buffer"" , yyscanner);","yy_fatal_error( ""cmListFileLexer_yyset_lineno called with no buffer"" , yyscanner);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_823.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_823.cpp,"yy_fatal_error( ""yyset_lineno called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_823.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_823.cpp,6
89a8261f68dd06778e14fc02ccf051489cdb4381,ENH: Mangled lexer symbols to begin in cmListFileLexer_yy instead of just yy to avoid conflict with other lexers that may be added.,[],Source/cmListFileLexer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_653.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_653.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1307.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1307.cpp,1898,1900,1906,1908,"yy_fatal_error( ""yyset_column called with no buffer"" , yyscanner);","yy_fatal_error( ""cmListFileLexer_yyset_column called with no buffer"" , yyscanner);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_824.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_824.cpp,"yy_fatal_error( ""yyset_column called with no buffer"" , yyscanner)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_824.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_824.cpp,6
17619508e9d651f32cbd8d5bfbea6ac94ef975fc,"ENH: Update to the new coverage code. It may not be perfect yet, but it is a start",[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_655.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1309.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1309.cpp,19,19,449,-1,"sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_825.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_825.cpp,"{
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      std::cout << ""Open file: "" << cfileoutputname << std::endl;
      if (!m_CTest->OpenOutputFile(m_CTest->GetCurrentTag(), 
                                   cfileoutputname, cfileoutput))
        {
        std::cerr << ""Cannot open log file: "" << cfileoutputname << std::endl;
        return 1;
        }
      local_start_time = m_CTest->CurrentTime();
      m_CTest->StartXML(cfileoutput);
      cfileoutput << ""<CoverageLog>\n""
        << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_825.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 5, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_825.cpp,408
17619508e9d651f32cbd8d5bfbea6ac94ef975fc,"ENH: Update to the new coverage code. It may not be perfect yet, but it is a start",[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_655.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1309.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1309.cpp,19,19,40,43,,"sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_826.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_826.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_826.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_826.cpp,0
17619508e9d651f32cbd8d5bfbea6ac94ef975fc,"ENH: Update to the new coverage code. It may not be perfect yet, but it is a start",[],Source/CTest/cmCTestCoverageHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_655.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_655.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1309.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1309.cpp,19,19,40,64,,"sprintf(covLogFilename, ""CoverageLog-%d.xml"", logFileCount);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_827.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_827.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_827.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_827.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1310.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1310.cpp,144,152,156,162,"sprintf(output, ""%c%c=="", 
              table64[obuf[0]],
              table64[obuf[1]]);","snprintf(output, 5, ""%c%c=="",
               table64[obuf[0]],
               table64[obuf[1]]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_828.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_828.cpp,"{
    case 1: /* only one byte read */
      sprintf(output, ""%c%c=="", 
              table64[obuf[0]],
              table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      sprintf(output, ""%c%c%c="", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]]);
      break;
    default:
      sprintf(output, ""%c%c%c%c"", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]],
              table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_828.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_828.cpp,39
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1310.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1310.cpp,144,152,161,167,"sprintf(output, ""%c%c%c="", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]]);","snprintf(output, 5, ""%c%c%c="",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_829.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_829.cpp,"{
    case 1: /* only one byte read */
      sprintf(output, ""%c%c=="", 
              table64[obuf[0]],
              table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      sprintf(output, ""%c%c%c="", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]]);
      break;
    default:
      sprintf(output, ""%c%c%c%c"", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]],
              table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_829.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_829.cpp,44
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1310.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1310.cpp,144,152,167,173,"sprintf(output, ""%c%c%c%c"", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]],
              table64[obuf[3]] );","snprintf(output, 5, ""%c%c%c%c"",
               table64[obuf[0]],
               table64[obuf[1]],
               table64[obuf[2]],
               table64[obuf[3]] );",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_830.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_830.cpp,"{
    case 1: /* only one byte read */
      sprintf(output, ""%c%c=="", 
              table64[obuf[0]],
              table64[obuf[1]]);
      break;
    case 2: /* two bytes read */
      sprintf(output, ""%c%c%c="", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]]);
      break;
    default:
      sprintf(output, ""%c%c%c%c"", 
              table64[obuf[0]],
              table64[obuf[1]],
              table64[obuf[2]],
              table64[obuf[3]] );
      break;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_830.cpp,"[0, 0, 0, 0, 3, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 42, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 15, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_830.cpp,50
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1312.cpp,234,234,244,245,,"printf(""0x%02x: "", i);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_831.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_831.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_831.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_831.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1312.cpp,234,234,244,248,,"printf(""%02x "", data[i+j]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_832.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_832.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_832.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_832.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1312.cpp,234,234,244,250,,"printf(""   "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_833.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_833.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_833.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_833.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1312.cpp,234,234,244,252,,"printf("" | "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_834.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_834.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_834.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_834.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/base64.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_656.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_656.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1312.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1312.cpp,234,234,244,256,,"printf(""%c"", isgraph(data[i+j])?data[i+j]:'.');",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_835.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_835.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_835.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_835.cpp,0
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/formdata.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_658.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_658.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_658.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1314.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1314.cpp,1006,780,1042,848,"vsprintf(s, fmt, ap);","vsnprintf(s, sizeof(s), fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_836.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_836.cpp,"{
  char s[4096];
  va_list ap;
  va_start(ap, fmt);
  vsprintf(s, fmt, ap);
  va_end(ap);

  return AddFormData(formp, s, 0);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_836.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_836.cpp,6
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1315.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1315.cpp,770,932,772,934,"sprintf(buf, ""%04d%02d%02d %02d:%02d:%02d"",
                year, month, day, hour, minute, second);","snprintf(buf, sizeof(conn->data->state.buffer),
                 ""%04d%02d%02d %02d:%02d:%02d GMT"",
                 year, month, day, hour, minute, second);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_837.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_837.cpp,"{
        /* we have a time, reformat it */
        time_t secs=time(NULL);
        sprintf(buf, ""%04d%02d%02d %02d:%02d:%02d"",
                year, month, day, hour, minute, second);
        /* now, convert this into a time() value: */
        conn->data->info.filetime = curl_getdate(buf, &secs);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_837.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_837.cpp,26
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1316.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1316.cpp,861,1024,970,-1,"snprintf(nbuf, sizeof(nbuf), ""?"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_838.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_838.cpp,"{
    snprintf(nbuf, sizeof(nbuf), ""?"");
    snprintf(sbuf, sizeof(sbuf), ""?"");
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_838.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_838.cpp,109
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1316.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1316.cpp,861,1024,971,-1,"snprintf(sbuf, sizeof(sbuf), ""?"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_839.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_839.cpp,"{
    snprintf(nbuf, sizeof(nbuf), ""?"");
    snprintf(sbuf, sizeof(sbuf), ""?"");
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_839.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_839.cpp,110
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1318.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1318.cpp,1444,1507,1446,1509,"f(newhost, ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);","f(newhost, sizeof(newhost),
             ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_840.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_840.cpp,"{
    int ip[4];
    int port[2];
    char *str=buf;

    /*
     * New 227-parser June 3rd 1999.
     * It now scans for a sequence of six comma-separated numbers and
     * will take them as IP+port indicators.
     *
     * Found reply-strings include:
     * ""227 Entering Passive Mode (127,0,0,1,4,51)""
     * ""227 Data transfer will passively listen to 127,0,0,1,4,51""
     * ""227 Entering passive mode. 127,0,0,1,4,51""
     */
      
    while(*str) {
      if (6 == sscanf(str, ""%d,%d,%d,%d,%d,%d"",
                      &ip[0], &ip[1], &ip[2], &ip[3],
                      &port[0], &port[1]))
        break;
      str++;
    }

    if(!*str) {
      failf(data, ""Couldn't interpret this 227-reply: %s"", buf);
      return CURLE_FTP_WEIRD_227_FORMAT;
    }

    sprintf(newhost, ""%d.%d.%d.%d"", ip[0], ip[1], ip[2], ip[3]);
    newhostp = newhost;
    newport = (unsigned short)((port[0]<<8) + port[1]);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_840.cpp,"[2, 1, 0, 0, 1, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 49, 0, 0, 3, 3, 0, 0, 1, 19, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 42, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 14, 0, 3, 2, 0, 0, 4, 0, 0, 5, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_840.cpp,92
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_659.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_659.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1319.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1319.cpp,1999,2163,2001,2165,"sprintf(buf, ""Content-Length: %d\r\n"", filesize);","snprintf(buf, sizeof(data->state.buffer),
               ""Content-Length: %"" FORMAT_OFF_T ""\r\n"", filesize);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_841.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_841.cpp,"{
      sprintf(buf, ""Content-Length: %d\r\n"", filesize);
      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_841.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_841.cpp,61
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1321.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1321.cpp,218,297,690,786,"fprintf(stderr, ""Starting parse\n"");","YYFPRINTF (stderr, ""Stack now"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_842.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_842.cpp,"fprintf(stderr, ""Starting parse\n"")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_842.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_842.cpp,47
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1322.cpp,704,1084,796,-1,"fprintf(stderr, ""Stack size increased to %d\n"", yystacksize);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_843.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_843.cpp,"fprintf(stderr, ""Stack size increased to %d\n"", yystacksize)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_843.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_843.cpp,153
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1322.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1322.cpp,704,1084,805,-1,"fprintf(stderr, ""Entering state %d\n"", yystate);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_844.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_844.cpp,"fprintf(stderr, ""Entering state %d\n"", yystate)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_844.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_844.cpp,162
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1323.cpp,816,1182,830,1192,"fprintf(stderr, ""Reading a token: "");","YYDPRINTF ((stderr, ""Reading a token: ""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_845.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_845.cpp,"fprintf(stderr, ""Reading a token: "")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_845.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_845.cpp,187
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1323.cpp,816,1182,844,1199,"fprintf(stderr, ""Now at end of input.\n"");","YYDPRINTF ((stderr, ""Now at end of input.\n""));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_846.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_846.cpp,"fprintf(stderr, ""Now at end of input.\n"")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_846.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_846.cpp,201
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1323.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1323.cpp,816,1182,895,-1,"fprintf(stderr, ""Shifting token %d (%s), "", yychar, yytname[yychar1]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_847.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_847.cpp,"fprintf(stderr, ""Shifting token %d (%s), "", yychar, yytname[yychar1])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_847.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_847.cpp,252
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1324.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1324.cpp,1290,1663,1425,-1,"fprintf(stderr, ""Discarding token %d (%s).\n"", yychar, yytname[yychar1]);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_848.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_848.cpp,"fprintf(stderr, ""Discarding token %d (%s).\n"", yychar, yytname[yychar1])",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_848.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_848.cpp,782
609801fe67c95f9959468df8316a8f4a26943842,ENH: Update Curl to 7.12.1,[],Source/CTest/Curl/getdate.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_660.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_660.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1324.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1324.cpp,1290,1663,1493,1832,"fprintf(stderr, ""Shifting error token, "");","YY_STACK_PRINT (yyss, yyssp);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_849.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_849.cpp,"fprintf(stderr, ""Shifting error token, "")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_849.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_849.cpp,850
6972cdf9e9ca78f9031bd419f48c270bd67c8a71,ENH: Move all extracting of variables to ExtractVariables. This way it is easy to know what variables are used,[],Source/CTest/cmCTestScriptHandler.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_662.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_662.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_662.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1326.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1326.cpp,397,428,403,-1,"sprintf(updateVar,""CTEST_EXTRA_UPDATES_%i"",i);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_850.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_850.cpp,"{
    sprintf(updateVar,""CTEST_EXTRA_UPDATES_%i"",i);
    const char *updateVal = m_Makefile->GetDefinition(updateVar);
    if (updateVal)
      {
      if (m_CVSCmd.empty())
        {
        cmSystemTools::Error(updateVar, "" specified without specifying CTEST_CVS_COMMAND."");
        this->RestoreBackupDirectories();
        return 12;
        }
      std::vector<std::string> cvsArgs;
      cmSystemTools::ExpandListArgument(updateVal,cvsArgs);
      if (cvsArgs.size() == 2)
        {
        std::string fullCommand = command;
        fullCommand += "" update "";
        fullCommand += cvsArgs[1];
        output = """";
        retVal = 0;
        if ( m_Verbose )
          {
          std::cerr << ""Run CVS: "" << fullCommand.c_str() << std::endl;
          }
        res = cmSystemTools::RunSingleCommand(fullCommand.c_str(), &output, 
          &retVal, cvsArgs[0].c_str(),
          m_Verbose, 0 /*m_TimeOut*/);
        if (!res || retVal != 0)
          {
          cmSystemTools::Error(""Unable to perform extra cvs updates:\n"", 
            output.c_str());
          this->RestoreBackupDirectories();
          return 8;
          }
        }
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_850.cpp,"[5, 0, 0, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0, 0, 1, 81, 0, 0, 3, 3, 0, 0, 2, 14, 0, 0, 0, 0, 1, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 5, 5, 0, 0, 15, 0, 0, 12, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_850.cpp,13
a2c19a4d46b82f747d97ad0005887ce44c89af72,"ENH: Condense help string, add support for setting line length and make it work",[],Source/kwsys/CommandLineArguments.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_664.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_664.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_664.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1328.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1328.cpp,539,550,543,556,"sprintf(format, ""%%%ds"", static_cast<unsigned int>(maxlen));","sprintf(format, ""%%%ds  "", static_cast<unsigned int>(maxlen-2));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_851.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_851.cpp,"{
  kwsys_ios::ostringstream str;

  // Collapse all arguments into the map of vectors of all arguments that do
  // the same thing.
  CommandLineArguments::Internal::CallbacksMap::iterator it;
  typedef kwsys_stl::map<CommandLineArguments::Internal::String, 
     CommandLineArguments::Internal::SetOfStrings > MapArgs;
  MapArgs mp;
  MapArgs::iterator mpit, smpit;
  for ( it = this->Internals->Callbacks.begin();
    it != this->Internals->Callbacks.end();
    it ++ )
    {
    CommandLineArgumentsCallbackStructure *cs = &(it->second);
    mpit = mp.find(cs->Help);
    if ( mpit != mp.end() )
      {
      mpit->second.insert(it->first);
      mp[it->first].insert(it->first);
      }
    else
      {
      mp[it->first].insert(it->first);
      }
    }
  for ( it = this->Internals->Callbacks.begin();
    it != this->Internals->Callbacks.end();
    it ++ )
    {
    CommandLineArgumentsCallbackStructure *cs = &(it->second);
    mpit = mp.find(cs->Help);
    if ( mpit != mp.end() )
      {
      mpit->second.insert(it->first);
      smpit = mp.find(it->first);
      CommandLineArguments::Internal::SetOfStrings::iterator sit;
      for ( sit = smpit->second.begin(); sit != smpit->second.end(); sit++ )
        {
        mpit->second.insert(*sit);
        }
      mp.erase(smpit);
      }
    else
      {
      mp[it->first].insert(it->first);
      }
    }
 
  // Find the length of the longest string
  CommandLineArguments::Internal::String::size_type maxlen = 0;
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      CommandLineArguments::Internal::String::size_type clen = sit->size();
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT:     clen += 0; break;
        case CommandLineArguments::CONCAT_ARGUMENT: clen += 6; break;
        case CommandLineArguments::SPACE_ARGUMENT:  clen += 7; break;
        case CommandLineArguments::EQUAL_ARGUMENT:  clen += 7; break;
        }
      if ( clen > maxlen )
        {
        maxlen = clen;
        }
      }
    }

  // Create format for that string
  char format[80];
  sprintf(format, ""%%%ds"", static_cast<unsigned int>(maxlen));


  // Print help for each option
  for ( mpit = mp.begin();
    mpit != mp.end();
    mpit ++ )
    {
    CommandLineArguments::Internal::SetOfStrings::iterator sit;
    for ( sit = mpit->second.begin(); sit != mpit->second.end(); sit++ )
      {
      str << kwsys_ios::endl;
      char argument[100];
      sprintf(argument, sit->c_str());
      switch ( this->Internals->Callbacks[*sit].ArgumentType )
        {
        case CommandLineArguments::NO_ARGUMENT: break;
        case CommandLineArguments::CONCAT_ARGUMENT: strcat(argument, ""option""); break;
        case CommandLineArguments::SPACE_ARGUMENT:  strcat(argument, "" option""); break;
        case CommandLineArguments::EQUAL_ARGUMENT:  strcat(argument, ""=option""); break;
        }
      char buffer[80];
      sprintf(buffer, format, argument);
      str << buffer;
      }
    str << ""\t"";
    const char* ptr = this->Internals->Callbacks[mpit->first].Help;
    int len = strlen(ptr);
    int cnt = 0;
    while ( len > 0)
      {
      // If argument with help is longer than line length, split it on previous
      // space (or tab) and continue on the next line
      CommandLineArguments::Internal::String::size_type cc;
      for ( cc = 0; ptr[cc]; cc ++ )
        {
        if ( *ptr == ' ' || *ptr == '\t' )
          {
          ptr ++;
          len --;
          }
        }
      if ( cnt > 0 )
        {
        for ( cc = 0; cc < maxlen; cc ++ )
          {
          str << "" "";
          }
        str << ""\t"";
        }
      CommandLineArguments::Internal::String::size_type skip = len;
      if ( skip > this->LineLength - maxlen )
        {
        skip = this->LineLength - maxlen;
        for ( cc = skip-1; cc > 0; cc -- )
          {
          if ( ptr[cc] == ' ' || ptr[cc] == '\t' )
            {
            break;
            }
          }
        if ( cc != 0 )
          {
          skip = cc;
          }
        }
      str.write(ptr, skip);
      str << kwsys_ios::endl;
      ptr += skip;
      len -= skip;
      cnt ++;
      }
    }
  this->Help = str.str();
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_851.cpp,"[8, 1, 10, 0, 9, 0, 0, 2, 8, 0, 24, 0, 0, 0, 1, 398, 0, 0, 19, 20, 0, 0, 18, 27, 0, 0, 0, 1, 3, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 192, 0, 136, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 12, 0, 21, 8, 2, 0, 40, 0, 0, 36, 0, 31, 0, 10, 0, 0, 10, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_851.cpp,76
43d8918f4078dc2f99a868b23bcdffabaa739a95,more cleanup of ctest,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1331.cpp,558,472,1039,-1,"sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_852.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_852.cpp,"{
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      std::cout << ""Open file: "" << cfileoutputname << std::endl;
      if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
        {
        std::cerr << ""Cannot open log file: "" << cfileoutputname << std::endl;
        return 1;
        }
      local_start_time = this->CurrentTime();
      this->StartXML(cfileoutput);
      cfileoutput << ""<CoverageLog>\n""
        << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_852.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 6, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_852.cpp,406
43d8918f4078dc2f99a868b23bcdffabaa739a95,more cleanup of ctest,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1331.cpp,558,472,1507,-1,"sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_853.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_853.cpp,"{
      double ttime = clock_finish - clock_start;
      int hours = static_cast<int>(ttime / (60 * 60));
      int minutes = static_cast<int>(ttime / 60) % 60;
      int seconds = static_cast<int>(ttime) % 60;
      char buffer[100];
      sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);
      *olog 
        << ""----------------------------------------------------------""
        << std::endl
        << ""\"""" << testname.c_str() << ""\"" end time: "" 
        << this->CurrentTime() << std::endl
        << ""\"""" << testname.c_str() << ""\"" time elapsed: "" 
        << buffer << std::endl
        << ""----------------------------------------------------------""
        << std::endl << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_853.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 50, 0, 0, 5, 5, 0, 0, 4, 13, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 18, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 10, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_853.cpp,180
43d8918f4078dc2f99a868b23bcdffabaa739a95,more cleanup of ctest,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1331.cpp,558,472,1761,-1,"fprintf(stderr,""\n%.0f%% tests passed, %i tests failed out of %i\n"",
      percent, int(failed.size()), total);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_854.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_854.cpp,"{
    if (m_Verbose && passed.size() && 
      (m_UseIncludeRegExp || m_UseExcludeRegExp)) 
      {
      std::cerr << ""\nThe following tests passed:\n"";
      for(cmCTest::tm_VectorOfStrings::iterator j = passed.begin();
        j != passed.end(); ++j)
        {   
        std::cerr << ""\t"" << *j << ""\n"";
        }
      }

    float percent = float(passed.size()) * 100.0f / total;
    if ( failed.size() > 0 &&  percent > 99)
      {
      percent = 99;
      }
    fprintf(stderr,""\n%.0f%% tests passed, %i tests failed out of %i\n"",
      percent, int(failed.size()), total);

    if (failed.size()) 
      {
      std::ofstream ofs;

      std::cerr << ""\nThe following tests FAILED:\n"";
      this->OpenOutputFile(""Temporary"", ""LastTestsFailed.log"", ofs);

      std::vector<cmCTest::cmCTestTestResult>::iterator ftit;
      for(ftit = m_TestResults.begin();
        ftit != m_TestResults.end(); ++ftit)
        {
        if ( ftit->m_Status != cmCTest::COMPLETED )
          {
          ofs << ftit->m_TestCount << "":"" << ftit->m_Name << std::endl;
          fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));
          }
        }

      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_854.cpp,"[4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 109, 0, 0, 3, 4, 0, 0, 4, 13, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 56, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 4, 0, 0, 17, 0, 0, 8, 0, 17, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_854.cpp,62
43d8918f4078dc2f99a868b23bcdffabaa739a95,more cleanup of ctest,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_666.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_666.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1331.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1331.cpp,558,472,1778,-1,"fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_855.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_855.cpp,"{
          ofs << ftit->m_TestCount << "":"" << ftit->m_Name << std::endl;
          fprintf(stderr, ""\t%3d - %s (%s)\n"", ftit->m_TestCount, ftit->m_Name.c_str(),
            this->GetTestStatus(ftit->m_Status));
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_855.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_855.cpp,79
05d985c08277350c3a1ca5ea6023ac397cf9bf1b,some bug fixes for my recent checkins and some more cleanup,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_667.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_667.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_667.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1332.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1332.cpp,710,719,743,-1,"sprintf(current_time, ""%04d-%02d-%02d %02d:%02d:%02d UTC"",
      t->tm_year + 1900,
      t->tm_mon + 1,
      t->tm_mday,
      t->tm_hour,
      t->tm_min,
      t->tm_sec);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_856.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_856.cpp,"{
    struct tm* t = ::GetNightlyTime(m_DartConfiguration[""NightlyStartTime""],
      m_Verbose,
      m_TomorrowTag);
    char current_time[1024];
    sprintf(current_time, ""%04d-%02d-%02d %02d:%02d:%02d UTC"",
      t->tm_year + 1900,
      t->tm_mon + 1,
      t->tm_mday,
      t->tm_hour,
      t->tm_min,
      t->tm_sec);
    std::string today_update_date = current_time;
   
    extra_update_opts += ""-D \"""" + today_update_date +""\"""";
    //std::cout << ""Update: "" << extra_update_opts << std::endl;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_856.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 40, 0, 0, 3, 3, 0, 0, 2, 7, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_856.cpp,31
1b5b6ab30378d0648eccb66c1fc41a7e8c762dea,starting cleanup of ctest,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_668.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_668.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_668.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1333.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1333.cpp,3602,3598,3946,-1,"sprintf(updateVar,""CTEST_EXTRA_UPDATES_%i"",i);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_857.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_857.cpp,"{
      sprintf(updateVar,""CTEST_EXTRA_UPDATES_%i"",i);
      const char *updateVal = mf->GetDefinition(updateVar);
      if (updateVal)
        {
        std::vector<std::string> cvsArgs;
        cmSystemTools::ExpandListArgument(updateVal,cvsArgs);
        if (cvsArgs.size() == 2)
          {
          std::string fullCommand = command;
          fullCommand += "" update "";
          fullCommand += cvsArgs[1];
          output = """";
          retVal = 0;
          if ( m_Verbose )
            {
            std::cerr << ""Run CVS: "" << fullCommand.c_str() << std::endl;
            }
          res = cmSystemTools::RunSingleCommand(fullCommand.c_str(), &output, 
            &retVal, cvsArgs[0].c_str(),
            m_Verbose, 0 /*m_TimeOut*/);
          if (!res || retVal != 0)
            {
            cmSystemTools::Error(""Unable to perform extra cvs updates:\n"", output.c_str());
            this->RestoreBackupDirectories(backup, srcDir, binDir,
              backupSrcDir.c_str(), 
              backupBinDir.c_str());
            return 8;
            }
          }
        }
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_857.cpp,"[4, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 1, 80, 0, 0, 3, 3, 0, 0, 2, 12, 0, 0, 0, 0, 1, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 0, 4, 4, 0, 0, 14, 0, 0, 10, 0, 20, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_857.cpp,141
66a08c10e5bd4b8eff58837cd58372a4dfdd19df,"ENH: more uniform approach to enable language, one step closer to being able to enable a language without modifing cmake source code",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_669.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_669.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_669.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1334.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1334.cpp,158,158,160,160,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE FORTRAN)\n"");","fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE Fortran)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_858.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_858.cpp,"{
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE FORTRAN)\n"");      
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_858.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_858.cpp,138
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1335.cpp,2156,2156,2158,-1,"fprintf(stderr,""%3d/%3d Testing %-30s\n"", cnt, (int)tmsize, testname.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_859.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_859.cpp,"{
      fprintf(stderr,""%3d/%3d Testing %-30s\n"", cnt, (int)tmsize, testname.c_str());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_859.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_859.cpp,63
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1335.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1335.cpp,2156,2156,2162,-1,"fprintf(stderr,""%3d/%3d Testing %-30s "", cnt, (int)tmsize, testname.c_str());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_860.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_860.cpp,"{
      fprintf(stderr,""%3d/%3d Testing %-30s "", cnt, (int)tmsize, testname.c_str());
      fflush(stderr);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_860.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_860.cpp,67
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1336.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1336.cpp,2279,2293,2281,2295,"fprintf(stderr,""   Passed\n"");","std::cerr <<   ""   Passed\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_861.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_861.cpp,"{
        fprintf(stderr,""   Passed\n"");
        passed.push_back(testname);
        cres.m_Status = cmCTest::COMPLETED;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_861.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_861.cpp,186
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2290,2304,"fprintf(stderr,""***Timeout\n"");","std::cerr << ""***Timeout\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_862.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_862.cpp,"{
          fprintf(stderr,""***Timeout\n"");
          cres.m_Status = cmCTest::TIMEOUT;
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_862.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_862.cpp,195
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2295,2309,"fprintf(stderr,""***Exception: "");","std::cerr << ""***Exception: "";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_863.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_863.cpp,"{
          fprintf(stderr,""***Exception: "");
          switch ( retVal )
            {
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }
          fprintf(stderr,""\n"");
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_863.cpp,"[0, 0, 0, 0, 4, 0, 0, 1, 4, 1, 2, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_863.cpp,200
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2299,2313,"fprintf(stderr,""SegFault"");","std::cerr << ""SegFault"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_864.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_864.cpp,"{
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_864.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_864.cpp,204
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2303,2317,"fprintf(stderr,""Illegal"");","std::cerr << ""Illegal"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_865.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_865.cpp,"{
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_865.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_865.cpp,208
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2307,2321,"fprintf(stderr,""Interrupt"");","std::cerr << ""Interrupt"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_866.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_866.cpp,"{
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_866.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_866.cpp,212
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2311,2325,"fprintf(stderr,""Numerical"");","std::cerr << ""Numerical"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_867.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_867.cpp,"{
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_867.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_867.cpp,216
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2315,2329,"fprintf(stderr,""Other"");","std::cerr << ""Other"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_868.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_868.cpp,"{
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_868.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_868.cpp,220
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2318,2332,"fprintf(stderr,""\n"");","std::cerr << ""\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_869.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_869.cpp,"{
          fprintf(stderr,""***Exception: "");
          switch ( retVal )
            {
          case cmsysProcess_Exception_Fault:
            fprintf(stderr,""SegFault"");
            cres.m_Status = cmCTest::SEGFAULT;
            break;
          case cmsysProcess_Exception_Illegal:
            fprintf(stderr,""Illegal"");
            cres.m_Status = cmCTest::ILLEGAL;
            break;
          case cmsysProcess_Exception_Interrupt:
            fprintf(stderr,""Interrupt"");
            cres.m_Status = cmCTest::INTERRUPT;
            break;
          case cmsysProcess_Exception_Numerical:
            fprintf(stderr,""Numerical"");
            cres.m_Status = cmCTest::NUMERICAL;
            break;
          default:
            fprintf(stderr,""Other"");
            cres.m_Status = cmCTest::OTHER_FAULT;
            }
          fprintf(stderr,""\n"");
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_869.cpp,"[0, 0, 0, 0, 4, 0, 0, 1, 4, 1, 2, 0, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_869.cpp,223
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2322,2336,"fprintf(stderr,""***Bad command %d\n"", res);","std::cerr << ""***Bad command "" << res << ""\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_870.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_870.cpp,"{
          fprintf(stderr,""***Bad command %d\n"", res);
          cres.m_Status = cmCTest::BAD_COMMAND;
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_870.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_870.cpp,227
d2087dfe99d87356462a9a8b6608ca56d6293c5e,"ENH: fixes for RUN_TESTS from visual studio IDE, fprintf does not print right away, so std::cerr had to be used.  Also, allow .\ to start the config type",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_670.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_670.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1337.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1337.cpp,2288,2302,2327,2341,"fprintf(stderr,""***Failed\n"");","std::cerr << ""***Failed\n"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_871.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_871.cpp,"{
          fprintf(stderr,""***Failed\n"");
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_871.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_871.cpp,232
9655299f08b5aa04ea63193ebecfa08efae7ca3d,ENH: initial fortran support,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_671.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_671.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_671.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1338.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1338.cpp,156,156,159,160,,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE FORTRAN)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_872.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_872.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_872.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_872.cpp,0
c19a70b3ada66a59c7a0ff78bf1a4a1cd557db9a,WRN: remove warnings,[],Source/cmMacroCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_674.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_674.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_674.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1343.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1343.cpp,71,71,76,74,"sprintf(argcDef,""%i"",expandedArguments.size());",argcDefStream << expandedArguments.size();,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_873.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_873.cpp,"{
    std::string tmps;
    cmListFileArgument arg;
    std::string variable;
    // Expand the argument list to the macro.
    std::vector<std::string> expandedArguments;
    mf.ExpandArguments(lff.m_Arguments, expandedArguments);

    // make sure the number of arguments passed is at least the number
    // required by the signature
    if (expandedArguments.size() < m_Args.size() - 1)
      {
      cmOStringStream error;
      error << ""Error in cmake code at\n""
            << lff.m_FilePath << "":"" << lff.m_Line << "":\n""
            << ""Invocation of macro \""""
            << lff.m_Name.c_str() << ""\"" with incorrect number of arguments."";
      cmSystemTools::Error(error.str().c_str());
      return true;
      }
    
    // now set the new argcDef
    char argcDef[64];
    sprintf(argcDef,""%i"",expandedArguments.size());    
    
    // Invoke all the functions that were collected in the block.
    cmListFileFunction newLFF;
    for(unsigned int c = 0; c < m_Functions.size(); ++c)
      {
      // Replace the formal arguments and then invoke the command.
      newLFF.m_Arguments.clear();
      newLFF.m_Arguments.reserve(m_Functions[c].m_Arguments.size());
      newLFF.m_Name = m_Functions[c].m_Name;
      newLFF.m_FilePath = m_Functions[c].m_FilePath;
      newLFF.m_Line = m_Functions[c].m_Line;
      for (std::vector<cmListFileArgument>::const_iterator k = 
             m_Functions[c].m_Arguments.begin();
           k != m_Functions[c].m_Arguments.end(); ++k)
        {
        tmps = k->Value;
        // replace formal arguments
        for (unsigned int j = 1; j < m_Args.size(); ++j)
          {
          variable = ""${"";
          variable += m_Args[j];
          variable += ""}""; 
          cmSystemTools::ReplaceString(tmps, variable.c_str(),
                                       expandedArguments[j-1].c_str());
          }
        // replace argc, argv arguments
        for (unsigned int j = 1; j < m_Args.size(); ++j)
          {
          variable = ""${ARGC}"";
          cmSystemTools::ReplaceString(tmps, variable.c_str(),argcDef);
          }
        for (unsigned int j = 1; j < m_Args.size(); ++j)
          {
          // since this could be slow, first check if there is an ARGV
          // only then do the inner loop. PS std::string sucks
          char argvName[60];
          if (tmps.find(""${ARGV"") != std::string::npos)
            {
            for (unsigned int t = 0; t < expandedArguments.size(); ++t)
              {
              sprintf(argvName,""${ARGV%i}"",t);
              cmSystemTools::ReplaceString(tmps, argvName,
                                           expandedArguments[t].c_str());
              }
            }
          }
        
        arg.Value = tmps;
        arg.Quoted = k->Quoted;
        newLFF.m_Arguments.push_back(arg);
        }
      if(!mf.ExecuteCommand(newLFF))
        {
        cmOStringStream error;
        error << ""Error in cmake code at\n""
              << lff.m_FilePath << "":"" << lff.m_Line << "":\n""
              << ""A command failed during the invocation of macro \""""
              << lff.m_Name.c_str() << ""\""."";
        cmSystemTools::Error(error.str().c_str());
        }
      }
    return true;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_873.cpp,"[3, 0, 6, 0, 0, 0, 2, 0, 0, 0, 10, 0, 0, 0, 0, 248, 0, 0, 9, 15, 0, 0, 12, 27, 0, 0, 0, 0, 0, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 11, 0, 9, 3, 0, 0, 36, 0, 0, 23, 0, 25, 0, 6, 0, 0, 6, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_873.cpp,58
824b231f42af0b228040202d3e62c781f5d6c409,ENH: Count tests while they go. Also in the logs report more stuff like elapsed time etc.,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_677.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1347.cpp,1929,1924,1961,2000,"fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());","fprintf(stderr,""%3d/%3d Testing %-30s "", cnt, tmsize, testname.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_874.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_874.cpp,"{
        fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());
        fflush(stderr);
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_874.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_874.cpp,133
824b231f42af0b228040202d3e62c781f5d6c409,ENH: Count tests while they go. Also in the logs report more stuff like elapsed time etc.,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_677.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1347.cpp,1929,1924,1971,1996,,"fprintf(stderr,""%3d/%3d Testing %-30s\n"", cnt, tmsize, testname.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_875.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_875.cpp,"(testCommand == """")
        {
        std::cerr << ""Unable to find executable: "" <<
          args[1].Value.c_str() << ""\n"";
        m_TestResults.push_back( cres ); 
        failed.push_back(args[0].Value);
        continue;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_875.cpp,"[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_875.cpp,143
824b231f42af0b228040202d3e62c781f5d6c409,ENH: Count tests while they go. Also in the logs report more stuff like elapsed time etc.,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_677.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_677.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1347.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1347.cpp,1929,1924,1971,2100,,"sprintf(buffer, ""%02d:%02d:%02d"", hours, minutes, seconds);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_876.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_876.cpp,"(testCommand == """")
        {
        std::cerr << ""Unable to find executable: "" <<
          args[1].Value.c_str() << ""\n"";
        m_TestResults.push_back( cres ); 
        failed.push_back(args[0].Value);
        continue;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_876.cpp,"[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_876.cpp,143
2c2291bbe03aec2dd6637a5311204f09ff6c58ba,"ENH: add new feature to ctest so that it can cmake, build and run a test executable",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_680.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_680.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_680.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1352.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1352.cpp,1961,1962,1963,1964,"fprintf(stderr,""***Bad command\n"");","fprintf(stderr,""***Bad command %d\n"", res);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_877.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_877.cpp,"{
            fprintf(stderr,""***Bad command\n"");
            cres.m_Status = cmCTest::BAD_COMMAND;
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_877.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_877.cpp,203
5dcbef7dfe7e365b1cb2f5881be07bc934df8df5,ENH: Using CreateFile with FILE_FLAG_DELETE_ON_CLOSE to automatically delete the Win9x forwarding executable even if the parent process crashes.,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_684.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_684.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_684.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1356.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1356.cpp,286,289,288,291,"sprintf(fwdName, ""cmw9xfwd_%u_%p.exe"", GetCurrentProcessId(), cp);","sprintf(fwdName, KWSYS_NAMESPACE_STRING ""pew9xfwd_%u_%p.exe"",
            GetCurrentProcessId(), cp);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_878.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_878.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";

    /* We will try putting the executable in the system temp
       directory.  Note that the returned path already has a trailing
       slash.  */
    DWORD length = GetTempPath(_MAX_PATH+1, tempDir);

    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, ""cmw9xfwd_%u_%p.exe"", GetCurrentProcessId(), cp);

    /* If we have a temp directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Allocate a buffer to hold the forwarding executable path.  */
      size_t tdlen = strlen(tempDir);
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }

      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s%s"", tempDir, fwdName);
      }

    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_878.cpp,"[4, 0, 0, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 0, 46, 0, 0, 4, 4, 0, 0, 4, 12, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 4, 4, 1, 0, 12, 0, 0, 7, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_878.cpp,44
ad8bc4b1a43dd017d361f189ec2b38d97e7de987,ENH: Merged changes from KWSys-MultiProcess-bp to KWSys-MultiProcess-b2t-1-mp to main tree.  This introduces support for process pipelines.,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_687.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_687.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_687.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1361.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1361.cpp,698,779,771,-1,"sprintf(cp->RealCommand, ""%s %p %p %d %s"", cp->Win9x,
            cp->Pipe[CMPE_PIPE_ERROR].Write, cp->Win9xKillEvent,
            cp->HideWindow, cp->Command);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_879.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_879.cpp,"{
    /* Windows 9x */
    
    /* The forwarding executable is given a handle to the error pipe
       and a handle to the kill event.  */
    cp->RealCommand = malloc(strlen(cp->Win9x)+strlen(cp->Command)+100);
    sprintf(cp->RealCommand, ""%s %p %p %d %s"", cp->Win9x,
            cp->Pipe[CMPE_PIPE_ERROR].Write, cp->Win9xKillEvent,
            cp->HideWindow, cp->Command);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_879.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 33, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_879.cpp,75
3bbe95397a1331d52d53f66ab4a12baf63c02860,"ENH: Fix verbose output, fix error message, and fix the exit code check",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1366.cpp,1772,1772,1774,1774,"fprintf(stderr,""SegFault"");","fprintf(stderr,""Illegal"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_880.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_880.cpp,"{
              case cmsysProcess_Exception_Fault:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::SEGFAULT;
                break;
              case cmsysProcess_Exception_Illegal:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::ILLEGAL;
                break;
              case cmsysProcess_Exception_Interrupt:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::INTERRUPT;
                break;
              case cmsysProcess_Exception_Numerical:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::NUMERICAL;
                break;
              default:
                fprintf(stderr,""Other"");
                cres.m_Status = cmCTest::OTHER_FAULT;
                }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_880.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_880.cpp,159
3bbe95397a1331d52d53f66ab4a12baf63c02860,"ENH: Fix verbose output, fix error message, and fix the exit code check",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1366.cpp,1772,1772,1778,1778,"fprintf(stderr,""SegFault"");","fprintf(stderr,""Interrupt"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_881.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_881.cpp,"{
              case cmsysProcess_Exception_Fault:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::SEGFAULT;
                break;
              case cmsysProcess_Exception_Illegal:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::ILLEGAL;
                break;
              case cmsysProcess_Exception_Interrupt:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::INTERRUPT;
                break;
              case cmsysProcess_Exception_Numerical:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::NUMERICAL;
                break;
              default:
                fprintf(stderr,""Other"");
                cres.m_Status = cmCTest::OTHER_FAULT;
                }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_881.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_881.cpp,163
3bbe95397a1331d52d53f66ab4a12baf63c02860,"ENH: Fix verbose output, fix error message, and fix the exit code check",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_690.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_690.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1366.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1366.cpp,1772,1772,1782,1782,"fprintf(stderr,""SegFault"");","fprintf(stderr,""Numerical"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_882.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_882.cpp,"{
              case cmsysProcess_Exception_Fault:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::SEGFAULT;
                break;
              case cmsysProcess_Exception_Illegal:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::ILLEGAL;
                break;
              case cmsysProcess_Exception_Interrupt:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::INTERRUPT;
                break;
              case cmsysProcess_Exception_Numerical:
                fprintf(stderr,""SegFault"");
                cres.m_Status = cmCTest::NUMERICAL;
                break;
              default:
                fprintf(stderr,""Other"");
                cres.m_Status = cmCTest::OTHER_FAULT;
                }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_882.cpp,"[0, 0, 0, 0, 4, 0, 0, 0, 4, 1, 1, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 10, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_882.cpp,167
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1754,1797,"fprintf(stderr,""***Failed\n"");","fprintf(stderr,""***Failed\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_883.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_883.cpp,"{
            fprintf(stderr,""***Failed\n"");
            if (output != """")
              {
              if (dartStuff.find(output.c_str()))
                {
                std::string dartString = dartStuff.match(1);
                cmSystemTools::ReplaceString(output, dartString.c_str(),"""");
                cres.m_RegressionImages = this->GenerateRegressionImages(dartString);
                }
              if (output != """" && m_Verbose)
                {
                std::cerr << output.c_str() << ""\n"";
                }
              }
            failed.push_back(args[0].Value); 
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_883.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 3, 3, 0, 0, 9, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_883.cpp,139
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1772,1754,"fprintf(stderr,""   Passed\n"");","fprintf(stderr,""   Passed\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_884.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_884.cpp,"{
            fprintf(stderr,""   Passed\n"");
            if (output != """")
              {
              if (dartStuff.find(output.c_str()))
                {
                std::string dartString = dartStuff.match(1);
                cmSystemTools::ReplaceString(output, dartString.c_str(),"""");
                cres.m_RegressionImages = this->GenerateRegressionImages(dartString);
                }
              if (output != """" && m_Verbose)
                {
                std::cerr << output.c_str() << ""\n"";
                }
              }
            passed.push_back(args[0].Value); 
            }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_884.cpp,"[3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 44, 0, 0, 1, 1, 0, 0, 1, 7, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 3, 3, 0, 0, 9, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_884.cpp,157
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1761,,"fprintf(stderr,""***Timeout\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_885.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_885.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_885.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_885.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1766,,"fprintf(stderr,""***Exception: "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_886.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_886.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_886.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_886.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1770,,"fprintf(stderr,""SegFault"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_887.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_887.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_887.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_887.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1774,,"fprintf(stderr,""SegFault"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_888.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_888.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_888.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_888.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1778,,"fprintf(stderr,""SegFault"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_889.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_889.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_889.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_889.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1782,,"fprintf(stderr,""SegFault"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_890.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_890.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_890.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_890.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1786,,"fprintf(stderr,""Other"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_891.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_891.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_891.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_891.cpp,0
cbeeaa71880c565226efeab605e0492eb1806e66,ENH: Better error reporting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_691.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_691.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1367.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1367.cpp,1750,1750,1771,1792,,"fprintf(stderr,""***Bad command\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_892.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_892.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_892.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_892.cpp,0
beda09a96b2139a5e22f7f78c4cdff7783669d99,ENH: Made error message consistent between win9x and non-win9x version of error reporting.,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_692.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_692.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_692.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1368.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1368.cpp,1261,1266,1286,1271,"_snprintf(cp->ErrorMessage, CMPE_PIPE_BUFFER_SIZE,
                ""Process execution failed with error 0x%X.  ""
                ""FormatMessage failed with error 0x%X."",
                original, GetLastError());","_snprintf(cp->ErrorMessage, CMPE_PIPE_BUFFER_SIZE,
                ""Process execution failed with error 0x%X.  ""
                ""FormatMessage failed with error 0x%X"",
                original, GetLastError());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_893.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_893.cpp,"{
      /* FormatMessage failed.  Use a default message.  */
      _snprintf(cp->ErrorMessage, CMPE_PIPE_BUFFER_SIZE,
                ""Process execution failed with error 0x%X.  ""
                ""FormatMessage failed with error 0x%X."",
                original, GetLastError());
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_893.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_893.cpp,36
8d22e9f70a1653fc6620cc8b5389d1036ec27596,ENH: On windows and apple handle lowercase/upercase file name problem,[],Source/cmGlob.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_696.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_696.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_696.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1373.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1373.cpp,51,52,53,56,,"sprintf(buffer, ""%c"", tolower(ch));",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_894.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_894.cpp,"{
    sprintf(buffer, ""%c"", ch);
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_894.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_894.cpp,11
36880845b66fbe9062fb9e72b703a14dfb2c2036,ERR: Using strncpy instead of snprintf for portability.,[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_697.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_697.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_697.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1374.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1374.cpp,526,526,528,528,"snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
               ""%s"", strerror(errno));","strncpy(cp->ErrorMessage, strerror(errno), KWSYSPE_PIPE_BUFFER_SIZE);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_895.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_895.cpp,"{
      /* Select returned an error.  Leave the error description in the
         pipe buffer.  */
      snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE,
               ""%s"", strerror(errno));
      
      /* Kill the child now.  */
      kwsysProcess_Kill(cp);
      cp->Killed = 0;
      cp->ChildError = 1;
      cp->PipesLeft = 0;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_895.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 5, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_895.cpp,145
36880845b66fbe9062fb9e72b703a14dfb2c2036,ERR: Using strncpy instead of snprintf for portability.,[],Source/kwsys/ProcessUNIX.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_697.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_697.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_697.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1375.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1375.cpp,730,729,732,731,"snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE, ""%s"", strerror(errno));","strncpy(cp->ErrorMessage, strerror(errno), KWSYSPE_PIPE_BUFFER_SIZE);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_896.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_896.cpp,"{
    snprintf(cp->ErrorMessage, KWSYSPE_PIPE_BUFFER_SIZE, ""%s"", strerror(errno));
    cp->State = kwsysProcess_State_Error;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_896.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_896.cpp,7
ef76ed76f8a31f706ee675160e5c57c34b608516,ENH: Added DLL support.,[],Source/kwsys/EncodeExecutable.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_700.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_700.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_700.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1378.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1378.cpp,50,50,54,53,,"fprintf(ofp, ""#include <stdio.h>\n\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_897.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_897.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_897.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_897.cpp,0
ef5214c6c52d81df38923feefd147dccb18200be,ERR: Using GetCurrentProcessId instead of _getpid so we don't need to include the system process.h header.  Also creating pipe threads with 1K stacks to save memory.,[],Source/kwsys/ProcessWin32.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_702.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_702.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_702.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1380.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1380.cpp,234,233,236,235,"sprintf(fwdName, ""cmw9xfwd_%u_%p.exe"", _getpid(), cp);","sprintf(fwdName, ""cmw9xfwd_%u_%p.exe"", GetCurrentProcessId(), cp);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_898.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_898.cpp,"{
    /* This is Win9x.  We need the console forwarding executable to
       work-around a Windows 9x bug.  */
    char fwdName[_MAX_FNAME+1] = """";
    char tempDir[_MAX_PATH+1] = """";
    
    /* We will try putting the executable in the system temp
       directory.  */
    DWORD length = GetEnvironmentVariable(""TEMP"", tempDir, _MAX_PATH);
    
    /* Construct the executable name from the process id and kwsysProcess
       instance.  This should be unique.  */
    sprintf(fwdName, ""cmw9xfwd_%u_%p.exe"", _getpid(), cp);
    
    /* If the environment variable ""TEMP"" gave us a directory, use it.  */
    if(length > 0 && length <= _MAX_PATH)
      {
      /* Make sure there is no trailing slash.  */
      size_t tdlen = strlen(tempDir);
      if(tempDir[tdlen-1] == '/' || tempDir[tdlen-1] == '\\')
        {
        tempDir[tdlen-1] = 0;
        --tdlen;
        }
      
      /* Allocate a buffer to hold the forwarding executable path.  */
      win9x = (char*)malloc(tdlen + strlen(fwdName) + 2);
      if(!win9x)
        {
        kwsysProcess_Delete(cp);
        return 0;
        }
      
      /* Construct the full path to the forwarding executable.  */
      sprintf(win9x, ""%s/%s"", tempDir, fwdName);
      }
    
    /* If we found a place to put the forwarding executable, try to
       write it. */
    if(win9x)
      {
      if(!kwsysEncodedWriteArrayProcessFwd9x(win9x))
        {
        /* Failed to create forwarding executable.  Give up.  */
        free(win9x);
        kwsysProcess_Delete(cp);
        return 0;
        }
      }
    else
      {
      /* Failed to find a place to put forwarding executable.  */
      kwsysProcess_Delete(cp);
      return 0;
      }
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_898.cpp,"[5, 0, 0, 0, 0, 0, 3, 0, 0, 0, 7, 0, 0, 0, 0, 56, 0, 0, 4, 4, 0, 0, 4, 18, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 0, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5, 0, 5, 5, 1, 0, 12, 0, 0, 9, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_898.cpp,38
7f48313225537a7bcc92c0f1c73754bdc50a2ca4,"Remove nan and inf, use iostreams to set precision, fix file name, and remove bogus files",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_709.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_709.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_709.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1388.cpp,1428,1437,1439,-1,"sprintf(cmbuff, ""%.2f"", cmet);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_899.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_899.cpp,"{
    if ( ccount == 100 )
      {
      local_end_time = ::CurrentTime();
      cfileoutput << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>\n""
        << ""</CoverageLog>\n""
        << ""</Site>"" << std::endl;
      cfileoutput.close();
      std::cout << ""Close file: "" << cfileoutputname << std::endl;
      ccount = 0;
      }
    if ( ccount == 0 )
      {
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      std::cout << ""Open file: "" << cfileoutputname << std::endl;
      if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
        {
        std::cout << ""Cannot open log file: "" << cfileoutputname << std::endl;
        return 1;
        }
      local_start_time = ::CurrentTime();
      cfileoutput << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
        << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
        << ""\"" BuildStamp=\"""" << m_CurrentTag << ""-""
        << this->GetTestModelString() << ""\"" Site=\""""
        << m_DartConfiguration[""Site""] << ""\"">\n""
        << ""<CoverageLog>\n""
        << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
      }

    //std::cerr << ""Final process of Source file: "" << cit->first << std::endl;
    cmCTest::cmCTestCoverage &cov = cit->second;


    std::ifstream ifile(cov.m_AbsolutePath.c_str());
    if ( !ifile )
      {
      std::cerr << ""Cannot open file: "" << cov.m_FullPath.c_str() << std::endl;
      }
    ifile.seekg (0, std::ios::end);
    int length = ifile.tellg();
    ifile.seekg (0, std::ios::beg);
    char *buffer = new char [ length + 1 ];
    ifile.read(buffer, length);
    buffer [length] = 0;
    //std::cout << ""Read: "" << buffer << std::endl;
    std::vector<cmStdString> lines;
    cmSystemTools::Split(buffer, lines);
    delete [] buffer;
    cfileoutput << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\""""
      << cov.m_FullPath << std::endl << ""\"">\n""
      << ""\t\t<Report>"" << std::endl;
    for ( cc = 0; cc < lines.size(); cc ++ )
      {
      cfileoutput << ""\t\t<Line Number=\"""" 
        << static_cast<int>(cc) << ""\"" Count=\""""
        << cov.m_Lines[cc] << ""\"">""
        << cmCTest::MakeXMLSafe(lines[cc]) << ""</Line>"" << std::endl;
      }
    cfileoutput << ""\t\t</Report>\n""
      << ""\t</File>"" << std::endl;


    total_tested += cov.m_Tested;
    total_untested += cov.m_UnTested;
    float cper = 0;
    float cmet = 0;
    if ( total_tested + total_untested > 0 )
      {
      cper = (100 * static_cast<float>(cov.m_Tested)/
        static_cast<float>(cov.m_Tested + cov.m_UnTested));
      cmet = ( static_cast<float>(cov.m_Tested + 10) /
        static_cast<float>(cov.m_Tested + cov.m_UnTested + 10));
      }
    char cmbuff[100];
    char cpbuff[100];
    sprintf(cmbuff, ""%.2f"", cmet);
    sprintf(cpbuff, ""%.2f"", cper);

    log << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\"""" << cov.m_FullPath
      << ""\"" Covered=\"""" << (cmet>0?""true"":""false"") << ""\"">\n""
      << ""\t\t<LOCTested>"" << cov.m_Tested << ""</LOCTested>\n""
      << ""\t\t<LOCUnTested>"" << cov.m_UnTested << ""</LOCUnTested>\n""
      << ""\t\t<PercentCoverage>"" << cpbuff << ""</PercentCoverage>\n""
      << ""\t\t<CoverageMetric>"" << cmbuff << ""</CoverageMetric>\n""
      << ""\t</File>"" << std::endl;
    ccount ++;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_899.cpp,"[5, 0, 1, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 239, 0, 0, 9, 9, 0, 0, 6, 65, 0, 0, 0, 0, 2, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 1, 86, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 7, 6, 1, 0, 29, 0, 0, 28, 0, 33, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_899.cpp,356
7f48313225537a7bcc92c0f1c73754bdc50a2ca4,"Remove nan and inf, use iostreams to set precision, fix file name, and remove bogus files",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_709.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_709.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_709.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1388.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1388.cpp,1428,1437,1440,1454,"sprintf(cpbuff, ""%.2f"", cper);","log << FIXNUM(cper) << ""</PercentCoverage>\n""
      << ""\t\t<CoverageMetric>"";;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_900.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_900.cpp,"{
    if ( ccount == 100 )
      {
      local_end_time = ::CurrentTime();
      cfileoutput << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>\n""
        << ""</CoverageLog>\n""
        << ""</Site>"" << std::endl;
      cfileoutput.close();
      std::cout << ""Close file: "" << cfileoutputname << std::endl;
      ccount = 0;
      }
    if ( ccount == 0 )
      {
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      std::cout << ""Open file: "" << cfileoutputname << std::endl;
      if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
        {
        std::cout << ""Cannot open log file: "" << cfileoutputname << std::endl;
        return 1;
        }
      local_start_time = ::CurrentTime();
      cfileoutput << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
        << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
        << ""\"" BuildStamp=\"""" << m_CurrentTag << ""-""
        << this->GetTestModelString() << ""\"" Site=\""""
        << m_DartConfiguration[""Site""] << ""\"">\n""
        << ""<CoverageLog>\n""
        << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
      }

    //std::cerr << ""Final process of Source file: "" << cit->first << std::endl;
    cmCTest::cmCTestCoverage &cov = cit->second;


    std::ifstream ifile(cov.m_AbsolutePath.c_str());
    if ( !ifile )
      {
      std::cerr << ""Cannot open file: "" << cov.m_FullPath.c_str() << std::endl;
      }
    ifile.seekg (0, std::ios::end);
    int length = ifile.tellg();
    ifile.seekg (0, std::ios::beg);
    char *buffer = new char [ length + 1 ];
    ifile.read(buffer, length);
    buffer [length] = 0;
    //std::cout << ""Read: "" << buffer << std::endl;
    std::vector<cmStdString> lines;
    cmSystemTools::Split(buffer, lines);
    delete [] buffer;
    cfileoutput << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\""""
      << cov.m_FullPath << std::endl << ""\"">\n""
      << ""\t\t<Report>"" << std::endl;
    for ( cc = 0; cc < lines.size(); cc ++ )
      {
      cfileoutput << ""\t\t<Line Number=\"""" 
        << static_cast<int>(cc) << ""\"" Count=\""""
        << cov.m_Lines[cc] << ""\"">""
        << cmCTest::MakeXMLSafe(lines[cc]) << ""</Line>"" << std::endl;
      }
    cfileoutput << ""\t\t</Report>\n""
      << ""\t</File>"" << std::endl;


    total_tested += cov.m_Tested;
    total_untested += cov.m_UnTested;
    float cper = 0;
    float cmet = 0;
    if ( total_tested + total_untested > 0 )
      {
      cper = (100 * static_cast<float>(cov.m_Tested)/
        static_cast<float>(cov.m_Tested + cov.m_UnTested));
      cmet = ( static_cast<float>(cov.m_Tested + 10) /
        static_cast<float>(cov.m_Tested + cov.m_UnTested + 10));
      }
    char cmbuff[100];
    char cpbuff[100];
    sprintf(cmbuff, ""%.2f"", cmet);
    sprintf(cpbuff, ""%.2f"", cper);

    log << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\"""" << cov.m_FullPath
      << ""\"" Covered=\"""" << (cmet>0?""true"":""false"") << ""\"">\n""
      << ""\t\t<LOCTested>"" << cov.m_Tested << ""</LOCTested>\n""
      << ""\t\t<LOCUnTested>"" << cov.m_UnTested << ""</LOCUnTested>\n""
      << ""\t\t<PercentCoverage>"" << cpbuff << ""</PercentCoverage>\n""
      << ""\t\t<CoverageMetric>"" << cmbuff << ""</CoverageMetric>\n""
      << ""\t</File>"" << std::endl;
    ccount ++;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_900.cpp,"[5, 0, 1, 0, 0, 0, 1, 0, 0, 0, 7, 0, 0, 0, 0, 239, 0, 0, 9, 9, 0, 0, 6, 65, 0, 0, 0, 0, 2, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 1, 86, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 9, 0, 7, 6, 1, 0, 29, 0, 0, 28, 0, 33, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_900.cpp,357
a956b8c68c37eaa924ce3cfd57db2b7ec410a2b1,Some cov improvements and better esc,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_710.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_710.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_710.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1389.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1389.cpp,168,168,172,172,"sprintf(buffer, ""&gt;&lt;"");","sprintf(buffer, ""&gt;%d&lt;"", (int)ch);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_901.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_901.cpp,"{
      sprintf(buffer, ""&gt;&lt;"");
      //sprintf(buffer, ""&#x%0x;"", (unsigned int)ch);
      ost << buffer;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_901.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_901.cpp,10
394149a03420c2160b4150f9481f82be27ba69a9,"Fix cov. problems, ignore nonascii char. Propagate verbosity",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_711.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1390.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1390.cpp,167,167,172,172,"sprintf(buffer, ""&%x"", (int)ch);","sprintf(buffer, ""&gt;&lt;"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_902.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_902.cpp,"{
      sprintf(buffer, ""&%x"", (int)ch);
      ost << buffer;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_902.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_902.cpp,10
394149a03420c2160b4150f9481f82be27ba69a9,"Fix cov. problems, ignore nonascii char. Propagate verbosity",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_711.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1391.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1391.cpp,1307,1320,1309,-1,"sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_903.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_903.cpp,"{
  std::cout << ""Performing coverage"" << std::endl;
  std::vector<std::string> files;
  std::vector<std::string> cfiles;
  std::vector<std::string> cdirs;
  bool done = false;
  std::string::size_type cc;
  std::string glob;
  std::map<std::string, std::string> allsourcefiles;
  std::map<std::string, std::string> allbinaryfiles;

  std::string start_time = ::CurrentTime();

  // Find all source files.
  std::string sourceDirectory = m_DartConfiguration[""SourceDirectory""];
  if ( sourceDirectory.size() == 0 )
    {
    std::cerr << ""Cannot find SourceDirectory  key in the DartConfiguration.tcl"" << std::endl;
    return 1;
    }
  cdirs.push_back(sourceDirectory);
  while ( !done ) 
    {
    if ( cdirs.size() <= 0 )
      {
      break;
      }
    glob = cdirs[cdirs.size()-1] + ""/*"";
    //std::cout << ""Glob: "" << glob << std::endl;
    cdirs.pop_back();
    if ( cmSystemTools::SimpleGlob(glob, cfiles, 1) )
      {
      for ( cc = 0; cc < cfiles.size(); cc ++ )
        {
        allsourcefiles[cmSystemTools::GetFilenameName(cfiles[cc])] = cfiles[cc];
        }
      }
    if ( cmSystemTools::SimpleGlob(glob, cfiles, -1) )
      {
      for ( cc = 0; cc < cfiles.size(); cc ++ )
        {
        if ( cfiles[cc] != ""."" && cfiles[cc] != "".."" )
          {
          cdirs.push_back(cfiles[cc]);
          }
        }
      }
    }

  // find all binary files
  cdirs.push_back(cmSystemTools::GetCurrentWorkingDirectory());
  while ( !done ) 
    {
    if ( cdirs.size() <= 0 )
      {
      break;
      }
    glob = cdirs[cdirs.size()-1] + ""/*"";
    //std::cout << ""Glob: "" << glob << std::endl;
    cdirs.pop_back();
    if ( cmSystemTools::SimpleGlob(glob, cfiles, 1) )
      {
      for ( cc = 0; cc < cfiles.size(); cc ++ )
        {
        allbinaryfiles[cmSystemTools::GetFilenameName(cfiles[cc])] = cfiles[cc];
        }
      }
    if ( cmSystemTools::SimpleGlob(glob, cfiles, -1) )
      {
      for ( cc = 0; cc < cfiles.size(); cc ++ )
        {
        if ( cfiles[cc] != ""."" && cfiles[cc] != "".."" )
          {
          cdirs.push_back(cfiles[cc]);
          }
        }
      }
    }

  std::map<std::string, std::string>::iterator sit;
  for ( sit = allbinaryfiles.begin(); sit != allbinaryfiles.end(); sit ++ )
    {
    const std::string& fname = sit->second;
    //std::cout << ""File: "" << fname << std::endl;
    if ( strcmp(fname.substr(fname.size()-3, 3).c_str(), "".da"") == 0 )
      {
      files.push_back(fname);
      }
    }
  
  if ( files.size() == 0 )
    {
    std::cout << ""Cannot find any coverage information files (.da)"" << std::endl;
    return 1;
    }

  std::ofstream log; 
  if (!this->OpenOutputFile(""Coverage"", ""Coverage.log"", log))
    {
    std::cout << ""Cannot open log file"" << std::endl;
    return 1;
    }
  log.close();
  if (!this->OpenOutputFile(m_CurrentTag, ""Coverage.xml"", log))
    {
    std::cout << ""Cannot open log file"" << std::endl;
    return 1;
    }

  std::string opath = m_ToplevelPath + ""/Testing/"" + m_CurrentTag + ""/Coverage"";
  
  for ( cc = 0; cc < files.size(); cc ++ )
    {
    std::string command = ""gcov -l \"""" + files[cc] + ""\"""";
    std::string output;
    int retVal = 0;
    //std::cout << ""Run gcov on "" << files[cc] << std::flush;
    bool res = true;
    if ( !m_ShowOnly )
      {
      res = cmSystemTools::RunCommand(command.c_str(), output, 
                                      retVal, opath.c_str(),
                                      m_Verbose);
      }
    if ( res && retVal == 0 )
      {
      //std::cout << "" - done"" << std::endl;
      }
    else
      {
      //std::cout << "" - fail"" << std::endl;
      }
    }
  
  files.clear();
  glob = opath + ""/*"";
  if ( !cmSystemTools::SimpleGlob(glob, cfiles, 1) )
    {
    std::cout << ""Cannot found any coverage files"" << std::endl;
    return 1;
    }
  std::map<std::string, std::vector<std::string> > sourcefiles;
  for ( cc = 0; cc < cfiles.size(); cc ++ )
    {
    std::string& fname = cfiles[cc];
    //std::cout << ""File: "" << fname << std::endl;
    if ( strcmp(fname.substr(fname.size()-5, 5).c_str(), "".gcov"") == 0 )
      {
      files.push_back(fname);
      std::string::size_type pos = fname.find("".da."");
      if ( pos != fname.npos )
        {
        pos += 4;
        std::string::size_type epos = fname.size() - pos - strlen("".gcov"");
        std::string nf = fname.substr(pos, epos);
        //std::cout << ""Substring: "" << nf << std::endl;
        if ( allsourcefiles.find(nf) != allsourcefiles.end() || 
             allbinaryfiles.find(nf) != allbinaryfiles.end() )
          {
          std::vector<std::string> &cvec = sourcefiles[nf];
          cvec.push_back(fname);
          }
        }
      }
    }
  for ( cc = 0; cc < files.size(); cc ++ )
    {
    //std::cout << ""File: "" << files[cc] << std::endl;
    }

  std::map<std::string, std::vector<std::string> >::iterator it;
  cmCTest::tm_CoverageMap coverageresults;

  log << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
      << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
      << ""\"" BuildStamp=\"""" << m_CurrentTag << ""-""
      << this->GetTestModelString() << ""\"" Name=\""""
      << m_DartConfiguration[""Site""] << ""\"">\n""
      << ""<Coverage>\n""
      << ""\t<StartDateTime>"" << start_time << ""</StartDateTime>"" << std::endl;

  int total_tested = 0;
  int total_untested = 0;

  for ( it = sourcefiles.begin(); it != sourcefiles.end(); it ++ )
    {
    //std::cerr << ""Source file: "" << it->first << std::endl;
    std::vector<std::string> &gfiles = it->second;
    for ( cc = 0; cc < gfiles.size(); cc ++ )
      {
      //std::cout << ""\t"" << gfiles[cc] << std::endl;
      std::ifstream ifile(gfiles[cc].c_str());
      ifile.seekg (0, std::ios::end);
      int length = ifile.tellg();
      ifile.seekg (0, std::ios::beg);
      char *buffer = new char [ length + 1 ];
      ifile.read(buffer, length);
      buffer [length] = 0;
      //std::cout << ""Read: "" << buffer << std::endl;
      std::vector<cmStdString> lines;
      cmSystemTools::Split(buffer, lines);
      delete [] buffer;
      cmCTest::cmCTestCoverage& cov = coverageresults[it->first];
      std::vector<int>& covlines = cov.m_Lines; 
      if ( cov.m_FullPath == """" )
        {
        covlines.insert(covlines.begin(), lines.size(), -1);
        if ( allsourcefiles.find(it->first) != allsourcefiles.end() )
          {
          cov.m_FullPath = allsourcefiles[it->first];
          }
        else if ( allbinaryfiles.find(it->first) != allbinaryfiles.end() )
          {
          cov.m_FullPath = allbinaryfiles[it->first];
          }
        //std::cerr << ""Full path: "" << cov.m_FullPath << std::endl;
        }
      for ( cc = 0; cc < lines.size(); cc ++ )
        {
        std::string& line = lines[cc];
        std::string sub = line.substr(0, strlen(""      ######""));
        int count = atoi(sub.c_str());
        if ( sub.compare(""      ######"") == 0 )
          {
          if ( covlines[cc] == -1 )
            {
            covlines[cc] = 0;
            }
          cov.m_UnTested ++;
          //std::cout << ""Untested - "";
          }
        else if ( count > 0 )
          {
          if ( covlines[cc] == -1 )
            {
            covlines[cc] = 0;
            }
          cov.m_Tested ++;
          covlines[cc] += count;
          //std::cout << ""Tested["" << count << ""] - "";
          }

        //std::cout << line << std::endl;
        }
      }
    }

  //std::cerr << ""Finalizing"" << std::endl;
  cmCTest::tm_CoverageMap::iterator cit;
  int ccount = 0;
  std::ofstream cfileoutput; 
  int cfileoutputcount = 0;
  char cfileoutputname[100];
  sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
  if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
    {
    std::cout << ""Cannot open log file"" << std::endl;
    return 1;
    }
  std::string local_start_time = ::CurrentTime();
  std::string local_end_time;
  for ( cit = coverageresults.begin(); cit != coverageresults.end(); cit ++ )
    {
    if ( ccount == 100 )
      {
      local_end_time = ::CurrentTime();
      cfileoutput << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>\n""
                  << ""</CoverageLog>\n""
                  << ""</Site>"" << std::endl;
      cfileoutput.close();
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
        {
        std::cout << ""Cannot open log file"" << std::endl;
        return 1;
        }
      ccount = 0;
      }

    if ( ccount == 0 )
      {
      local_start_time = ::CurrentTime();
      cfileoutput << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
                  << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
                  << ""\"" BuildStamp=\"""" << m_CurrentTag << ""-""
                  << this->GetTestModelString() << ""\"" Name=\""""
                  << m_DartConfiguration[""Site""] << ""\"">\n""
                  << ""<CoverageLog>\n""
                  << ""\t<StartDateTime>"" << local_start_time << ""</StartDateTime>"" << std::endl;
      }

    //std::cerr << ""Final process of Source file: "" << cit->first << std::endl;
    cmCTest::cmCTestCoverage &cov = cit->second;


    std::ifstream ifile(cov.m_FullPath.c_str());
    ifile.seekg (0, std::ios::end);
    int length = ifile.tellg();
    ifile.seekg (0, std::ios::beg);
    char *buffer = new char [ length + 1 ];
    ifile.read(buffer, length);
    buffer [length] = 0;
    //std::cout << ""Read: "" << buffer << std::endl;
    std::vector<cmStdString> lines;
    cmSystemTools::Split(buffer, lines);
    delete [] buffer;
    cfileoutput << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\""""
                << cov.m_FullPath << std::endl << ""\"">\n""
                << ""\t\t<Report>"" << std::endl;
    for ( cc = 0; cc < lines.size(); cc ++ )
      {
      cfileoutput << ""\t\t<Line Number=\"""" 
                  << static_cast<int>(cc) << ""\"" Count=\""""
                  << cov.m_Lines[cc] << ""\"">""
                  << lines[cc] << ""</Line>"" << std::endl;
      }
    cfileoutput << ""\t\t</Report>\n""
                << ""\t</File>"" << std::endl;


    total_tested += cov.m_Tested;
    total_untested += cov.m_UnTested;
    float cper = 0;
    float cmet = 0;
    if ( total_tested + total_untested > 0 )
      {
      cper = (100 * static_cast<float>(cov.m_Tested)/
              static_cast<float>(cov.m_Tested + cov.m_UnTested));
      cmet = ( static_cast<float>(cov.m_Tested + 10) /
               static_cast<float>(cov.m_Tested + cov.m_UnTested + 10));
      }
    log << ""\t<File Name=\"""" << cit->first << ""\"" FullPath=\"""" << cov.m_FullPath
        << ""\"" Covered=\"""" << cov.m_Covered << ""\"">\n""
        << ""\t\t<LOCTested>"" << cov.m_Tested << ""</LOCTested>\n""
        << ""\t\t<LOCUnTested>"" << cov.m_UnTested << ""</LOCUnTested>\n""
        << ""\t\t<PercentCoverage>"" << cper << ""</PercentCoverage>\n""
        << ""\t\t<CoverageMetric>"" << cmet << ""</CoverageMetric>\n""
        << ""\t</File>"" << std::endl;
    }
  
  if ( ccount > 0 )
    {
    local_end_time = ::CurrentTime();
    cfileoutput << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>\n""
                << ""</CoverageLog>\n""
                << ""</Site>"" << std::endl;
    cfileoutput.close();
    }

  int total_lines = total_tested + total_untested;
  float percent_coverage = 100 * static_cast<float>(total_tested) / 
    static_cast<float>(total_lines);
  if ( total_lines == 0 )
    {
    percent_coverage = 0;
    }

  std::string end_time = ::CurrentTime();

  log << ""\t<LOCTested>"" << total_tested << ""</LOCTested>\n""
      << ""\t<LOCUntested>"" << total_untested << ""</LOCUntested>\n""
      << ""\t<LOC>"" << total_lines << ""</LOC>\n""
      << ""\t<PercentCoverage>"" << percent_coverage << ""</PercentCoverage>\n""
      << ""\t<EndDateTime>"" << end_time << ""</EndDateTime>\n""
      << ""</Coverage>\n""
      << ""</Site>"" << std::endl;

  std::cout << ""\tCovered LOC:         "" << total_tested << std::endl
            << ""\tNot covered LOC:     "" << total_untested << std::endl
            << ""\tTotal LOC:           "" << total_lines << std::endl
            << ""\tPercentage Coverage: "" << percent_coverage << ""%"" << std::endl;


  std::cerr << ""Coverage test is not yet implemented"" << std::endl;
  return 1;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_903.cpp,"[33, 2, 13, 0, 2, 0, 8, 0, 0, 0, 50, 0, 0, 0, 1, 998, 0, 0, 55, 55, 0, 0, 47, 177, 0, 0, 0, 0, 10, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 502, 0, 348, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 0, 41, 0, 48, 33, 1, 0, 131, 0, 0, 70, 2, 123, 0, 13, 0, 0, 13, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_903.cpp,254
394149a03420c2160b4150f9481f82be27ba69a9,"Fix cov. problems, ignore nonascii char. Propagate verbosity",[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_711.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_711.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1392.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1392.cpp,1321,1328,1326,1338,"sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);","sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_904.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_904.cpp,"{
      local_end_time = ::CurrentTime();
      cfileoutput << ""\t<EndDateTime>"" << local_end_time << ""</EndDateTime>\n""
                  << ""</CoverageLog>\n""
                  << ""</Site>"" << std::endl;
      cfileoutput.close();
      sprintf(cfileoutputname, ""CoverageLog-%d.xml"", cfileoutputcount++);
      if (!this->OpenOutputFile(m_CurrentTag, cfileoutputname, cfileoutput))
        {
        std::cout << ""Cannot open log file"" << std::endl;
        return 1;
        }
      ccount = 0;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_904.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 27, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 4, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_904.cpp,271
a2c4d8eb90efe6f8d343fc91b9ee1552c6890f14,Display Cache and all variables,[],Tests/SystemInformation/DumpInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_713.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_713.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_713.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1395.cpp,1,1,8,8,"printf(""Error, could not open file %s\n"", CMAKE_DUMP_FILE);","printf(""Error, could not open file %s\n"", filename);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_905.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_905.cpp,"{
    printf(""Error, could not open file %s\n"", CMAKE_DUMP_FILE);
    return -1;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_905.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_905.cpp,5
a2c4d8eb90efe6f8d343fc91b9ee1552c6890f14,Display Cache and all variables,[],Tests/SystemInformation/DumpInformation.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_713.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_713.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_713.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1395.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1395.cpp,1,1,11,11,"printf(""#CMake System Variables are:"");","printf(""%s"", comment);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_906.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_906.cpp,"FILE* file = fopen(CMAKE_DUMP_FILE, ""r"");
  if(!file)
    {
    printf(""Error, could not open file %s\n"", CMAKE_DUMP_FILE);
    return -1;
    }
  printf(""#CMake System Variables are:"")",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_906.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 1, 1, 0, 0, 1, 4, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_906.cpp,8
d9324c178bbfa5e2ef1dcabb6ace504fe3c94328,Fix proxy code and fix comments to be C comments,[],Source/CTest/Curl/Testing/curltest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_715.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_715.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_715.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1397.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1397.cpp,46,46,48,48,"sprintf(""%s:%s"", getenv(""HTTP_PROXY""), getenv(""HTTP_PROXY_PORT""));","sprintf(proxy, ""%s:%s"", getenv(""HTTP_PROXY""), getenv(""HTTP_PROXY_PORT""));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_907.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_907.cpp,"{
      sprintf(""%s:%s"", getenv(""HTTP_PROXY""), getenv(""HTTP_PROXY_PORT""));
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_907.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_907.cpp,14
d9324c178bbfa5e2ef1dcabb6ace504fe3c94328,Fix proxy code and fix comments to be C comments,[],Source/CTest/Curl/Testing/curltest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_715.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_715.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_715.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1397.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1397.cpp,46,46,52,52,"sprintf(""%s"", getenv(""HTTP_PROXY""));","sprintf(proxy, ""%s"", getenv(""HTTP_PROXY""));",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_908.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_908.cpp,"{
      sprintf(""%s"", getenv(""HTTP_PROXY""));
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_908.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_908.cpp,18
55e1cb875d87c50956f242c375848cbb3a1fc17a,Add proxy support,[],Source/CTest/Curl/Testing/curltest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_716.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_716.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_716.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1398.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1398.cpp,51,102,60,-1,"printf(""Error fetching: http://www.cmake.org/page2.html\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_909.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_909.cpp,"{
      printf(""Error fetching: http://www.cmake.org/page2.html\n"");
      retVal = 1;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_909.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_909.cpp,27
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1407.cpp,279,279,286,-1,"vfprintf(f, fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_910.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_910.cpp,"return vfprintf(f, fmt, ap);",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_910.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_910.cpp,6
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1407.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1407.cpp,279,279,288,-1,"buf = aprintf(fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_911.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_911.cpp,"{
    buf = aprintf(fmt, ap);
    ret = buffer_write(&conn->out_buffer, buf, strlen(buf));
    free(buf);
    return ret;
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_911.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_911.cpp,8
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,357,-1,"vfprintf(f, fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_912.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_912.cpp,"return vfprintf(f, fmt, ap);",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_912.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_912.cpp,8
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,359,-1,"buf = aprintf(fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_913.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_913.cpp,"{
    int ret = 0;
    char *buf;
    void *enc;
    int len;
    if(!conn->sec_complete)
        return vfprintf(f, fmt, ap);
    
    buf = aprintf(fmt, ap);
    len = (conn->mech->encode)(conn->app_data, buf, strlen(buf),
                               conn->command_prot, &enc,
                               conn);
    free(buf);
    if(len < 0) {
        failf(conn->data, ""Failed to encode command."");
        return -1;
    }
    if(Curl_base64_encode(enc, len, &buf) < 0){
      failf(conn->data, ""Out of memory base64-encoding."");
      return -1;
    }
    if(conn->command_prot == prot_safe)
        ret = fprintf(f, ""MIC %s"", buf);
    else if(conn->command_prot == prot_private)
        ret = fprintf(f, ""ENC %s"", buf);
    else if(conn->command_prot == prot_confidential)
        ret = fprintf(f, ""CONF %s"", buf);

    free(buf);
    return ret;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_913.cpp,"[6, 0, 0, 0, 0, 0, 4, 0, 0, 0, 7, 0, 0, 0, 0, 77, 0, 0, 4, 4, 0, 0, 1, 10, 0, 0, 0, 0, 2, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 0, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 6, 6, 0, 0, 12, 0, 0, 9, 2, 30, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_913.cpp,10
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,373,-1,"ret = fprintf(f, ""MIC %s"", buf);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_914.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_914.cpp,"ret = fprintf(f, ""MIC %s"", buf)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_914.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_914.cpp,24
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,375,-1,"ret = fprintf(f, ""ENC %s"", buf);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_915.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_915.cpp,"ret = fprintf(f, ""ENC %s"", buf)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_915.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_915.cpp,26
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,377,-1,"ret = fprintf(f, ""CONF %s"", buf);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_916.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_916.cpp,"ret = fprintf(f, ""CONF %s"", buf)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_916.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_916.cpp,28
587b06788071e818823aabb5e31ef283f9278506,New Curl version 7.10.3,[],Source/CTest/Curl/security.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_722.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_722.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1408.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1408.cpp,346,321,389,-1,"ret = Curl_sec_vfprintf(conn, f, fmt, ap);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_917.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_917.cpp,"{
    va_list ap;
    int ret;
    va_start(ap, fmt);
    ret = Curl_sec_vfprintf(conn, f, fmt, ap);
    va_end(ap);
    return ret;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_917.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 16, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_917.cpp,6
6beecfa3de806bf54de02d0a20c76c851e07a188,"Better page, so the resulting dart page will not refresh",[],Source/CTest/Curl/Testing/curltest.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_724.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_724.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_724.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1410.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1410.cpp,16,16,18,18,"printf(""Error fetching: http://www.cmake.org/\n"");","printf(""Error fetching: ftp://public.kitware.com/pub/cmake/cygwin/setup.hint\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_918.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_918.cpp,"{
      printf(""Error fetching: http://www.cmake.org/\n"");
      retVal = 1;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_918.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_918.cpp,16
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_725.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_725.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_725.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1411.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1411.cpp,1470,1477,1562,-1,"sprintf(buf, ""Content-Length: %d\r\n"", filesize);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_919.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_919.cpp,"{
      sprintf(buf, ""Content-Length: %d\r\n"", filesize);
      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
      if(result)
        return result;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_919.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_919.cpp,61
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/ftp.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_725.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_725.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_725.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1412.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1412.cpp,2081,2117,2085,-1,"fprintf(conn->data->set.err, ""> %s\n"", s);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_920.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_920.cpp,"fprintf(conn->data->set.err, ""> %s\n"", s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_920.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_920.cpp,15
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/hostip.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_727.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_727.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_727.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1414.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1414.cpp,283,349,298,378,"snprintf(sbuf, sizeof(sbuf), ""%d"", port);","snprintf(sbuf, sizeof(sbuf), ""%d"", port);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_921.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_921.cpp,"{
  struct addrinfo hints, *res;
  int error;
  char sbuf[NI_MAXSERV];

  memset(&hints, 0, sizeof(hints));
  hints.ai_family = PF_INET;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_CANONNAME;
  snprintf(sbuf, sizeof(sbuf), ""%d"", port);
  error = getaddrinfo(hostname, sbuf, &hints, &res);
  if (error) {
    infof(data, ""getaddrinfo(3) failed for %s\n"", hostname);    
    return NULL;
  }
  *bufp=(char *)res; /* make it point to the result struct */

  return res;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_921.cpp,"[1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 45, 0, 0, 3, 4, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 28, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 0, 1, 1, 0, 0, 6, 0, 0, 8, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_921.cpp,13
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_728.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_728.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_728.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1416.cpp,579,587,585,596,"conn->allocptr.host = aprintf(""Host: %s\r\n"", host);","conn->allocptr.host = aprintf(""Host: %s%s%s\r\n"",
                                    conn->bits.ipv6_ip?""["":"""",
                                    host,
                                    conn->bits.ipv6_ip?""]"":"""");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_922.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_922.cpp,"conn->allocptr.host = aprintf(""Host: %s\r\n"", host)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_922.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_922.cpp,101
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/http.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_728.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_728.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_728.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1416.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1416.cpp,579,587,587,601,"conn->allocptr.host = aprintf(""Host: %s:%d\r\n"", host,
                                    conn->remote_port);","conn->allocptr.host = aprintf(""Host: %s%s%s:%d\r\n"",
                                    conn->bits.ipv6_ip?""["":"""",
                                    host,
                                    conn->bits.ipv6_ip?""]"":"""",
                                    conn->remote_port);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_923.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_923.cpp,"conn->allocptr.host = aprintf(""Host: %s:%d\r\n"", host,
                                    conn->remote_port)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_923.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_923.cpp,103
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/netrc.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_730.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_730.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_730.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1420.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1420.cpp,116,119,119,130,,"printf(""NETRC: overridden .netrc file: %s\n"", home);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_924.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_924.cpp,"f(file) {
    char *tok;
        char *tok_buf;
    while(fgets(netrcbuffer, sizeof(netrcbuffer), file)) {
      tok=strtok_r(netrcbuffer, "" \t\n"", &tok_buf);
      while(tok) {
        switch(state) {
        case NOTHING:
          if(strequal(""machine"", tok)) {
            /* the next tok is the machine name, this is in itself the
               delimiter that starts the stuff entered for this machine,
               after this we need to search for 'login' and
               'password'. */
            state=HOSTFOUND;
          }
          break;
        case HOSTFOUND:
          if(strequal(host, tok)) {
            /* and yes, this is our host! */
            state=HOSTVALID;
#ifdef _NETRC_DEBUG
            printf(""HOST: %s\n"", tok);
#endif
            retcode=0; /* we did find our host */
          }
          else
            /* not our host */
            state=NOTHING;
          break;
        case HOSTVALID:
          /* we are now parsing sub-keywords concerning ""our"" host */
          if(state_login) {
            strncpy(login, tok, LOGINSIZE-1);
#ifdef _NETRC_DEBUG
            printf(""LOGIN: %s\n"", login);
#endif
            state_login=0;
          }
          else if(state_password) {
            strncpy(password, tok, PASSWORDSIZE-1);
#ifdef _NETRC_DEBUG
            printf(""PASSWORD: %s\n"", password);
#endif
            state_password=0;
          }
          else if(strequal(""login"", tok))
            state_login=1;
          else if(strequal(""password"", tok))
            state_password=1;
          else if(strequal(""machine"", tok)) {
            /* ok, there's machine here go => */
            state = HOSTFOUND;
          }
          break;
        } /* switch (state) */
        tok = strtok_r(NULL, "" \t\n"", &tok_buf);
      } /* while (tok) */
    } /* while fgets() */

    fclose(file);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_924.cpp,"[7, 2, 0, 0, 3, 0, 0, 1, 3, 0, 12, 0, 0, 0, 0, 67, 0, 0, 2, 2, 0, 0, 0, 16, 0, 0, 0, 0, 2, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 0, 63, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 10, 7, 1, 0, 16, 0, 0, 17, 4, 34, 6, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_924.cpp,46
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_731.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_731.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_731.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1422.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1422.cpp,84,84,139,138,"vfprintf(data->set.err, fmt, ap);","vsnprintf(print_buffer, 1024, fmt, ap);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_925.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_925.cpp,"{
    va_start(ap, fmt);
    fputs(""* "", data->set.err);
    vfprintf(data->set.err, fmt, ap);
    va_end(ap);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_925.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_925.cpp,6
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/sendf.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_731.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_731.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_731.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1424.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1424.cpp,163,167,174,192,"fprintf(data->set.err, ""> %s"", s);","Curl_debug(data, CURLINFO_DATA_OUT, sptr, bytes_written);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_926.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_926.cpp,"fprintf(data->set.err, ""> %s"", s)",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_926.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_926.cpp,14
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/transfer.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_732.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_732.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_732.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1425.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1425.cpp,1136,1607,1227,-1,"sprintf(newest, ""%s%s%s"", url_clone, ('/' == newurl[0])?"""":""/"",
                  newurl);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_927.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_927.cpp,"{
          /***
           *DANG* this is an RFC 2068 violation. The URL is supposed
           to be absolute and this doesn't seem to be that!
           ***
           Instead, we have to TRY to append this new path to the old URL
           to the right of the host part. Oh crap, this is doomed to cause
           problems in the future...
          */
          char *protsep;
          char *pathsep;
          char *newest;

          /* we must make our own copy of the URL to play with, as it may
             point to read-only data */
          char *url_clone=strdup(data->change.url);

          if(!url_clone) {
            res = CURLE_OUT_OF_MEMORY;
            break; /* skip out of this loop NOW */
          }

          /* protsep points to the start of the host name */
          protsep=strstr(url_clone, ""//"");
          if(!protsep)
            protsep=url_clone;
          else
            protsep+=2; /* pass the slashes */

          if('/' != newurl[0]) {
            /* First we need to find out if there's a ?-letter in the URL,
               and cut it and the right-side of that off */
            pathsep = strrchr(protsep, '?');
            if(pathsep)
              *pathsep=0;

            /* we have a relative path to append to the last slash if
               there's one available */
            pathsep = strrchr(protsep, '/');
            if(pathsep)
              *pathsep=0;
          }
          else {
            /* We got a new absolute path for this server, cut off from the
               first slash */
            pathsep = strchr(protsep, '/');
            if(pathsep)
              *pathsep=0;
          }

          newest=(char *)malloc( strlen(url_clone) +
                                 1 + /* possible slash */
                                 strlen(newurl) + 1/* zero byte */);

          if(!newest) {
            res = CURLE_OUT_OF_MEMORY;
            break; /* go go go out from this loop */
          }
          sprintf(newest, ""%s%s%s"", url_clone, ('/' == newurl[0])?"""":""/"",
                  newurl);
          free(newurl);
          free(url_clone);
          newurl = newest;
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_927.cpp,"[7, 0, 0, 0, 2, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 62, 0, 0, 4, 4, 0, 0, 1, 17, 0, 0, 0, 0, 4, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 1, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 8, 8, 3, 0, 11, 0, 0, 16, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_927.cpp,150
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/url.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_733.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_733.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_733.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1426.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1426.cpp,2194,2766,2236,2770,"snprintf(hbuf, sizeof(hbuf), ""?"");",free(conn->allocptr.accept_encoding);,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_928.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_928.cpp,"{
      snprintf(hbuf, sizeof(hbuf), ""?"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_928.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_928.cpp,990
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/url.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_733.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_733.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_733.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1426.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1426.cpp,2194,2766,2196,2772,,"(""Accept-Encoding: %s\015\012"";",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_929.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_929.cpp,"f(-1 == conn->firstsocket) {
    /* Connect only if not already connected! */
    result = ConnectPlease(conn);
    if(CURLE_OK != result)
      return result;

    if(conn->curl_connect) {
      /* is there a connect() procedure? */

      /* set start time here for timeout purposes in the
       * connect procedure, it is later set again for the
       * progress meter purpose */
      conn->now = Curl_tvnow();

      /* Call the protocol-specific connect function */
      result = conn->curl_connect(conn);
      if(result != CURLE_OK)
        return result; /* pass back errors */
    }
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_929.cpp,"[3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 4, 0, 0, 3, 0, 3, 0, 0, 0, 1, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_929.cpp,950
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/version.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_734.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_734.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_734.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1427.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1427.cpp,56,52,58,54,"f(ptr, "" (OpenSSL %lx.%lx.%lx%s)"",
            (ssleay_value>>28)&0xf,
            (ssleay_value>>20)&0xff,
            (ssleay_value>>12)&0xff,
            sub);","f(ptr, "" OpenSSL/%lx.%lx.%lx%s"",
            (ssleay_value>>28)&0xf,
            (ssleay_value>>20)&0xff,
            (ssleay_value>>12)&0xff,
            sub);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_930.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_930.cpp,"{
    char sub[2];
    unsigned long ssleay_value;
    sub[1]='\0';
    ssleay_value=SSLeay();
    if(ssleay_value < 0x906000) {
      ssleay_value=SSLEAY_VERSION_NUMBER;
      sub[0]='\0';
    }
    else {
      if(ssleay_value&0xff0) {
        sub[0]=((ssleay_value>>4)&0xff) + 'a' -1;
      }
      else
        sub[0]='\0';
    }

    sprintf(ptr, "" (OpenSSL %lx.%lx.%lx%s)"",
            (ssleay_value>>28)&0xf,
            (ssleay_value>>20)&0xff,
            (ssleay_value>>12)&0xff,
            sub);
  }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_930.cpp,"[2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 27, 0, 0, 2, 2, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0, 2, 2, 2, 0, 2, 0, 0, 7, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_930.cpp,27
3ad91bf9d39c22dc6941068e6fdc1453988f0b07,New version of libcurl,[],Source/CTest/Curl/version.c,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_734.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_734.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_734.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1427.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1427.cpp,56,52,67,64,"f(ptr, "" (SSL %lx.%lx.%lx)"",
          (SSLEAY_VERSION_NUMBER>>28)&0xff,
          (SSLEAY_VERSION_NUMBER>>20)&0xff,
          (SSLEAY_VERSION_NUMBER>>12)&0xf);","sprintf(ptr, "" OpenSSL/%lx.%lx.%lx"",
          (SSLEAY_VERSION_NUMBER>>28)&0xff,
          (SSLEAY_VERSION_NUMBER>>20)&0xff,
          (SSLEAY_VERSION_NUMBER>>12)&0xf);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_931.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_931.cpp,"{
  static char version[200];
  char *ptr;
  strcpy(version, LIBCURL_NAME "" "" LIBCURL_VERSION );
  ptr=strchr(version, '\0');

#ifdef USE_SSLEAY

#if (SSLEAY_VERSION_NUMBER >= 0x905000)
  {
    char sub[2];
    unsigned long ssleay_value;
    sub[1]='\0';
    ssleay_value=SSLeay();
    if(ssleay_value < 0x906000) {
      ssleay_value=SSLEAY_VERSION_NUMBER;
      sub[0]='\0';
    }
    else {
      if(ssleay_value&0xff0) {
        sub[0]=((ssleay_value>>4)&0xff) + 'a' -1;
      }
      else
        sub[0]='\0';
    }

    sprintf(ptr, "" (OpenSSL %lx.%lx.%lx%s)"",
            (ssleay_value>>28)&0xf,
            (ssleay_value>>20)&0xff,
            (ssleay_value>>12)&0xff,
            sub);
  }

#else
#if (SSLEAY_VERSION_NUMBER >= 0x900000)
  sprintf(ptr, "" (SSL %lx.%lx.%lx)"",
          (SSLEAY_VERSION_NUMBER>>28)&0xff,
          (SSLEAY_VERSION_NUMBER>>20)&0xff,
          (SSLEAY_VERSION_NUMBER>>12)&0xf);
#else
  {
    char sub[2];
    sub[1]='\0';
    if(SSLEAY_VERSION_NUMBER&0x0f) {
      sub[0]=(SSLEAY_VERSION_NUMBER&0x0f) + 'a' -1;
    }
    else
      sub[0]='\0';

    sprintf(ptr, "" (SSL %x.%x.%x%s)"",
            (SSLEAY_VERSION_NUMBER>>12)&0xff,
            (SSLEAY_VERSION_NUMBER>>8)&0xf,
            (SSLEAY_VERSION_NUMBER>>4)&0xf, sub);
  }
#endif
#endif
  ptr=strchr(ptr, '\0');
#endif

#if defined(KRB4) || defined(ENABLE_IPV6)
  strcat(ptr, "" ("");
  ptr+=2;
#ifdef KRB4
  sprintf(ptr, ""krb4 "");
  ptr += strlen(ptr);
#endif
#ifdef ENABLE_IPV6
  sprintf(ptr, ""ipv6 "");
  ptr += strlen(ptr);
#endif
  sprintf(ptr, ""enabled)"");
  ptr += strlen(ptr);
#endif

#ifdef USE_ZLIB
  sprintf(ptr, "" (zlib %s)"", zlibVersion());
  ptr += strlen(ptr);
#endif

  return version;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_931.cpp,"[6, 0, 0, 0, 0, 0, 1, 0, 0, 0, 9, 0, 0, 0, 1, 99, 0, 0, 5, 5, 0, 0, 0, 57, 0, 0, 0, 0, 1, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75, 0, 82, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10, 0, 3, 3, 5, 0, 19, 0, 0, 25, 0, 40, 16, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_931.cpp,36
8aba833b7714c746436282a0db9f5a5478c75271,Work on submitting,[],Source/cmCTest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_735.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_735.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_735.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1428.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1428.cpp,273,277,273,277,"sprintf(datestring, ""%04d%02d%02d-%02d%02d"",
              lctime->tm_year + 1900,
              lctime->tm_mon,
              lctime->tm_mday,
              lctime->tm_hour,
              lctime->tm_min);","sprintf(datestring, ""%04d%02d%02d-%02d%02d"",
              lctime->tm_year + 1900,
              lctime->tm_mon+1,
              lctime->tm_mday,
              lctime->tm_hour,
              lctime->tm_min);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_932.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_932.cpp,"{
      char datestring[100];
      sprintf(datestring, ""%04d%02d%02d-%02d%02d"",
              lctime->tm_year + 1900,
              lctime->tm_mon,
              lctime->tm_mday,
              lctime->tm_hour,
              lctime->tm_min);
      tag = datestring;
      std::ofstream ofs(tagfile.c_str());
      if ( ofs )
        {
        ofs << tag << std::endl;
        }
      ofs.close();
      std::cout << ""Create new tag: "" << tag << std::endl;
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_932.cpp,"[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 45, 0, 0, 2, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 1, 0, 0, 4, 0, 0, 5, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_932.cpp,91
190424b29ca2367bf2893736b9f929efbe35b127,ENH: Tcl packages now Tcl_PkgProvide their own name and version.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_736.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1429.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1429.cpp,228,228,231,230,,"fprintf(fout,""#include \""vtkVersion.h\""\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_933.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_933.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "", tempOutputFile.c_str());
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < m_Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(m_Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_933.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 204, 0, 0, 4, 4, 0, 0, 7, 67, 0, 0, 0, 0, 1, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 68, 0, 0, 45, 0, 109, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_933.cpp,22
190424b29ca2367bf2893736b9f929efbe35b127,ENH: Tcl packages now Tcl_PkgProvide their own name and version.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_736.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1429.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1429.cpp,228,228,231,231,,"fprintf(fout,""#define VTK_TCL_TO_STRING(x) VTK_TCL_TO_STRING0(x)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_934.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_934.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "", tempOutputFile.c_str());
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < m_Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(m_Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_934.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 204, 0, 0, 4, 4, 0, 0, 7, 67, 0, 0, 0, 0, 1, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 68, 0, 0, 45, 0, 109, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_934.cpp,22
190424b29ca2367bf2893736b9f929efbe35b127,ENH: Tcl packages now Tcl_PkgProvide their own name and version.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_736.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_736.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1429.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1429.cpp,228,228,231,232,,"fprintf(fout,""#define VTK_TCL_TO_STRING0(x) #x\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_935.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_935.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    cmSystemTools::Error(""Failed to open TclInit file for "", tempOutputFile.c_str());
    return false;
    }

  // capitalized commands just once
  std::vector<std::string> capcommands;
  for (i = 0; i < m_Commands.size(); i++)
    {
    capcommands.push_back(cmSystemTools::Capitalized(m_Commands[i]));
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""#if (TCL_MAJOR_VERSION == 8) && (TCL_MINOR_VERSION >= 4) && (TCL_RELEASE_LEVEL >= TCL_FINAL_RELEASE)\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, CONST84 char *[]);\n""
          ""#else\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""#endif\n""
          ""}\n""
          ""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n""
                 ""               int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");

  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());
    }
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
          kitName);
  fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
          kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");

  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""extern \""C\""\n{\nvoid vtkCommonDeleteAssocData(ClientData cd)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n}\n"");
    }
    
  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
            ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");
    fprintf(fout,
            ""  Tcl_CreateExitHandler(vtkCommonDeleteAssocData,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",\n""
                 ""                    reinterpret_cast<vtkTclCommandType>(vtkCommandForward),\n""
                 ""                    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < m_Commands.size(); i++)
    {
    fprintf(fout,""  %s_Init(interp);\n"", capcommands[i].c_str());
    }
  fprintf(fout,""\n"");

  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
            classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_935.cpp,"[4, 0, 5, 0, 0, 0, 2, 0, 0, 0, 11, 0, 0, 0, 0, 204, 0, 0, 4, 4, 0, 0, 7, 67, 0, 0, 0, 0, 1, 0, 67, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 8, 0, 9, 4, 1, 0, 68, 0, 0, 45, 0, 109, 0, 5, 0, 0, 5, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_935.cpp,22
e0cec1e650138f797467967e8a4c8ae66dc61e37,Add support for only showing what will be done. This way you can for example get a list of all tests: ctest -N or list of all tests that match regex: ctest -N -R regex,[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_737.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_737.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1430.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1430.cpp,1163,1193,1165,1201,"fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());","fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_936.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_936.cpp,"{
        if (this->m_UseExcludeRegExp && 
            this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].Value.c_str()))
          {
          continue;
          }
        if (this->m_UseIncludeRegExp && !ireg.find(args[0].Value.c_str()))
          {
          continue;
          }
        if (this->m_UseExcludeRegExp && 
            !this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].Value.c_str()))
          {
          continue;
          }

        cmCTestTestResult cres;

        if (firstTest)
          {
          std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
          std::cerr << ""Changing directory into "" << nwd.c_str() << ""\n"";
          firstTest = 0;
          }
        cres.m_Name = args[0].Value;
        fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());
        fflush(stderr);
        //std::cerr << ""Testing "" << args[0] << "" ... "";
        // find the test executable
        std::string testCommand = this->FindExecutable(args[1].Value.c_str());
        testCommand = cmSystemTools::ConvertToOutputPath(testCommand.c_str());

        // continue if we did not find the executable
        if (testCommand == """")
          {
          std::cerr << ""Unable to find executable: "" << 
            args[1].Value.c_str() << ""\n"";
          continue;
          }
        
        // add the arguments
        std::vector<cmListFileArgument>::const_iterator j = args.begin();
        ++j;
        ++j;
        for(;j != args.end(); ++j)
          {   
          testCommand += "" "";
          testCommand += cmSystemTools::EscapeSpaces(j->Value.c_str());
          }
        /**
         * Run an executable command and put the stdout in output.
         */
        std::string output;
        int retVal;

        double clock_start, clock_finish;
        clock_start = cmSystemTools::GetTime();

        if ( m_Verbose )
          {
          std::cout << std::endl << ""Test command: "" << testCommand << std::endl;
          }
        bool res = cmSystemTools::RunCommand(testCommand.c_str(), output, 
                                             retVal, 0, false);
        clock_finish = cmSystemTools::GetTime();

        cres.m_ExecutionTime = (double)(clock_finish - clock_start);
        cres.m_FullCommandLine = testCommand;

        if (!res || retVal != 0)
          {
          fprintf(stderr,""***Failed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          failed.push_back(args[0].Value); 
          }
        else
          {
          fprintf(stderr,""   Passed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          passed.push_back(args[0].Value); 
          }
        cres.m_Output = output;
        cres.m_ReturnValue = retVal;
        std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
        if ( nwd.size() > m_ToplevelPath.size() )
          {
          nwd = ""."" + nwd.substr(m_ToplevelPath.size(), nwd.npos);
          }
        cres.m_Path = nwd;
        cres.m_CompletionStatus = ""Completed"";
        m_TestResults.push_back( cres );
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_936.cpp,"[14, 0, 1, 0, 0, 4, 0, 0, 0, 0, 17, 0, 0, 0, 0, 279, 0, 0, 9, 10, 0, 0, 6, 35, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 9, 0, 15, 14, 1, 0, 48, 0, 0, 30, 0, 36, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_936.cpp,78
e0cec1e650138f797467967e8a4c8ae66dc61e37,Add support for only showing what will be done. This way you can for example get a list of all tests: ctest -N or list of all tests that match regex: ctest -N -R regex,[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_737.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_737.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_737.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1430.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1430.cpp,1163,1193,1165,1201,"fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());","fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_937.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_937.cpp,"{
        if (this->m_UseExcludeRegExp && 
            this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].Value.c_str()))
          {
          continue;
          }
        if (this->m_UseIncludeRegExp && !ireg.find(args[0].Value.c_str()))
          {
          continue;
          }
        if (this->m_UseExcludeRegExp && 
            !this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].Value.c_str()))
          {
          continue;
          }

        cmCTestTestResult cres;

        if (firstTest)
          {
          std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
          std::cerr << ""Changing directory into "" << nwd.c_str() << ""\n"";
          firstTest = 0;
          }
        cres.m_Name = args[0].Value;
        fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());
        fflush(stderr);
        //std::cerr << ""Testing "" << args[0] << "" ... "";
        // find the test executable
        std::string testCommand = this->FindExecutable(args[1].Value.c_str());
        testCommand = cmSystemTools::ConvertToOutputPath(testCommand.c_str());

        // continue if we did not find the executable
        if (testCommand == """")
          {
          std::cerr << ""Unable to find executable: "" << 
            args[1].Value.c_str() << ""\n"";
          continue;
          }
        
        // add the arguments
        std::vector<cmListFileArgument>::const_iterator j = args.begin();
        ++j;
        ++j;
        for(;j != args.end(); ++j)
          {   
          testCommand += "" "";
          testCommand += cmSystemTools::EscapeSpaces(j->Value.c_str());
          }
        /**
         * Run an executable command and put the stdout in output.
         */
        std::string output;
        int retVal;

        double clock_start, clock_finish;
        clock_start = cmSystemTools::GetTime();

        if ( m_Verbose )
          {
          std::cout << std::endl << ""Test command: "" << testCommand << std::endl;
          }
        bool res = cmSystemTools::RunCommand(testCommand.c_str(), output, 
                                             retVal, 0, false);
        clock_finish = cmSystemTools::GetTime();

        cres.m_ExecutionTime = (double)(clock_finish - clock_start);
        cres.m_FullCommandLine = testCommand;

        if (!res || retVal != 0)
          {
          fprintf(stderr,""***Failed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          failed.push_back(args[0].Value); 
          }
        else
          {
          fprintf(stderr,""   Passed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          passed.push_back(args[0].Value); 
          }
        cres.m_Output = output;
        cres.m_ReturnValue = retVal;
        std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
        if ( nwd.size() > m_ToplevelPath.size() )
          {
          nwd = ""."" + nwd.substr(m_ToplevelPath.size(), nwd.npos);
          }
        cres.m_Path = nwd;
        cres.m_CompletionStatus = ""Completed"";
        m_TestResults.push_back( cres );
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_937.cpp,"[14, 0, 1, 0, 0, 4, 0, 0, 0, 0, 17, 0, 0, 0, 0, 279, 0, 0, 9, 10, 0, 0, 6, 35, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 130, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 9, 0, 15, 14, 1, 0, 48, 0, 0, 30, 0, 36, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_937.cpp,78
4888c088ae0ca829862e8b2f9568abca12dc34d1,"ENH: Moved ExpandListVariables out of individual commands.  Argument evaluation rules are now very consistent.  Double quotes can always be used to create exactly one argument, regardless of contents inside.",[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_738.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_738.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_738.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1432.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1432.cpp,1159,1162,1162,1165,"fprintf(stderr,""Testing %-30s "",args[0].c_str());","fprintf(stderr,""Testing %-30s "",args[0].Value.c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_938.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_938.cpp,"{
        if (this->m_UseExcludeRegExp && 
            this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].c_str()))
          {
          continue;
          }
        if (this->m_UseIncludeRegExp && !ireg.find(args[0].c_str()))
          {
          continue;
          }
        if (this->m_UseExcludeRegExp && 
            !this->m_UseExcludeRegExpFirst && 
            ereg.find(args[0].c_str()))
          {
          continue;
          }

        cmCTestTestResult cres;

        if (firstTest)
          {
          std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
          std::cerr << ""Changing directory into "" << nwd.c_str() << ""\n"";
          firstTest = 0;
          }
        cres.m_Name = args[0];
        fprintf(stderr,""Testing %-30s "",args[0].c_str());
        fflush(stderr);
        //std::cerr << ""Testing "" << args[0] << "" ... "";
        // find the test executable
        std::string testCommand = this->FindExecutable(args[1].c_str());
        testCommand = cmSystemTools::ConvertToOutputPath(testCommand.c_str());

        // continue if we did not find the executable
        if (testCommand == """")
          {
          std::cerr << ""Unable to find executable: "" << 
            args[1].c_str() << ""\n"";
          continue;
          }
        
        // add the arguments
        std::vector<std::string>::iterator j = args.begin();
        ++j;
        ++j;
        for(;j != args.end(); ++j)
          {   
          testCommand += "" "";
          testCommand += cmSystemTools::EscapeSpaces(j->c_str());
          }
        /**
         * Run an executable command and put the stdout in output.
         */
        std::string output;
        int retVal;

        double clock_start, clock_finish;
        clock_start = cmSystemTools::GetTime();

        if ( m_Verbose )
          {
          std::cout << std::endl << ""Test command: "" << testCommand << std::endl;
          }
        bool res = cmSystemTools::RunCommand(testCommand.c_str(), output, 
                                             retVal, 0, false);
        clock_finish = cmSystemTools::GetTime();

        cres.m_ExecutionTime = (double)(clock_finish - clock_start);
        cres.m_FullCommandLine = testCommand;

        if (!res || retVal != 0)
          {
          fprintf(stderr,""***Failed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          failed.push_back(args[0]); 
          }
        else
          {
          fprintf(stderr,""   Passed\n"");
          if (output != """")
            {
            if (dartStuff.find(output.c_str()))
              {
              cmSystemTools::ReplaceString(output,
                                           dartStuff.match(1).c_str(),"""");
              }
            if (output != """" && m_Verbose)
              {
              std::cerr << output.c_str() << ""\n"";
              }
            }
          passed.push_back(args[0]); 
          }
        cres.m_Output = output;
        cres.m_ReturnValue = retVal;
        std::string nwd = cmSystemTools::GetCurrentWorkingDirectory();
        if ( nwd.size() > m_ToplevelPath.size() )
          {
          nwd = ""."" + nwd.substr(m_ToplevelPath.size(), nwd.npos);
          }
        cres.m_Path = nwd;
        cres.m_CompletionStatus = ""Completed"";
        m_TestResults.push_back( cres );
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_938.cpp,"[14, 0, 1, 0, 0, 4, 0, 0, 0, 0, 17, 0, 0, 0, 0, 265, 0, 0, 9, 10, 0, 0, 6, 35, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 9, 0, 15, 14, 1, 0, 48, 0, 0, 30, 0, 36, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_938.cpp,76
c1132e4b08da658a1eab86e212a9b205bce63337,ENH: move version to title bar,[],Source/MFCDialog/CMakeSetupDialog.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_741.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_741.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_741.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1435.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1435.cpp,288,287,290,289,"sprintf(tmp,""Version %d.%d - %s"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmake::GetReleaseVersion());","sprintf(tmp,""CMake %d.%d - %s"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmake::GetReleaseVersion());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_939.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_939.cpp,"{
  CDialog::OnInitDialog();
  this->DragAcceptFiles(true);

  // Add ""Create shortcut"" menu item to system menu.

  // IDM_CREATESHORTCUT must be in the system command range.
  ASSERT((IDM_CREATESHORTCUT & 0xFFF0) == IDM_CREATESHORTCUT);
  ASSERT(IDM_CREATESHORTCUT < 0xF000);

  // Add ""About..."" menu item to system menu.

  // IDM_ABOUTBOX must be in the system command range.
  ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
  ASSERT(IDM_ABOUTBOX < 0xF000);

  CMenu* pSysMenu = GetSystemMenu(FALSE);
  if (pSysMenu != NULL)
    {
    CString strCreateShortcutMenu;
    strCreateShortcutMenu.LoadString(IDS_CREATESHORTCUT);
    if (!strCreateShortcutMenu.IsEmpty())
      {
      pSysMenu->AppendMenu(MF_SEPARATOR);
      pSysMenu->AppendMenu(MF_STRING, 
                           IDM_CREATESHORTCUT, 
                           strCreateShortcutMenu);
      }

    CString strAboutMenu;
    strAboutMenu.LoadString(IDS_ABOUTBOX);
    if (!strAboutMenu.IsEmpty())
      {
      pSysMenu->AppendMenu(MF_SEPARATOR);
      pSysMenu->AppendMenu(MF_STRING, 
                           IDM_ABOUTBOX, 
                           strAboutMenu);
      }
    }

  // Set the icon for this dialog.  The framework does this automatically
  //  when the application's main window is not a dialog
  SetIcon(m_hIcon, TRUE);			// Set big icon
  SetIcon(m_hIcon, FALSE);		// Set small icon
  // Load source and build dirs from registry
  this->LoadFromRegistry();
  std::vector<std::string> names;
  this->m_CMakeInstance->GetRegisteredGenerators(names);
  for(std::vector<std::string>::iterator i = names.begin();
      i != names.end(); ++i)
    {
    m_GeneratorChoice.AddString(i->c_str());
    }
  if (m_GeneratorChoiceString == _T("""")) 
    {
    m_GeneratorChoiceString = ""Visual Studio 6"";
    }

  // try to load the cmake cache from disk
  this->LoadCacheFromDiskToGUI();
  m_WhereBuildControl.LimitText(2048);
  m_WhereSourceControl.LimitText(2048);
  m_GeneratorChoice.LimitText(2048);
    
  // Set the version number
  char tmp[1024];
  sprintf(tmp,""Version %d.%d - %s"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmake::GetReleaseVersion());
  SetDlgItemText(IDC_CMAKE_VERSION, tmp);
  SetDlgItemText(IDC_PROGRESS, """");
  this->UpdateData(FALSE);
  return TRUE;  // return TRUE  unless you set the focus to a control
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_939.cpp,"[4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 144, 0, 0, 5, 6, 0, 0, 3, 13, 0, 0, 0, 0, 1, 0, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 74, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 5, 4, 0, 0, 37, 0, 0, 26, 0, 38, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_939.cpp,67
145390fcc9f6d59435d03b6217e1adc4f8fc93d0,fix flag setting,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_742.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_742.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_742.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1436.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1436.cpp,153,153,155,155,"f(fout, ""SET(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${COMPILE_DEFINITIONS})\n"");","f(fout, ""SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${COMPILE_DEFINITIONS}\""\"")\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_940.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_940.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    
    std::string source = argv[2];
    cmSystemTools::FileFormat format = 
      cmSystemTools::GetFileFormat( 
        cmSystemTools::GetFilenameExtension(source).c_str());
    if ( format == cmSystemTools::C_FILE_FORMAT )
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE C)\n"");      
      }
    else if ( format == cmSystemTools::CXX_FILE_FORMAT )
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE CXX)\n"");      
      }
    else
      {
      cmSystemTools::Error(""Unknown file format for file: "", source.c_str(), 
                           ""; TRY_COMPILE only works for C and CXX files"");
      return -1;
      }

    fprintf(fout, ""SET(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${COMPILE_DEFINITIONS})\n"");
    fprintf(fout, ""SET(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} ${COMPILE_DEFINITIONS})\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",source.c_str());
    fprintf(fout, ""TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})\n"");
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_940.cpp,"[4, 0, 1, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 100, 0, 0, 4, 4, 0, 0, 5, 22, 0, 0, 0, 0, 1, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 4, 1, 0, 27, 0, 0, 18, 1, 35, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_940.cpp,135
145390fcc9f6d59435d03b6217e1adc4f8fc93d0,fix flag setting,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_742.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_742.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_742.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1436.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1436.cpp,153,153,156,156,"fprintf(fout, ""SET(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} ${COMPILE_DEFINITIONS})\n"");","fprintf(fout, ""SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${COMPILE_DEFINITIONS}\"")\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_941.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_941.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    
    std::string source = argv[2];
    cmSystemTools::FileFormat format = 
      cmSystemTools::GetFileFormat( 
        cmSystemTools::GetFilenameExtension(source).c_str());
    if ( format == cmSystemTools::C_FILE_FORMAT )
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE C)\n"");      
      }
    else if ( format == cmSystemTools::CXX_FILE_FORMAT )
      {
      fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE CXX)\n"");      
      }
    else
      {
      cmSystemTools::Error(""Unknown file format for file: "", source.c_str(), 
                           ""; TRY_COMPILE only works for C and CXX files"");
      return -1;
      }

    fprintf(fout, ""SET(CMAKE_C_FLAGS ${CMAKE_C_FLAGS} ${COMPILE_DEFINITIONS})\n"");
    fprintf(fout, ""SET(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} ${COMPILE_DEFINITIONS})\n"");
    fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");
    fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",source.c_str());
    fprintf(fout, ""TARGET_LINK_LIBRARIES(cmTryCompileExec ${LINK_LIBRARIES})\n"");
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_941.cpp,"[4, 0, 1, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 100, 0, 0, 4, 4, 0, 0, 5, 22, 0, 0, 0, 0, 1, 0, 27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 31, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 5, 4, 1, 0, 27, 0, 0, 18, 1, 35, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_941.cpp,136
1d39833446340e262020c83d9ef3124da6a1e3f7,Add progress to ccmake,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_743.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1437.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1437.cpp,381,381,384,388,,"sprintf(firstLine, 
            ""                                                               "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_942.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_942.cpp,"(m_OkToGenerate)
      {
      sprintf(firstLine,  ""Press [c] to configure     Press [g] to generate and exit"");
      }
    else
      {
      sprintf(firstLine,  ""Press [c] to configure                                   "");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_942.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_942.cpp,29
1d39833446340e262020c83d9ef3124da6a1e3f7,Add progress to ccmake,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_743.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1437.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1437.cpp,381,381,384,390,,"sprintf(secondLine, 
            ""                                                               "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_943.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_943.cpp,"(m_OkToGenerate)
      {
      sprintf(firstLine,  ""Press [c] to configure     Press [g] to generate and exit"");
      }
    else
      {
      sprintf(firstLine,  ""Press [c] to configure                                   "");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_943.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_943.cpp,29
1d39833446340e262020c83d9ef3124da6a1e3f7,Add progress to ccmake,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_743.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_743.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1437.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1437.cpp,381,381,384,392,,"sprintf(thirdLine, 
            ""                                                               "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_944.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_944.cpp,"(m_OkToGenerate)
      {
      sprintf(firstLine,  ""Press [c] to configure     Press [g] to generate and exit"");
      }
    else
      {
      sprintf(firstLine,  ""Press [c] to configure                                   "");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_944.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_944.cpp,29
5b9feb6fdc32488e0f3fece5df9633981e11b06a,Fix network build,[],Source/cmWin32ProcessExecution.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_750.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_750.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_750.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1447.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1447.cpp,310,310,318,319,"sprintf(s2, ""%s%s%s"", s1, s3, cmdstring);","sprintf(s2, ""%s"", cmdstring);",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_945.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_945.cpp,"{
      /* NT/2000 and not using command.com. */
      x = i + (int)strlen(s3) + (int)strlen(cmdstring) + 1;
      s2 = (char *)_alloca(x);
      ZeroMemory(s2, x);
      sprintf(s2, ""%s%s%s"", s1, s3, cmdstring);
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_945.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 4, 0, 10, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_945.cpp,38
ea87271c4a4e534772d7d8f14b70b6fd8ac648be,"Reorganization, cleanup and some improvement in dart emulation",[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_751.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_751.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_751.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1449.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1449.cpp,547,589,570,-1,"sprintf(datestring, ""%4d%02d%02d-%d%d"",
          lctime->tm_year + 1900,
          lctime->tm_mon,
          lctime->tm_mday,
          lctime->tm_hour,
          lctime->tm_min);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_946.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_946.cpp,"{
  time_t tctime = time(0);
  struct tm *lctime = gmtime(&tctime);
  char datestring[100];
  sprintf(datestring, ""%4d%02d%02d-%d%d"",
          lctime->tm_year + 1900,
          lctime->tm_mon,
          lctime->tm_mday,
          lctime->tm_hour,
          lctime->tm_min);

  os << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
     << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
     << ""\"" BuildStamp=\"""" << datestring << ""-Experimental\"" Name=\""""
     << m_DartConfiguration[""Site""] << ""\"">\n""
     << ""<Build>\n""
     << ""  <StartDateTime>"" << ::CurrentTime() << ""</StartDateTime>\n""
     << ""  <BuildCommand>"" << m_DartConfiguration[""MakeCommand""]
     << ""</BuildCommand>"" << std::endl;
    
  std::vector<cmCTestBuildErrorWarning>::iterator it;
  for ( it = ew.begin(); it != ew.end(); it++ )
    {
    cmCTestBuildErrorWarning *cm = &(*it);
    os << ""  <"" << (cm->m_Error ? ""Error"" : ""Warning"") << "">\n""
       << ""    <BuildLogLine>"" << cm->m_LogLine << ""</BuildLogLine>\n""
       << ""    <Text>"" << cm->m_Text << ""</Text>"" << std::endl;
    if ( cm->m_SourceFile.size() > 0 )
      {
      os << ""    <SourceFile>"" << cm->m_SourceFile << ""</SourceFile>"" 
         << std::endl;
      }
    if ( cm->m_SourceFileTail.size() > 0 )
      {
      os << ""    <SourceFileTail>"" << cm->m_SourceFileTail 
         << ""</SourceFileTail>"" << std::endl;
      }
    if ( cm->m_LineNumber >= 0 )
      {
      os << ""    <SourceLineNumber>"" << cm->m_LineNumber 
         << ""</SourceLineNumber>"" << std::endl;
      }
    os << ""    <PreContext>"" << cm->m_PreContext << ""</PreContext>\n""
       << ""    <PostContext>"" << cm->m_PostContext << ""</PostContext>\n""
       << ""  </"" << (cm->m_Error ? ""Error"" : ""Warning"") << "">"" 
       << std::endl;
    }
  os << ""  <Log Encoding=\""base64\"" Compression=\""/bin/gzip\"">\n    </Log>\n""
     << ""  <EndDateTime>"" << ::CurrentTime() << ""</EndDateTime>\n""
     << ""</Build>\n""
     << ""</Site>"" << std::endl;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_946.cpp,"[3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 125, 0, 0, 5, 5, 0, 0, 4, 47, 0, 0, 0, 0, 2, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 2, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 4, 0, 6, 5, 2, 0, 10, 0, 0, 8, 0, 10, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_946.cpp,6
ea87271c4a4e534772d7d8f14b70b6fd8ac648be,"Reorganization, cleanup and some improvement in dart emulation",[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_751.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_751.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_751.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1450.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1450.cpp,795,929,800,-1,"sprintf(datestring, ""%4d%02d%02d-%d%d"",
          lctime->tm_year + 1900,
          lctime->tm_mon,
          lctime->tm_mday,
          lctime->tm_hour,
          lctime->tm_min);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_947.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_947.cpp,"{
  if ( !m_DartMode )
    {
    return;
    }

  if ( m_TestResults.size() == 0 )
    {
    return;
    }

  time_t tctime = time(0);
  struct tm *lctime = gmtime(&tctime);
  char datestring[100];
  sprintf(datestring, ""%4d%02d%02d-%d%d"",
          lctime->tm_year + 1900,
          lctime->tm_mon,
          lctime->tm_mday,
          lctime->tm_hour,
          lctime->tm_min);

  os << ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n""
     << ""<Site BuildName=\"""" << m_DartConfiguration[""BuildName""]
     << ""\"" BuildStamp=\"""" << datestring << ""-Experimental\"" Name=\""""
     << m_DartConfiguration[""Site""] << ""\"">\n""
     << ""<Testing>\n""
     << ""  <StartDateTime>"" << ::CurrentTime() << ""</StartDateTime>\n""
     << ""  <TestList>\n"";
  tm_TestResultsVector::size_type cc;
  for ( cc = 0; cc < m_TestResults.size(); cc ++ )
    {
    cmCTestTestResult *result = &m_TestResults[cc];
    os << ""    <Test>"" << result->m_Path << ""/"" << result->m_Name 
       << ""</Test>"" << std::endl;
    }
  os << ""  </TestList>\n"";
  for ( cc = 0; cc < m_TestResults.size(); cc ++ )
    {
    cmCTestTestResult *result = &m_TestResults[cc];
    os << ""  <Test Status=\"""" << (result->m_ReturnValue?""failed"":""passed"") 
       << ""\"">\n""
       << ""    <Name>"" << result->m_Name << ""</Name>\n""
       << ""    <Path>"" << result->m_Path << ""</Path>\n""
       << ""    <FullName>"" << result->m_Path << ""/"" << result->m_Name << ""</FullName>\n""
       << ""    <FullCommandLine>"" << result->m_FullCommandLine << ""</FullCommandLine>\n""
       << ""    <Results>"" << std::endl;
    if ( result->m_ReturnValue )
      {
      os << ""      <NamedMeasurement type=\""text/string\"" name=\""Exit Code\""><Value>""
         << ""CHILDSTATUS"" << ""</Value></NamedMeasurement>\n""
         << ""      <NamedMeasurement type=\""text/string\"" name=\""Exit Value\""><Value>""
         << result->m_ReturnValue << ""</Value></NamedMeasurement>"" << std::endl;
      }
    os << ""      <NamedMeasurement type=\""numeric/double\"" ""
       << ""name=\""Execution Time\""><Value>""
       << result->m_ExecutionTime << ""</Value></NamedMeasurement>\n""
       << ""      <NamedMeasurement type=\""text/string\"" ""
       << ""name=\""Completion Status\""><Value>""
       << result->m_CompletionStatus << ""</Value></NamedMeasurement>\n""
       << ""      <Measurement>\n""
       << ""        <Value>"" << result->m_Output << ""</value>\n""
       << ""      </Measurement>\n""
       << ""    </Results>\n""
       << ""  </Test>"" << std::endl;
    }
  
  os << ""<EndDateTime>"" << ::CurrentTime() << ""</EndDateTime>\n""
     << ""</Testing>\n""
     << ""</Site>"" << std::endl;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_947.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 6, 0, 0, 0, 0, 129, 0, 0, 6, 6, 0, 0, 6, 57, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111, 1, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 5, 0, 6, 4, 1, 0, 8, 0, 0, 8, 0, 9, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_947.cpp,15
a7692d84f038d24e167fdc8576713218ddcfb2f0,Cleanups and hopefully now it works on all windows platforms,[],Source/cmWin32ProcessExecution.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_755.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_755.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_755.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1455.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1455.cpp,61,61,77,-1,"printf(""%d - %s: %s (%d)\n"",line,str,msg, lastmsg);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_948.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_948.cpp,"{
  DWORD lastmsg = GetLastError();
  LPVOID msg;
  FormatMessage(
    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
    NULL,
    lastmsg,
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
    (LPTSTR) &msg,
    0,
    NULL
  );
  printf(""%d - %s: %s (%d)\n"",line,str,msg, lastmsg);
  LocalFree(msg);
  ::SetLastError(ERROR_SUCCESS);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_948.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 26, 0, 0, 2, 2, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 16, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_948.cpp,13
aad36568ea85acc1305e1f3cad2b5e307d25472d,It is late and it at least seems to work better than before...,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_756.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_756.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_756.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1457.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1457.cpp,1430,1430,1436,1436,"printf(""%s"",buf);",std::cout << buf << std::flush;,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_949.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_949.cpp,"{
	  //std::cout << ""Read data..."" << std::endl;
          ReadFile(read_stdout,buf,1023,&bread,NULL);
 
//read the stdout pipe 
          printf(""%s"",buf);
          memset(buf, 0, sizeof(buf));
 
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_949.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 14, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_949.cpp,112
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,135,-1,"f(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_950.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_950.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_950.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_950.cpp,115
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,136,157,"fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");","fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_951.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_951.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_951.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_951.cpp,116
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,137,142,"fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");","fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE C)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_952.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_952.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_952.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_952.cpp,117
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,138,166,"fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");","fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_953.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_953.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_953.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_953.cpp,118
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,139,160,"fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");","fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_954.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_954.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_954.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_954.cpp,119
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,137,146,,"fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE CXX)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_955.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_955.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_955.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_955.cpp,117
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,138,158,,"fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS}""
              "" ${CMAKE_ANSI_CXXFLAGS}\"")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_956.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_956.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_956.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_956.cpp,118
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,139,165,,"fprintf(fout, ""IF (CMAKE_ANSI_CFLAGS)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_957.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_957.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_957.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_957.cpp,119
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,139,167,,"fprintf(fout, ""ENDIF (CMAKE_ANSI_CFLAGS)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_958.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_958.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return -1;
      }
    fprintf(fout, ""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""  SET(CMAKE_C_FLAGS \""${CMAKE_C_FLAGS} ${CMAKE_ANSI_CFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    // handle any compile flags we need to pass on
    if (compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }
    
    fprintf(fout, ""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_958.cpp,"[2, 0, 1, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 0, 64, 0, 0, 2, 2, 0, 0, 3, 17, 0, 0, 0, 0, 1, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 0, 51, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 0, 0, 20, 0, 0, 15, 0, 26, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_958.cpp,119
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,140,169,,"fprintf(fout, ""ADD_DEFINITIONS(${COMPILE_DEFINITIONS})\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_959.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_959.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_959.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_959.cpp,0
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,141,170,,"fprintf(fout, ""INCLUDE_DIRECTORIES(${INCLUDE_DIRECTORIES})\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_960.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_960.cpp,"(compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_960.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 6, 0, 0, 3, 0, 7, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_960.cpp,121
561a3da2043c3fbebd1f90c88842513625076aed,"Several changes: COMPILE_DEFINITIONS is now depricated. If you want to specify some, use CMAKE_FLAGS -DCMAKE_DEFINITIONS:STRING=...; same goes for libraries, include path, ... It now detects wether the file is C or C++ and uses the apropriate project command, it also does the right thing when doing try_compile, so it does not execute configure for every single try_compile",[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_758.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_758.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1459.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1459.cpp,133,133,141,171,,"fprintf(fout, ""LINK_DIRECTORIES(${LINK_DIRECTORIES})\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_961.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_961.cpp,"(compileFlags.size())
      {
      fprintf(fout, ""ADD_DEFINITIONS( "");
      for (i = 0; i < compileFlags.size(); ++i)
        {
        fprintf(fout,""%s "",compileFlags[i].c_str());
        }
      fprintf(fout, "")\n"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_961.cpp,"[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 19, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 6, 0, 0, 3, 0, 7, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_961.cpp,121
d4f5545007c99259dcb7414d975a5446d5163933,updated to try compile,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_760.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1461.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1461.cpp,89,108,98,119,,"fprintf(fout, ""ADD_DEFINITIONS( "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_962.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_962.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    std::string outFileName = tmpString + ""/CMakeLists.txt"";
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return false;
      }
    fprintf(fout,""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout,""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_962.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 3, 3, 0, 0, 3, 13, 0, 0, 0, 0, 1, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 0, 0, 13, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_962.cpp,78
d4f5545007c99259dcb7414d975a5446d5163933,updated to try compile,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_760.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1461.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1461.cpp,89,108,98,122,,"fprintf(fout,""%s "",compileFlags[i].c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_963.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_963.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    std::string outFileName = tmpString + ""/CMakeLists.txt"";
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return false;
      }
    fprintf(fout,""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout,""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_963.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 3, 3, 0, 0, 3, 13, 0, 0, 0, 0, 1, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 0, 0, 13, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_963.cpp,78
d4f5545007c99259dcb7414d975a5446d5163933,updated to try compile,[],Source/cmTryCompileCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_760.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_760.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1461.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1461.cpp,89,108,98,124,,"fprintf(fout, "")\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_964.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_964.cpp,"{
    // remove any CMakeCache.txt files so we will have a clean test
    std::string ccFile = tmpString + ""/CMakeCache.txt"";
    cmSystemTools::RemoveFile(ccFile.c_str());
    
    // we need to create a directory and CMakeList file etc...
    // first create the directories
    sourceDirectory = binaryDirectory;

    // now create a CMakeList.txt file in that directory
    std::string outFileName = tmpString + ""/CMakeLists.txt"";
    FILE *fout = fopen(outFileName.c_str(),""w"");
    if (!fout)
      {
      cmSystemTools::Error(""Failed to create CMakeList file for "", 
                           outFileName.c_str());
      return false;
      }
    fprintf(fout,""PROJECT(CMAKE_TRY_COMPILE)\n"");
    fprintf(fout, ""IF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout, ""  SET(CMAKE_CXX_FLAGS \""${CMAKE_CXX_FLAGS} ${CMAKE_ANSI_CXXFLAGS}\"")\n"");
    fprintf(fout, ""ENDIF (CMAKE_ANSI_CXXFLAGS)\n"");
    fprintf(fout,""ADD_EXECUTABLE(cmTryCompileExec \""%s\"")\n"",argv[2].c_str());
    fclose(fout);
    projectName = ""CMAKE_TRY_COMPILE"";
    targetName = ""cmTryCompileExec"";
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_964.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 48, 0, 0, 3, 3, 0, 0, 3, 13, 0, 0, 0, 0, 1, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 0, 0, 13, 0, 0, 11, 0, 17, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_964.cpp,78
6769e8447291ab73cbf904a9470e4a7094c34e4d,Improve message handler to include client data.,[],Source/CursesDialog/ccmake.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_761.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_761.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_761.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1462.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1462.cpp,52,52,56,57,"cmCursesForm::CurrentForm->AddError(message, title);","self->AddError(message, title);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_965.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_965.cpp,"{
  cmCursesForm::CurrentForm->AddError(message, title);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_965.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_965.cpp,2
bea21587cf35f9d373314dd67c24b99fd0e11e49,updated makefile moved commands into cmake and fixed try compile,[],Source/cmMakefile.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_763.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_763.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_763.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1464.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1464.cpp,898,867,909,-1,"sprintf(tmp,""Version %d.%d"", cmMakefile::GetMajorVersion(),
          cmMakefile::GetMinorVersion());",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_966.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_966.cpp,"{
  // Open the supplied filename
  
  // Loop over all registered commands and print out documentation
  const char *name;
  const char *terse;
  const char *full;
  char tmp[1024];
  sprintf(tmp,""Version %d.%d"", cmMakefile::GetMajorVersion(),
          cmMakefile::GetMinorVersion());
  f << ""<html>\n"";
  f << ""<h1>Documentation for commands of CMake "" << tmp << ""</h1>\n"";
  f << ""<ul>\n"";
  for(RegisteredCommandsMap::iterator j = m_Commands.begin();
      j != m_Commands.end(); ++j)
    {
    name = (*j).second->GetName();
    terse = (*j).second->GetTerseDocumentation();
    full = (*j).second->GetFullDocumentation();
    f << ""<li><b>"" << name << ""</b> - "" << terse << std::endl
      << ""<br><i>Usage:</i> "" << full << ""</li>"" << std::endl << std::endl;
    }
  f << ""</ul></html>\n"";
  return 1;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_966.cpp,"[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 65, 0, 0, 4, 5, 0, 0, 2, 12, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 1, 0, 0, 0, 8, 0, 0, 9, 0, 4, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_966.cpp,9
a4eebcb5b179aa1833c844a7a5f083ef5d002690,ERR: Fix for borland in generated code.  vtkCommand is ambiguously both a function and a class.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_764.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_764.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_764.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1465.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1465.cpp,249,249,253,251,,"fprintf(fout,""int vtkCommandForward(ClientData cd, Tcl_Interp *interp,\n""
                 ""                      int argc, char *argv[]){\n""
                 ""  return vtkCommand(cd, interp, argc, argv);\n""
                 ""}\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_967.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_967.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_967.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_967.cpp,0
25ff4552b3d17c9c4f601c7f488710c4350323d1,new arch,[],Source/MFCDialog/CMakeSetupDialog.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_765.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_765.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_765.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1466.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1466.cpp,266,265,268,267,"sprintf(tmp,""Version %d.%d - %s"", cmMakefile::GetMajorVersion(),
          cmMakefile::GetMinorVersion(), cmMakefile::GetReleaseVersion());","sprintf(tmp,""Version %d.%d - %s"", cmake::GetMajorVersion(),
          cmake::GetMinorVersion(), cmake::GetReleaseVersion());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_968.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_968.cpp,"{
  CDialog::OnInitDialog();
  this->DragAcceptFiles(true);

  // Add ""Create shortcut"" menu item to system menu.

  // IDM_CREATESHORTCUT must be in the system command range.
  ASSERT((IDM_CREATESHORTCUT & 0xFFF0) == IDM_CREATESHORTCUT);
  ASSERT(IDM_CREATESHORTCUT < 0xF000);

  // Add ""About..."" menu item to system menu.

  // IDM_ABOUTBOX must be in the system command range.
  ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
  ASSERT(IDM_ABOUTBOX < 0xF000);

  CMenu* pSysMenu = GetSystemMenu(FALSE);
  if (pSysMenu != NULL)
    {
    CString strCreateShortcutMenu;
    strCreateShortcutMenu.LoadString(IDS_CREATESHORTCUT);
    if (!strCreateShortcutMenu.IsEmpty())
      {
      pSysMenu->AppendMenu(MF_SEPARATOR);
      pSysMenu->AppendMenu(MF_STRING, 
                           IDM_CREATESHORTCUT, 
                           strCreateShortcutMenu);
      }

    CString strAboutMenu;
    strAboutMenu.LoadString(IDS_ABOUTBOX);
    if (!strAboutMenu.IsEmpty())
      {
      pSysMenu->AppendMenu(MF_SEPARATOR);
      pSysMenu->AppendMenu(MF_STRING, 
                           IDM_ABOUTBOX, 
                           strAboutMenu);
      }
    }

  // Set the icon for this dialog.  The framework does this automatically
  //  when the application's main window is not a dialog
  SetIcon(m_hIcon, TRUE);			// Set big icon
  SetIcon(m_hIcon, FALSE);		// Set small icon
  // Load source and build dirs from registry
  this->LoadFromRegistry();
  this->m_CMakeInstance = new cmake;
  std::vector<std::string> names;
  this->m_CMakeInstance->GetRegisteredGenerators(names);
  for(std::vector<std::string>::iterator i = names.begin();
      i != names.end(); ++i)
    {
    m_GeneratorChoice.AddString(i->c_str());
    }
  if (m_GeneratorChoiceString == _T("""")) 
    {
    m_GeneratorChoiceString = ""Visual Studio 6"";
    }

  // try to load the cmake cache from disk
  this->LoadCacheFromDiskToGUI();
  m_WhereBuildControl.LimitText(2048);
  m_WhereSourceControl.LimitText(2048);
  m_GeneratorChoice.LimitText(2048);
    
  // Set the version number
  char tmp[1024];
  sprintf(tmp,""Version %d.%d - %s"", cmMakefile::GetMajorVersion(),
          cmMakefile::GetMinorVersion(), cmMakefile::GetReleaseVersion());
  SetDlgItemText(IDC_CMAKE_VERSION, tmp);
  this->UpdateData(FALSE);
  return TRUE;  // return TRUE  unless you set the focus to a control
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_968.cpp,"[4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 146, 0, 0, 5, 6, 0, 0, 3, 12, 0, 0, 0, 0, 1, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 72, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 1, 0, 5, 4, 0, 0, 36, 0, 0, 26, 0, 36, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_968.cpp,68
2c7e9b3b59cda840adc2aa4c3bfe1ffa0707be99,new architecture,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_766.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_766.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_766.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1467.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1467.cpp,362,368,376,386,"sprintf(firstLine,  ""Press [c] to configure"");","sprintf(firstLine,  ""Press [c] to configure                                   "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_969.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_969.cpp,"{
      sprintf(firstLine,  ""Press [c] to configure"");
      }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_969.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_969.cpp,31
2c7e9b3b59cda840adc2aa4c3bfe1ffa0707be99,new architecture,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_766.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_766.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_766.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1468.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1468.cpp,504,514,506,516,"sprintf(vertmp,""CMake Version %d.%d - %s"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion(),cmMakefile::GetReleaseVersion());","sprintf(vertmp,""CMake Version %d.%d - %s"", cmake::GetMajorVersion(),
	  cmake::GetMinorVersion(),cmake::GetReleaseVersion());",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_970.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_970.cpp,"{
  int x,y;
  getmaxyx(stdscr, y, x);
  // If window size is too small, display error and return
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       x < m_InitialWidth               ||
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_clear();
    curses_move(0,0);
    char fmt[] = ""Window is too small. A size of at least %dx%d is required."";
    printw(fmt,
	   (cmCursesMainForm::MIN_WIDTH < m_InitialWidth ?
	    m_InitialWidth : cmCursesMainForm::MIN_WIDTH), 
	   cmCursesMainForm::MIN_HEIGHT);
    touchwin(stdscr); 
    wrefresh(stdscr); 
    return;
    }

  // Get the key of the current entry
  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  cmCursesWidget* lbl = reinterpret_cast<cmCursesWidget*>(field_userptr(
    m_Fields[index-2]));
  const char* curField = lbl->GetValue();

  // Get the help string of the current entry
  // and add it to the help string
  char help[128];
  const char* helpString;
  cmCacheManager::CacheEntry *entry = 
    this->m_CMakeInstance->GetCacheManager()->GetCacheEntry(curField);
  if (entry)
    {
    helpString = entry->m_HelpString.c_str();
    strncpy(help, helpString, 127);
    help[127] = '\0';
    }
  else
    {
    sprintf(help,"" "");
    }


  // Join the key, help string and pad with spaces
  // (or truncate) as necessary
  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int helpLen = strlen(help);

  int width;
  if (x < cmCursesMainForm::MAX_WIDTH )
    {
    width = x;
    }
  else
    {
    width = cmCursesMainForm::MAX_WIDTH;
    }

  if (curFieldLen >= width)
    {
    strncpy(bar, curField, width);
    }
  else
    {
    strcpy(bar, curField);
    bar[curFieldLen] = ':';
    bar[curFieldLen+1] = ' ';
    if (curFieldLen + helpLen + 2 >= width)
      {
      strncpy(bar+curFieldLen+2, help, width
	- curFieldLen - 2);
      }
    else
      {
      strcpy(bar+curFieldLen+2, help);
      for(i=curFieldLen+helpLen+2; i < width; ++i) 
	{ 
	bar[i] = ' '; 
	}
      }
    }

  bar[width] = '\0';

  // Display CMake version info on the next line
  // We want to display this on the right
  char version[cmCursesMainForm::MAX_WIDTH];
  char vertmp[128];
  sprintf(vertmp,""CMake Version %d.%d - %s"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion(),cmMakefile::GetReleaseVersion());
  int sideSpace = (width-strlen(vertmp));
  for(i=0; i<sideSpace; i++) { version[i] = ' '; }
  sprintf(version+sideSpace, ""%s"", vertmp);
  version[width] = '\0';

  // Now print both lines
  curses_move(y-5,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  curses_move(y-4,0);
  printw(version);
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_970.cpp,"[5, 0, 2, 0, 0, 0, 1, 0, 0, 0, 12, 0, 0, 0, 2, 207, 0, 0, 16, 18, 0, 0, 11, 29, 0, 0, 0, 0, 5, 0, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 1, 117, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 13, 0, 8, 6, 5, 0, 36, 0, 0, 31, 0, 51, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_970.cpp,92
f87057813da84451aa60e85d3992b89e1f3c7bb0,FIX: la commande créait du code C++. Du code C devrait faire l'affaire.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_768.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_768.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_768.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1471.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1471.cpp,202,205,201,204,"""      printf(\""%3d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n""
    ""      }\n""
    ""    printf(\""To run a test, enter the test number: \"");\n""
    ""    int testNum = 0;\n""
    ""    scanf(\""%d\"", &testNum);\n""
    ""    if (testNum >= NumTests)\n""
    ""      {\n"";","""      printf(\""%3d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n""
    ""      }\n""
    ""    printf(\""To run a test, enter the test number: \"");\n""
    ""    testNum = 0;\n""
    ""    scanf(\""%d\"", &testNum);\n""
    ""    if (testNum >= NumTests)\n""
    ""      {\n"";",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_971.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_971.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_971.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_971.cpp,0
20b1d940a407c4e8184e0aff73fa76ce0dafcb2b,"BUG: Generated call to Tcl_CreateCommand for vtkCommand should cast pointer to extern ""C"" version.",[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_769.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_769.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_769.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1472.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1472.cpp,229,229,231,231,,"fprintf(fout,
          ""extern \""C\""\n""
          ""{\n""
          ""  typedef int (*vtkTclCommandType)(ClientData, Tcl_Interp *,int, char *[]);\n""
          ""}\n""
          ""\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_972.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_972.cpp,"(i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_972.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 5, 0, 0, 1, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_972.cpp,22
a07cdc75e19f957b8ea3c6d5cd35514372eeb21a,use stream not sprintf,[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_770.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_770.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_770.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1473.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1473.cpp,997,997,1000,1000,"sprintf(msg, ""FilesDiffer failed to read files (allocated: %lu, source: %lu, dest: %lu)"", statSource.st_size, finSource.gcount(), finDestination.gcount());","msg << ""FilesDiffer failed to read files (allocated: "" 
        << statSource.st_size << "", read source: "" <<  finSource.gcount() 
        << "", read dest: "" << finDestination.gcount() << std::ends;",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_973.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_973.cpp,"{
    char msg[256];
    sprintf(msg, ""FilesDiffer failed to read files (allocated: %lu, source: %lu, dest: %lu)"", statSource.st_size, finSource.gcount(), finDestination.gcount());
    cmSystemTools::Error(msg);
    delete [] source_buf;
    delete [] dest_buf;
    return false;
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_973.cpp,"[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 20, 0, 0, 1, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 6, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_973.cpp,49
b0eb1031b71a403bb5af7b2bdea926eb39e13270,ENH: small formatting enh,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_771.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_771.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_771.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1474.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1474.cpp,130,130,129,129,"""    printf(\""Available tests:\\n\"");\n""
    ""    for (i =0; i < NumTests; ++i)\n""
    ""      {\n""
    ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n""
    ""      }\n""
    ""    printf(\""To run a test, enter the test number: \"");\n""
    ""    int testNum = 0;\n""
    ""    scanf(\""%d\"", &testNum);\n""
    ""    if (testNum >= NumTests)\n""
    ""      {\n""
    ""      printf(\""%d is an invalid test number.\\n\"", testNum);\n""
    ""      return -1;\n""
    ""      }\n""
    ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";","""    printf(\""Available tests:\\n\"");\n""
    ""    for (i =0; i < NumTests; ++i)\n""
    ""      {\n""
    ""      printf(\""%3d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n""
    ""      }\n""
    ""    printf(\""To run a test, enter the test number: \"");\n""
    ""    int testNum = 0;\n""
    ""    scanf(\""%d\"", &testNum);\n""
    ""    if (testNum >= NumTests)\n""
    ""      {\n""
    ""      printf(\""%3d is an invalid test number.\\n\"", testNum);\n""
    ""      return -1;\n""
    ""      }\n""
    ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_974.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_974.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_974.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_974.cpp,0
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,108,-1,"fout << ""    printf(\""Available tests:\\n\"");\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_975.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_975.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_975.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_975.cpp,88
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,111,-1,"fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_976.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_976.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_976.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_976.cpp,91
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,113,-1,"fout << ""    printf(\""To run a test, enter the test number: \"");\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_977.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_977.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_977.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_977.cpp,93
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,118,-1,"fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_978.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_978.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_978.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_978.cpp,98
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,133,-1,"fout << ""  printf(\""Available tests:\\n\"");\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_979.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_979.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_979.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_979.cpp,113
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,136,-1,"fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_980.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_980.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_980.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_980.cpp,116
95519ef1b7dcf4193aeccb1a0bc7f3344678ce8e,ENH: add -R (similar to ctest but use substr instead of regexp). indent.,[],Source/cmCreateTestSourceList.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_772.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_772.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1475.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1475.cpp,80,83,138,-1,"fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_981.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_981.cpp,"{
  if (argsIn.size() < 3)
    {
      this->SetError(""called with wrong number of arguments."");
      return false;
    }

  std::vector<std::string> args;
  cmSystemTools::ExpandListArguments(argsIn, args, true);
  
  std::vector<std::string>::iterator i = args.begin();

  // Name of the source list

  const char* sourceList = i->c_str();
  ++i;

  // Name of the test driver

  std::string driver = m_Makefile->GetCurrentOutputDirectory();
  driver += ""/"";
  driver += *i;
  driver += "".cxx"";
  ++i;

  std::ofstream fout(driver.c_str());
  if(!fout)
    {
    std::string err = ""Could not create file "";
    err += driver;
    err += "" for cmCreateTestSourceList command."";
    this->SetError(err.c_str());
    return false;
    }

  // Create the test driver file

  fout << ""#include <stdio.h>\n"";
  fout << ""#include <string.h>\n"";
  fout << ""// forward declare test functions\n"";

  std::vector<std::string>::iterator testsBegin = i;
  std::vector<std::string> tests_filename;

  // The rest of the arguments consist of a list of test source files.
  // Sadly, they can be in directories. Let's modify each arg to get
  // a unique function name for the corresponding test, and push the 
  // real source filename to the tests_filename var (used at the end). 
  // For the moment:
  //   - replace spaces ' ', ':' and '/' with underscores '_'

  for(i = testsBegin; i != args.end(); ++i)
    {
    tests_filename.push_back(*i);
    cmSystemTools::ConvertToUnixSlashes(*i);
    cmSystemTools::ReplaceString(*i, "" "", ""_"");
    cmSystemTools::ReplaceString(*i, ""/"", ""_"");
    cmSystemTools::ReplaceString(*i, "":"", ""_"");
    fout << ""int "" << *i << ""(int, char**);\n"";
    }

  fout << ""// Create map \n"";
  fout << ""typedef int (*MainFuncPointer)(int , char**);\n"";
  fout << ""struct functionMapEntry\n""
       << ""{\n""
       << ""const char* name;\n""
       << ""MainFuncPointer func;\n""
       << ""};\n\n"";
  fout << ""functionMapEntry cmakeGeneratedFunctionMapEntries[] = {\n"";

  int numTests = 0;
  for(i = testsBegin; i != args.end(); ++i)
    {
    fout << ""{\"""" << *i << ""\"", "" << *i << ""},\n"";
    numTests++;
    }

  fout << ""};\n"";
  fout << ""int main(int ac, char** av)\n""
       << ""{\n"";
  fout << ""  int NumTests = "" << numTests << "";\n"";
  fout << ""  int i;\n"";
  fout << ""  if(ac < 2)\n"";
  fout << ""    {\n"";
  fout << ""    // if there is only one test, then run it with the arguments\n"";
  fout << ""    if(NumTests == 1)\n"";
  fout << ""      { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""    printf(\""Available tests:\\n\"");\n"";
  fout << ""    for(i =0; i < NumTests; ++i)\n"";
  fout << ""      {\n"";
  fout << ""      printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""      }\n"";
  fout << ""    printf(\""To run a test, enter the test number: \"");\n"";
  fout << ""    int testNum = 0;\n"";
  fout << ""    scanf(\""%d\"", &testNum);\n"";
  fout << ""    if(testNum >= NumTests)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d is an invalid test number.\\n\"", testNum);\n"";
  fout << ""    return -1;\n"";
  fout << ""    }\n"";
  fout << ""    return (*cmakeGeneratedFunctionMapEntries[testNum].func)(ac-1, av+1);\n"";
  fout << ""    }\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    if(strcmp(cmakeGeneratedFunctionMapEntries[i].name, av[1]) == 0)\n"";
  fout << ""      {\n"";
  fout << ""      return (*cmakeGeneratedFunctionMapEntries[i].func)(ac-1, av+1);\n"";
  fout << ""      }\n"";
  fout << ""    }\n"";
  fout << ""  // if there is only one test, then run it with the arguments\n"";
  fout << ""  if(NumTests == 1)\n"";
  fout << ""    { return (*cmakeGeneratedFunctionMapEntries[0].func)(ac, av); }\n"";
  fout << ""  printf(\""Available tests:\\n\"");\n"";
  fout << ""  for(i =0; i < NumTests; ++i)\n"";
  fout << ""    {\n"";
  fout << ""    printf(\""%d. %s\\n\"", i, cmakeGeneratedFunctionMapEntries[i].name);\n"";
  fout << ""    }\n"";
  fout << ""  printf(\""Failed: %s is an invalid test name.\\n\"", av[1]);\n"";
  fout << ""  return -1;\n"";
  fout << ""}\n"";
  fout.close();

  // Create the source list

  cmSourceFile cfile;
  cfile.SetIsAnAbstractClass(false);
  cfile.SetName(args[1].c_str(), 
                m_Makefile->GetCurrentOutputDirectory(),
                ""cxx"", 
                false);
  m_Makefile->AddSource(cfile, sourceList);
  
  for(i = tests_filename.begin(); i != tests_filename.end(); ++i)
    {
    cmSourceFile cfile;
    cfile.SetIsAnAbstractClass(false);
    cfile.SetName(i->c_str(), 
                  m_Makefile->GetCurrentDirectory(),
                  ""cxx"", 
                  false);
    m_Makefile->AddSource(cfile, sourceList);
    }

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_981.cpp,"[2, 0, 3, 0, 0, 0, 3, 0, 0, 0, 6, 0, 0, 0, 1, 230, 0, 0, 11, 11, 0, 0, 9, 84, 0, 0, 0, 0, 1, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 134, 0, 130, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 1, 0, 5, 2, 0, 0, 34, 0, 0, 74, 0, 35, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_981.cpp,118
6fc30804589219d63062fe20cc2cf3ce617a5ce6,"BUG: fix RunCommand again... back to system, but with GetShortPath",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_774.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_774.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_774.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1477.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1477.cpp,974,974,1077,-1,"printf(""%s"",buf);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_982.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_982.cpp,"{
          ReadFile(read_stdout,buf,1023,&bread,NULL); //read the stdout pipe
          printf(""%s"",buf);
          memset(buf, 0, sizeof(buf));
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_982.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 14, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_982.cpp,83
6fc30804589219d63062fe20cc2cf3ce617a5ce6,"BUG: fix RunCommand again... back to system, but with GetShortPath",[],Source/cmSystemTools.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_774.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_774.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_774.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1477.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1477.cpp,974,974,1077,-1,"printf(""%s"",buf);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_983.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_983.cpp,"{
          ReadFile(read_stdout,buf,1023,&bread,NULL); //read the stdout pipe
          printf(""%s"",buf);
          memset(buf, 0, sizeof(buf));
          }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_983.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 14, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 3, 0, 11, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_983.cpp,83
d8088655ffdbe947c9e701e49f2b95d6525b6f5d,minor fix,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_776.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_776.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_776.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1479.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1479.cpp,270,273,272,275,"fprintf(fout,""void vtkCommonDeleteAssocData(ClientData cd, Tcl_Interp *)\n"");","fprintf(fout,""void vtkCommonDeleteAssocData(ClientData cd)\n"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_984.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_984.cpp,"{
    fprintf(fout,""void vtkCommonDeleteAssocData(ClientData cd, Tcl_Interp *)\n"");
    fprintf(fout,""  {\n"");
    fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");
    fprintf(fout,""  delete tis;\n  }\n"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_984.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0, 8, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_984.cpp,60
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesLongMessageForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_777.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_777.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_777.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1480.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1480.cpp,89,89,91,91,"sprintf(firstLine,  ""O)k"");","sprintf(firstLine,  ""Press [e] to exit help"");",3,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_985.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_985.cpp,"{
  int x,y;
  getmaxyx(stdscr, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512];
  sprintf(firstLine,  ""O)k"");

  curses_move(y-2,0);
  printw(firstLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_985.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 26, 0, 0, 2, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 1, 0, 1, 1, 0, 0, 5, 0, 0, 5, 0, 9, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_985.cpp,10
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,304,348,"sprintf(firstLine,  ""C)onfigure                 G)enerate and Exit            H)elp"");","sprintf(firstLine,  ""Press [c] to configure"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_986.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_986.cpp,"{
    sprintf(firstLine,  ""C)onfigure                 G)enerate and Exit            H)elp"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_986.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_986.cpp,12
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,308,344,"sprintf(firstLine,  ""C)onfigure                                               H)elp"");","sprintf(firstLine,  ""Press [c] to configure     Press [g] to generate and exit"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_987.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_987.cpp,"{
    sprintf(firstLine,  ""C)onfigure                                               H)elp"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_987.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_987.cpp,16
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,312,352,"sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (On)"");","sprintf(thirdLine,  ""Press [t] to toggle advanced mode (Currently On)"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_988.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_988.cpp,"{
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (On)"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_988.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_988.cpp,20
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,316,359,"sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (Off)"");","sprintf(secondLine, ""Press [h] for help         Press [q] to quit without generating"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_989.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_989.cpp,"{
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (Off)"");
    }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_989.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_989.cpp,24
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,319,356,,"sprintf(thirdLine,  ""Press [t] to toggle advanced mode (Currently Off)"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_990.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_990.cpp,"{
  int x,y;
  getmaxyx(stdscr, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  if (m_OkToGenerate)
    {
    sprintf(firstLine,  ""C)onfigure                 G)enerate and Exit            H)elp"");
    }
  else
    {
    sprintf(firstLine,  ""C)onfigure                                               H)elp"");
    }
  if (m_AdvancedMode)
    {
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (On)"");
    }
  else
    {
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (Off)"");
    }

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_990.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 40, 0, 0, 2, 4, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 3, 3, 2, 0, 10, 0, 0, 10, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_990.cpp,27
69cb66f7ffd5541f60026135fa521f0369210bab,Updated toolbar.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_778.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_778.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1481.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1481.cpp,299,325,319,373,,"sprintf(firstLine, ""Page %d of %d"", cw->GetPage(), m_NumberOfPages);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_991.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_991.cpp,"{
  int x,y;
  getmaxyx(stdscr, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  if (m_OkToGenerate)
    {
    sprintf(firstLine,  ""C)onfigure                 G)enerate and Exit            H)elp"");
    }
  else
    {
    sprintf(firstLine,  ""C)onfigure                                               H)elp"");
    }
  if (m_AdvancedMode)
    {
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (On)"");
    }
  else
    {
    sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (Off)"");
    }

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_991.cpp,"[3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 0, 40, 0, 0, 2, 4, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 3, 3, 2, 0, 10, 0, 0, 10, 0, 18, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_991.cpp,27
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1485.cpp,205,242,240,306,"sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");","sprintf(firstLine,  ""C)onfigure                 G)enerate and Exit            H)elp"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_992.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_992.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");
  sprintf(secondLine, ""Q)uit                  H)elp"");

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_992.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 2, 4, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 8, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_992.cpp,10
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1485.cpp,205,242,241,314,"sprintf(secondLine, ""Q)uit                  H)elp"");","sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (On)"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_993.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_993.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");
  sprintf(secondLine, ""Q)uit                  H)elp"");

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_993.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 2, 4, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 8, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_993.cpp,11
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1485.cpp,205,242,244,310,,"sprintf(firstLine,  ""C)onfigure                                               H)elp"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_994.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_994.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");
  sprintf(secondLine, ""Q)uit                  H)elp"");

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_994.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 2, 4, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 8, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_994.cpp,14
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1485.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1485.cpp,205,242,244,318,,"sprintf(secondLine, ""Q)uit Without Generating   T)oggle Advanced Mode (Off)"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_995.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_995.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    return;
    }
  char firstLine[512], secondLine[512];
  sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");
  sprintf(secondLine, ""Q)uit                  H)elp"");

  curses_move(y-2,0);
  printw(firstLine);
  curses_move(y-1,0);
  printw(secondLine);
  pos_form_cursor(m_Form);
  
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_995.cpp,"[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 34, 0, 0, 2, 4, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 1, 1, 0, 0, 8, 0, 0, 8, 0, 14, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_995.cpp,14
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1486.cpp,254,332,273,419,"sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());","sprintf(vertmp,""CMake Version %d.%d"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_996.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_996.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_move(0,0);
    printw(""Window is too small. A size of at least %dx%d is required."",
	   cmCursesMainForm::MIN_WIDTH, cmCursesMainForm::MIN_HEIGHT);
    touchwin(m_Window); 
    wrefresh(m_Window); 
    return;
    }

  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* curField = field_buffer(m_Fields[index-2], 0);

  char version[128];
  sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());

  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int versionLen = strlen(version);
  int leftLen = cmCursesMainForm::IDEAL_WIDTH - versionLen;
  if (curFieldLen >= leftLen)
    {
    strncpy(bar, curField, leftLen);
    }
  else
    {
    strcpy(bar, curField);
    for(i=curFieldLen; i < leftLen; ++i) { bar[i] = ' '; }
    }
  strcpy(bar+leftLen, version);

  if ( x < cmCursesMainForm::MAX_WIDTH )
    {
    if (x > cmCursesMainForm::IDEAL_WIDTH )
      {
      for(i=cmCursesMainForm::IDEAL_WIDTH; i < x; i++)
	{
	bar[i] = ' ';
	}
      }
    bar[x] = '\0';
    }
  else
    {
    for(i=cmCursesMainForm::IDEAL_WIDTH; 
	i < cmCursesMainForm::MAX_WIDTH-1; i++)
      {
      bar[i] = ' ';
      }
    bar[cmCursesMainForm::MAX_WIDTH-1] = '\0';
    }

  curses_move(y-3,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_996.cpp,"[4, 0, 3, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 0, 142, 0, 0, 9, 11, 0, 0, 9, 16, 0, 0, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 8, 0, 7, 4, 2, 0, 21, 0, 0, 19, 0, 33, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_996.cpp,20
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1486.cpp,254,332,279,363,,"sprintf(help,""%127s"", helpString);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_997.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_997.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_move(0,0);
    printw(""Window is too small. A size of at least %dx%d is required."",
	   cmCursesMainForm::MIN_WIDTH, cmCursesMainForm::MIN_HEIGHT);
    touchwin(m_Window); 
    wrefresh(m_Window); 
    return;
    }

  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* curField = field_buffer(m_Fields[index-2], 0);

  char version[128];
  sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());

  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int versionLen = strlen(version);
  int leftLen = cmCursesMainForm::IDEAL_WIDTH - versionLen;
  if (curFieldLen >= leftLen)
    {
    strncpy(bar, curField, leftLen);
    }
  else
    {
    strcpy(bar, curField);
    for(i=curFieldLen; i < leftLen; ++i) { bar[i] = ' '; }
    }
  strcpy(bar+leftLen, version);

  if ( x < cmCursesMainForm::MAX_WIDTH )
    {
    if (x > cmCursesMainForm::IDEAL_WIDTH )
      {
      for(i=cmCursesMainForm::IDEAL_WIDTH; i < x; i++)
	{
	bar[i] = ' ';
	}
      }
    bar[x] = '\0';
    }
  else
    {
    for(i=cmCursesMainForm::IDEAL_WIDTH; 
	i < cmCursesMainForm::MAX_WIDTH-1; i++)
      {
      bar[i] = ' ';
      }
    bar[cmCursesMainForm::MAX_WIDTH-1] = '\0';
    }

  curses_move(y-3,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_997.cpp,"[4, 0, 3, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 0, 142, 0, 0, 9, 11, 0, 0, 9, 16, 0, 0, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 8, 0, 7, 4, 2, 0, 21, 0, 0, 19, 0, 33, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_997.cpp,26
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1486.cpp,254,332,279,367,,"sprintf(help,""%s"", helpString);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_998.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_998.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_move(0,0);
    printw(""Window is too small. A size of at least %dx%d is required."",
	   cmCursesMainForm::MIN_WIDTH, cmCursesMainForm::MIN_HEIGHT);
    touchwin(m_Window); 
    wrefresh(m_Window); 
    return;
    }

  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* curField = field_buffer(m_Fields[index-2], 0);

  char version[128];
  sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());

  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int versionLen = strlen(version);
  int leftLen = cmCursesMainForm::IDEAL_WIDTH - versionLen;
  if (curFieldLen >= leftLen)
    {
    strncpy(bar, curField, leftLen);
    }
  else
    {
    strcpy(bar, curField);
    for(i=curFieldLen; i < leftLen; ++i) { bar[i] = ' '; }
    }
  strcpy(bar+leftLen, version);

  if ( x < cmCursesMainForm::MAX_WIDTH )
    {
    if (x > cmCursesMainForm::IDEAL_WIDTH )
      {
      for(i=cmCursesMainForm::IDEAL_WIDTH; i < x; i++)
	{
	bar[i] = ' ';
	}
      }
    bar[x] = '\0';
    }
  else
    {
    for(i=cmCursesMainForm::IDEAL_WIDTH; 
	i < cmCursesMainForm::MAX_WIDTH-1; i++)
      {
      bar[i] = ' ';
      }
    bar[cmCursesMainForm::MAX_WIDTH-1] = '\0';
    }

  curses_move(y-3,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_998.cpp,"[4, 0, 3, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 0, 142, 0, 0, 9, 11, 0, 0, 9, 16, 0, 0, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 8, 0, 7, 4, 2, 0, 21, 0, 0, 19, 0, 33, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_998.cpp,26
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1486.cpp,254,332,279,372,,"sprintf(help,"" "");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_999.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_999.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_move(0,0);
    printw(""Window is too small. A size of at least %dx%d is required."",
	   cmCursesMainForm::MIN_WIDTH, cmCursesMainForm::MIN_HEIGHT);
    touchwin(m_Window); 
    wrefresh(m_Window); 
    return;
    }

  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* curField = field_buffer(m_Fields[index-2], 0);

  char version[128];
  sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());

  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int versionLen = strlen(version);
  int leftLen = cmCursesMainForm::IDEAL_WIDTH - versionLen;
  if (curFieldLen >= leftLen)
    {
    strncpy(bar, curField, leftLen);
    }
  else
    {
    strcpy(bar, curField);
    for(i=curFieldLen; i < leftLen; ++i) { bar[i] = ' '; }
    }
  strcpy(bar+leftLen, version);

  if ( x < cmCursesMainForm::MAX_WIDTH )
    {
    if (x > cmCursesMainForm::IDEAL_WIDTH )
      {
      for(i=cmCursesMainForm::IDEAL_WIDTH; i < x; i++)
	{
	bar[i] = ' ';
	}
      }
    bar[x] = '\0';
    }
  else
    {
    for(i=cmCursesMainForm::IDEAL_WIDTH; 
	i < cmCursesMainForm::MAX_WIDTH-1; i++)
      {
      bar[i] = ' ';
      }
    bar[cmCursesMainForm::MAX_WIDTH-1] = '\0';
    }

  curses_move(y-3,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_999.cpp,"[4, 0, 3, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 0, 142, 0, 0, 9, 11, 0, 0, 9, 16, 0, 0, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 8, 0, 7, 4, 2, 0, 21, 0, 0, 19, 0, 33, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_999.cpp,26
521d8d9410c7c7bb5958357933c9759035f51828,Improvements to the curses interface.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_780.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_780.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1486.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1486.cpp,254,332,316,423,,"sprintf(version+sideSpace, ""%s"", vertmp);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1000.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1000.cpp,"{
  int x,y;
  getmaxyx(m_Window, y, x);
  if ( x < cmCursesMainForm::MIN_WIDTH  || 
       y < cmCursesMainForm::MIN_HEIGHT )
    {
    curses_move(0,0);
    printw(""Window is too small. A size of at least %dx%d is required."",
	   cmCursesMainForm::MIN_WIDTH, cmCursesMainForm::MIN_HEIGHT);
    touchwin(m_Window); 
    wrefresh(m_Window); 
    return;
    }

  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* curField = field_buffer(m_Fields[index-2], 0);

  char version[128];
  sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());

  char bar[cmCursesMainForm::MAX_WIDTH];
  int i, curFieldLen = strlen(curField);
  int versionLen = strlen(version);
  int leftLen = cmCursesMainForm::IDEAL_WIDTH - versionLen;
  if (curFieldLen >= leftLen)
    {
    strncpy(bar, curField, leftLen);
    }
  else
    {
    strcpy(bar, curField);
    for(i=curFieldLen; i < leftLen; ++i) { bar[i] = ' '; }
    }
  strcpy(bar+leftLen, version);

  if ( x < cmCursesMainForm::MAX_WIDTH )
    {
    if (x > cmCursesMainForm::IDEAL_WIDTH )
      {
      for(i=cmCursesMainForm::IDEAL_WIDTH; i < x; i++)
	{
	bar[i] = ' ';
	}
      }
    bar[x] = '\0';
    }
  else
    {
    for(i=cmCursesMainForm::IDEAL_WIDTH; 
	i < cmCursesMainForm::MAX_WIDTH-1; i++)
      {
      bar[i] = ' ';
      }
    bar[cmCursesMainForm::MAX_WIDTH-1] = '\0';
    }

  curses_move(y-3,0);
  attron(A_STANDOUT);
  printw(bar);
  attroff(A_STANDOUT);  
  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1000.cpp,"[4, 0, 3, 0, 0, 0, 1, 0, 0, 0, 10, 0, 0, 0, 0, 142, 0, 0, 9, 11, 0, 0, 9, 16, 0, 0, 0, 0, 2, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 8, 0, 7, 4, 2, 0, 21, 0, 0, 19, 0, 33, 0, 3, 0, 0, 3, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1000.cpp,63
4848c81428b8b8218eb86f23451ff32d78c039cd,Many improvements.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_782.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1488.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1488.cpp,212,221,231,272,"sprintf(version,""CMake Version %d.%d"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());","sprintf(version,""(CMake Version %d.%d)"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1001.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1001.cpp,"{
  FIELD* cur = current_field(m_Form);
  int index = field_index(cur);
  char* text = field_buffer(m_Fields[index-2], 0);

  int x,y;
  getmaxyx(m_Window, y, x);
  move(y-1,0);
  printw(text);

  char version[128];
  sprintf(version,""CMake Version %d.%d"", cmMakefile::GetMajorVersion(),
	  cmMakefile::GetMinorVersion());
  int len = strlen(version);
  move(y-1, x-len);
  printw(version);

  pos_form_cursor(m_Form);
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1001.cpp,"[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 48, 0, 0, 6, 7, 0, 0, 4, 7, 0, 0, 0, 0, 2, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 2, 0, 0, 0, 0, 0, 13, 0, 0, 7, 0, 19, 0, 0, 0, 0, 0, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1001.cpp,12
4848c81428b8b8218eb86f23451ff32d78c039cd,Many improvements.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_782.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1488.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1488.cpp,212,221,219,239,,"sprintf(firstLine,  ""C)onfigure             G)enerate and Exit"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1002.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1002.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1002.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1002.cpp,0
4848c81428b8b8218eb86f23451ff32d78c039cd,Many improvements.,[],Source/CursesDialog/cmCursesMainForm.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_782.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_782.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1488.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1488.cpp,212,221,219,240,,"sprintf(secondLine, ""Q)uit                  H)elp"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1003.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1003.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1003.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1003.cpp,0
b502515ad1a41b6487d3883db0c133f6e4fe4fe4,memory leak,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_783.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1489.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1489.cpp,269,269,271,273,,"fprintf(fout,""void vtkCommonDeleteAssocData(ClientData cd, Tcl_Interp *)\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1004.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1004.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1004.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1004.cpp,0
b502515ad1a41b6487d3883db0c133f6e4fe4fe4,memory leak,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_783.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1489.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1489.cpp,269,269,271,274,,"fprintf(fout,""  {\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1005.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1005.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1005.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1005.cpp,0
b502515ad1a41b6487d3883db0c133f6e4fe4fe4,memory leak,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_783.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1489.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1489.cpp,269,269,271,275,,"fprintf(fout,""  vtkTclInterpStruct *tis = static_cast<vtkTclInterpStruct*>(cd);\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1006.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1006.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1006.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1006.cpp,0
b502515ad1a41b6487d3883db0c133f6e4fe4fe4,memory leak,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_783.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_783.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1489.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1489.cpp,269,269,271,276,,"fprintf(fout,""  delete tis;\n  }\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1007.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1007.cpp,,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1007.cpp,[],second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1007.cpp,0
08a89bd8dc87fb904d10a0b1718e7c61da725c12,added regexp option,[],Source/ctest.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_786.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_786.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_786.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1492.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1492.cpp,125,128,130,131,"fprintf(stderr,""Testing %-30s "",args[0].c_str());","(name == ""ADD_TEST"")
        {
        if (this->m_UseRegExp && !var.find(args[0].c_str()))
          {
          continue;
          }
        fprintf(stderr,""Testing %-30s "",args[0].c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1008.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1008.cpp,"{
        fprintf(stderr,""Testing %-30s "",args[0].c_str());
        //std::cerr << ""Testing "" << args[0] << "" ... "";
        // find the test executable
        std::string testCommand = this->FindExecutable(args[1].c_str());
        // add the arguments
        std::vector<std::string>::iterator j = args.begin();
        ++j;
        ++j;
        for(;j != args.end(); ++j)
          {   
          testCommand += "" "";
          testCommand += *j;
          }
        /**
         * Run an executable command and put the stdout in output.
         */
        std::string output;
        int retVal;
        
        if (!cmSystemTools::RunCommand(testCommand.c_str(), output, 
                                       retVal, false) || retVal != 0)
          {
          std::cerr << "" Failed\n"";
          if (output != """")
            {
            std::cerr << output.c_str() << ""\n"";
            }
          failed++;
          }
        else
          {
          std::cerr << "" Passed\n"";
          if (output != """")
            {
            std::cerr << output.c_str() << ""\n"";
            }
          passed++;
          }
        }",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1008.cpp,"[3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 74, 0, 0, 4, 4, 0, 0, 3, 12, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 0, 29, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 4, 3, 1, 0, 11, 0, 0, 11, 0, 9, 0, 1, 0, 0, 1, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1008.cpp,42
a2a40b125918797471919f526edea2990e29bc69,updated to handle Tk commands compiled/linked separately. Useful for VTK Tk widgets for example.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1495.cpp,211,241,214,252,"fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);","fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
	  kitName);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1009.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1009.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    return false;
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");

  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
	    ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",vtkCommand,\n		    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
	    classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1009.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 133, 0, 0, 3, 3, 0, 0, 4, 38, 0, 0, 0, 0, 1, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 3, 1, 0, 47, 0, 0, 33, 0, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1009.cpp,36
a2a40b125918797471919f526edea2990e29bc69,updated to handle Tk commands compiled/linked separately. Useful for VTK Tk widgets for example.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1495.cpp,211,241,216,-1,"fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);",,7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1010.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1010.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    return false;
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");

  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
	    ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",vtkCommand,\n		    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
	    classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1010.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 133, 0, 0, 3, 3, 0, 0, 4, 38, 0, 0, 0, 0, 1, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 3, 1, 0, 47, 0, 0, 33, 0, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1010.cpp,38
a2a40b125918797471919f526edea2990e29bc69,updated to handle Tk commands compiled/linked separately. Useful for VTK Tk widgets for example.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1495.cpp,211,241,220,256,"fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");","fprintf(fout,""\nextern void vtkTclGenericDeleteObject(ClientData cd);\n"");",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1011.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1011.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    return false;
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");

  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
	    ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",vtkCommand,\n		    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
	    classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1011.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 133, 0, 0, 3, 3, 0, 0, 4, 38, 0, 0, 0, 0, 1, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 3, 1, 0, 47, 0, 0, 33, 0, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1011.cpp,42
a2a40b125918797471919f526edea2990e29bc69,updated to handle Tk commands compiled/linked separately. Useful for VTK Tk widgets for example.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1495.cpp,211,241,214,246,,"fprintf(fout,""\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n"",
            capcommands[i].c_str());",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1012.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1012.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    return false;
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");

  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
	    ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",vtkCommand,\n		    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
	    classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1012.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 133, 0, 0, 3, 3, 0, 0, 4, 38, 0, 0, 0, 0, 1, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 3, 1, 0, 47, 0, 0, 33, 0, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1012.cpp,36
a2a40b125918797471919f526edea2990e29bc69,updated to handle Tk commands compiled/linked separately. Useful for VTK Tk widgets for example.,[],Source/cmVTKWrapTclCommand.cxx,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_old_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_new_file_788.cpp,second/download/CMake/CMake-old-new/CMake-old-new/Kitware_CMake_patch_788.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_hunk_1495.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_new_hunk_1495.cpp,211,241,216,250,,"fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n"",
	  kitName);",7,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_old_log_1013.cpp,second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_new_log_1013.cpp,"{
  unsigned int i;
  std::string tempOutputFile = outFileName + "".tmp"";
  FILE *fout = fopen(tempOutputFile.c_str(),""w"");
  if (!fout)
    {
    return false;
    }
  
  fprintf(fout,""#include \""vtkTclUtil.h\""\n"");
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""int %sCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"",classes[i].c_str());
    fprintf(fout,""ClientData %sNewCommand();\n"",classes[i].c_str());
    }
  
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,""int vtkCommand(ClientData cd, Tcl_Interp *interp,\n             int argc, char *argv[]);\n"");
    fprintf(fout,""\nTcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""Tcl_HashTable vtkCommandLookup;\n"");
    }
  else
    {
    fprintf(fout,""\nextern Tcl_HashTable vtkInstanceLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkPointerLookup;\n"");
    fprintf(fout,""extern Tcl_HashTable vtkCommandLookup;\n"");
    }
  fprintf(fout,""extern void vtkTclDeleteObjectFromHash(void *);\n"");  
  fprintf(fout,""extern void vtkTclListInstances(Tcl_Interp *interp, ClientData arg);\n"");
  
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_SafeInit(Tcl_Interp *interp);}\n\n"",
	  kitName);
  fprintf(fout,""\n\nextern \""C\"" {int VTK_EXPORT %s_Init(Tcl_Interp *interp);}\n\n"",
	  kitName);
  
  /* create an extern ref to the generic delete function */
  fprintf(fout,""\n\nextern void vtkTclGenericDeleteObject(ClientData cd);\n\n"");

  /* the main declaration */
  fprintf(fout,""\n\nint VTK_EXPORT %s_SafeInit(Tcl_Interp *interp)\n{\n"",kitName);
  fprintf(fout,""  return %s_Init(interp);\n}\n"",kitName);
  
  fprintf(fout,""\n\nint VTK_EXPORT %s_Init(Tcl_Interp *interp)\n{\n"",
          kitName);
  if (!strcmp(kitName,""Vtkcommontcl""))
    {
    fprintf(fout,
	    ""  vtkTclInterpStruct *info = new vtkTclInterpStruct;\n"");
    fprintf(fout,
            ""  info->Number = 0; info->InDelete = 0; info->DebugOn = 0;\n"");
    fprintf(fout,""\n"");
    fprintf(fout,""\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->InstanceLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->PointerLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
	    ""  Tcl_InitHashTable(&info->CommandLookup, TCL_STRING_KEYS);\n"");
    fprintf(fout,
            ""  Tcl_SetAssocData(interp,(char *) \""vtk\"",NULL,(ClientData *)info);\n"");

    /* create special vtkCommand command */
    fprintf(fout,""  Tcl_CreateCommand(interp,(char *) \""vtkCommand\"",vtkCommand,\n		    (ClientData *)NULL, NULL);\n\n"");
    }
  
  for (i = 0; i < classes.size(); i++)
    {
    fprintf(fout,""  vtkTclCreateNew(interp,(char *) \""%s\"", %sNewCommand,\n"",
	    classes[i].c_str(), classes[i].c_str());
    fprintf(fout,""                  %sCommand);\n"",classes[i].c_str());
    }
  
  fprintf(fout,""  return TCL_OK;\n}\n"");
  fclose(fout);

  // copy the file if different
  cmSystemTools::CopyFileIfDifferent(tempOutputFile.c_str(),
                                     outFileName.c_str());
  cmSystemTools::RemoveFile(tempOutputFile.c_str());

  return true;
}",second/download/CMake/CMake-gumtree/Kitware_CMake_old_new_block_1013.cpp,"[3, 0, 2, 0, 0, 0, 2, 0, 0, 0, 7, 0, 0, 0, 0, 133, 0, 0, 3, 3, 0, 0, 4, 38, 0, 0, 0, 0, 1, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 131, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 3, 1, 0, 47, 0, 0, 33, 0, 80, 0, 2, 0, 0, 2, 0]",second/download/CMake/CMake-old-new/CMake-old-new-joern/Kitware_CMake_old_new_function_1013.cpp,38
